"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_components_CanvasContainer_js",{

/***/ "(pages-dir-browser)/./components/utils/canvasUtils.js":
/*!*****************************************!*\
  !*** ./components/utils/canvasUtils.js ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createAnchorPoint: () => (/* binding */ createAnchorPoint),\n/* harmony export */   drawBezierCurve: () => (/* binding */ drawBezierCurve),\n/* harmony export */   drawBezierGuides: () => (/* binding */ drawBezierGuides),\n/* harmony export */   drawImageToCanvas: () => (/* binding */ drawImageToCanvas),\n/* harmony export */   getCoordinates: () => (/* binding */ getCoordinates),\n/* harmony export */   initializeCanvas: () => (/* binding */ initializeCanvas),\n/* harmony export */   isNearHandle: () => (/* binding */ isNearHandle),\n/* harmony export */   updateHandle: () => (/* binding */ updateHandle)\n/* harmony export */ });\n// Get the correct coordinates based on canvas scaling\nconst getCoordinates = (e, canvas)=>{\n    var _e_nativeEvent_touches_, _e_nativeEvent_touches, _e_nativeEvent_touches_1, _e_nativeEvent_touches1;\n    const rect = canvas.getBoundingClientRect();\n    // Calculate the scaling factor between the internal canvas size and displayed size\n    const scaleX = canvas.width / rect.width;\n    const scaleY = canvas.height / rect.height;\n    // Apply the scaling to get accurate coordinates\n    return {\n        x: (e.nativeEvent.offsetX || ((_e_nativeEvent_touches = e.nativeEvent.touches) === null || _e_nativeEvent_touches === void 0 ? void 0 : (_e_nativeEvent_touches_ = _e_nativeEvent_touches[0]) === null || _e_nativeEvent_touches_ === void 0 ? void 0 : _e_nativeEvent_touches_.clientX) - rect.left) * scaleX,\n        y: (e.nativeEvent.offsetY || ((_e_nativeEvent_touches1 = e.nativeEvent.touches) === null || _e_nativeEvent_touches1 === void 0 ? void 0 : (_e_nativeEvent_touches_1 = _e_nativeEvent_touches1[0]) === null || _e_nativeEvent_touches_1 === void 0 ? void 0 : _e_nativeEvent_touches_1.clientY) - rect.top) * scaleY\n    };\n};\n// Initialize canvas with white background\nconst initializeCanvas = (canvas)=>{\n    const ctx = canvas.getContext(\"2d\");\n    // Fill canvas with white background\n    ctx.fillStyle = \"#FFFFFF\";\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n};\n// Draw the background image to the canvas\nconst drawImageToCanvas = (canvas, backgroundImage)=>{\n    if (!canvas || !backgroundImage) return;\n    const ctx = canvas.getContext(\"2d\");\n    // Fill with white background first\n    ctx.fillStyle = \"#FFFFFF\";\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    // Draw the background image\n    ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);\n};\n// Draw bezier curve\nconst drawBezierCurve = (canvas, points)=>{\n    const ctx = canvas.getContext('2d');\n    if (!points || points.length < 2) {\n        console.error('Need at least 2 points to draw a path');\n        return;\n    }\n    ctx.beginPath();\n    ctx.strokeStyle = '#000000';\n    ctx.lineWidth = 3;\n    // Start at the first anchor point\n    ctx.moveTo(points[0].x, points[0].y);\n    // For each pair of anchor points (and their control points)\n    for(let i = 0; i < points.length - 1; i++){\n        const current = points[i];\n        const next = points[i + 1];\n        if (current.handleOut && next.handleIn) {\n            var _current_handleOut, _current_handleOut1, _next_handleIn, _next_handleIn1;\n            // If both points have handles, draw a cubic bezier\n            ctx.bezierCurveTo(current.x + (((_current_handleOut = current.handleOut) === null || _current_handleOut === void 0 ? void 0 : _current_handleOut.x) || 0), current.y + (((_current_handleOut1 = current.handleOut) === null || _current_handleOut1 === void 0 ? void 0 : _current_handleOut1.y) || 0), next.x + (((_next_handleIn = next.handleIn) === null || _next_handleIn === void 0 ? void 0 : _next_handleIn.x) || 0), next.y + (((_next_handleIn1 = next.handleIn) === null || _next_handleIn1 === void 0 ? void 0 : _next_handleIn1.y) || 0), next.x, next.y);\n        } else {\n            // If no handles, draw a straight line\n            ctx.lineTo(next.x, next.y);\n        }\n    }\n    ctx.stroke();\n};\n// Draw bezier guides (control points and lines)\nconst drawBezierGuides = (ctx, points)=>{\n    if (!points || points.length === 0) return;\n    // Draw the path itself first (as a light preview)\n    ctx.save();\n    ctx.globalAlpha = 0.3;\n    ctx.strokeStyle = '#888888';\n    ctx.lineWidth = 1.5;\n    ctx.beginPath();\n    ctx.moveTo(points[0].x, points[0].y);\n    // For each pair of anchor points (and their control points)\n    for(let i = 0; i < points.length - 1; i++){\n        const current = points[i];\n        const next = points[i + 1];\n        if (current.handleOut && next.handleIn) {\n            var _current_handleOut, _current_handleOut1, _next_handleIn, _next_handleIn1;\n            // If both points have handles, draw a cubic bezier\n            ctx.bezierCurveTo(current.x + (((_current_handleOut = current.handleOut) === null || _current_handleOut === void 0 ? void 0 : _current_handleOut.x) || 0), current.y + (((_current_handleOut1 = current.handleOut) === null || _current_handleOut1 === void 0 ? void 0 : _current_handleOut1.y) || 0), next.x + (((_next_handleIn = next.handleIn) === null || _next_handleIn === void 0 ? void 0 : _next_handleIn.x) || 0), next.y + (((_next_handleIn1 = next.handleIn) === null || _next_handleIn1 === void 0 ? void 0 : _next_handleIn1.y) || 0), next.x, next.y);\n        } else {\n            // If no handles, draw a straight line\n            ctx.lineTo(next.x, next.y);\n        }\n    }\n    ctx.stroke();\n    ctx.restore();\n    // Draw guide lines between anchor points and their handles\n    ctx.strokeStyle = 'rgba(100, 100, 255, 0.5)';\n    ctx.lineWidth = 1;\n    points.forEach((point)=>{\n        // Draw line from anchor to in-handle if it exists\n        if (point.handleIn) {\n            ctx.beginPath();\n            ctx.moveTo(point.x, point.y);\n            ctx.lineTo(point.x + point.handleIn.x, point.y + point.handleIn.y);\n            ctx.stroke();\n        }\n        // Draw line from anchor to out-handle if it exists\n        if (point.handleOut) {\n            ctx.beginPath();\n            ctx.moveTo(point.x, point.y);\n            ctx.lineTo(point.x + point.handleOut.x, point.y + point.handleOut.y);\n            ctx.stroke();\n        }\n    });\n    // Draw anchor points (main points of the path)\n    points.forEach((point, index)=>{\n        // Draw the main anchor point\n        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';\n        ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';\n        ctx.lineWidth = 1;\n        ctx.beginPath();\n        ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.stroke();\n        // Draw the handle points if they exist\n        if (point.handleIn) {\n            ctx.fillStyle = 'rgba(100, 100, 255, 0.8)';\n            ctx.beginPath();\n            ctx.arc(point.x + point.handleIn.x, point.y + point.handleIn.y, 4, 0, Math.PI * 2);\n            ctx.fill();\n        }\n        if (point.handleOut) {\n            ctx.fillStyle = 'rgba(100, 100, 255, 0.8)';\n            ctx.beginPath();\n            ctx.arc(point.x + point.handleOut.x, point.y + point.handleOut.y, 4, 0, Math.PI * 2);\n            ctx.fill();\n        }\n    });\n};\n// Helper to create a new anchor point with handles\nconst createAnchorPoint = function(x, y) {\n    let prevPoint = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;\n    // By default, create a point with no handles\n    const point = {\n        x,\n        y,\n        handleIn: null,\n        handleOut: null\n    };\n    // If there's a previous point, automatically add symmetric handles\n    if (prevPoint) {\n        // Calculate the default handle length (as a percentage of distance to previous point)\n        const dx = x - prevPoint.x;\n        const dy = y - prevPoint.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        const handleLength = distance * 0.3; // 30% of distance between points\n        // Create handles perpendicular to the line between points\n        // For a smooth curve, make the previous point's out handle opposite to this point's in handle\n        const angle = Math.atan2(dy, dx);\n        // Add an out handle to the previous point (if it doesn't already have one)\n        if (!prevPoint.handleOut) {\n            prevPoint.handleOut = {\n                x: Math.cos(angle) * -handleLength,\n                y: Math.sin(angle) * -handleLength\n            };\n        }\n        // Add an in handle to the current point\n        point.handleIn = {\n            x: Math.cos(angle) * -handleLength,\n            y: Math.sin(angle) * -handleLength\n        };\n    }\n    return point;\n};\n// Helper to check if a point is near a handle\nconst isNearHandle = function(point, handleType, x, y) {\n    let radius = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 10;\n    if (!point || !point[handleType]) return false;\n    const handleX = point.x + point[handleType].x;\n    const handleY = point.y + point[handleType].y;\n    const dx = handleX - x;\n    const dy = handleY - y;\n    return dx * dx + dy * dy <= radius * radius;\n};\n// Helper to update a handle position\nconst updateHandle = function(point, handleType, dx, dy) {\n    let symmetric = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;\n    if (!point || !point[handleType]) return;\n    // Update the target handle\n    point[handleType].x += dx;\n    point[handleType].y += dy;\n    // If symmetric and the other handle exists, update it to be symmetrical\n    if (symmetric) {\n        const otherType = handleType === 'handleIn' ? 'handleOut' : 'handleIn';\n        if (point[otherType]) {\n            point[otherType].x = -point[handleType].x;\n            point[otherType].y = -point[handleType].y;\n        }\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvdXRpbHMvY2FudmFzVXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQSxzREFBc0Q7QUFDL0MsTUFBTUEsaUJBQWlCLENBQUNDLEdBQUdDO1FBU0FELHlCQUFBQSx3QkFDQUEsMEJBQUFBO0lBVGhDLE1BQU1FLE9BQU9ELE9BQU9FLHFCQUFxQjtJQUV6QyxtRkFBbUY7SUFDbkYsTUFBTUMsU0FBU0gsT0FBT0ksS0FBSyxHQUFHSCxLQUFLRyxLQUFLO0lBQ3hDLE1BQU1DLFNBQVNMLE9BQU9NLE1BQU0sR0FBR0wsS0FBS0ssTUFBTTtJQUUxQyxnREFBZ0Q7SUFDaEQsT0FBTztRQUNMQyxHQUFHLENBQUNSLEVBQUVTLFdBQVcsQ0FBQ0MsT0FBTyxJQUFLVixFQUFBQSx5QkFBQUEsRUFBRVMsV0FBVyxDQUFDRSxPQUFPLGNBQXJCWCw4Q0FBQUEsMEJBQUFBLHNCQUF1QixDQUFDLEVBQUUsY0FBMUJBLDhDQUFBQSx3QkFBNEJZLE9BQU8sSUFBR1YsS0FBS1csSUFBSSxJQUFLVDtRQUNsRlUsR0FBRyxDQUFDZCxFQUFFUyxXQUFXLENBQUNNLE9BQU8sSUFBS2YsRUFBQUEsMEJBQUFBLEVBQUVTLFdBQVcsQ0FBQ0UsT0FBTyxjQUFyQlgsK0NBQUFBLDJCQUFBQSx1QkFBdUIsQ0FBQyxFQUFFLGNBQTFCQSwrQ0FBQUEseUJBQTRCZ0IsT0FBTyxJQUFHZCxLQUFLZSxHQUFHLElBQUtYO0lBQ25GO0FBQ0YsRUFBRTtBQUVGLDBDQUEwQztBQUNuQyxNQUFNWSxtQkFBbUIsQ0FBQ2pCO0lBQy9CLE1BQU1rQixNQUFNbEIsT0FBT21CLFVBQVUsQ0FBQztJQUU5QixvQ0FBb0M7SUFDcENELElBQUlFLFNBQVMsR0FBRztJQUNoQkYsSUFBSUcsUUFBUSxDQUFDLEdBQUcsR0FBR3JCLE9BQU9JLEtBQUssRUFBRUosT0FBT00sTUFBTTtBQUNoRCxFQUFFO0FBRUYsMENBQTBDO0FBQ25DLE1BQU1nQixvQkFBb0Is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QUFFIiwic291cmNlcyI6WyIvVXNlcnMvdHJ1ZHlwL0Rlc2t0b3AvZGV2LWdlbWluaS0yLjAvY29tcG9uZW50cy91dGlscy9jYW52YXNVdGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBHZXQgdGhlIGNvcnJlY3QgY29vcmRpbmF0ZXMgYmFzZWQgb24gY2FudmFzIHNjYWxpbmdcbmV4cG9ydCBjb25zdCBnZXRDb29yZGluYXRlcyA9IChlLCBjYW52YXMpID0+IHtcbiAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgXG4gIC8vIENhbGN1bGF0ZSB0aGUgc2NhbGluZyBmYWN0b3IgYmV0d2VlbiB0aGUgaW50ZXJuYWwgY2FudmFzIHNpemUgYW5kIGRpc3BsYXllZCBzaXplXG4gIGNvbnN0IHNjYWxlWCA9IGNhbnZhcy53aWR0aCAvIHJlY3Qud2lkdGg7XG4gIGNvbnN0IHNjYWxlWSA9IGNhbnZhcy5oZWlnaHQgLyByZWN0LmhlaWdodDtcbiAgXG4gIC8vIEFwcGx5IHRoZSBzY2FsaW5nIHRvIGdldCBhY2N1cmF0ZSBjb29yZGluYXRlc1xuICByZXR1cm4ge1xuICAgIHg6IChlLm5hdGl2ZUV2ZW50Lm9mZnNldFggfHwgKGUubmF0aXZlRXZlbnQudG91Y2hlcz8uWzBdPy5jbGllbnRYIC0gcmVjdC5sZWZ0KSkgKiBzY2FsZVgsXG4gICAgeTogKGUubmF0aXZlRXZlbnQub2Zmc2V0WSB8fCAoZS5uYXRpdmVFdmVudC50b3VjaGVzPy5bMF0/LmNsaWVudFkgLSByZWN0LnRvcCkpICogc2NhbGVZXG4gIH07XG59O1xuXG4vLyBJbml0aWFsaXplIGNhbnZhcyB3aXRoIHdoaXRlIGJhY2tncm91bmRcbmV4cG9ydCBjb25zdCBpbml0aWFsaXplQ2FudmFzID0gKGNhbnZhcykgPT4ge1xuICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICBcbiAgLy8gRmlsbCBjYW52YXMgd2l0aCB3aGl0ZSBiYWNrZ3JvdW5kXG4gIGN0eC5maWxsU3R5bGUgPSBcIiNGRkZGRkZcIjtcbiAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG59O1xuXG4vLyBEcmF3IHRoZSBiYWNrZ3JvdW5kIGltYWdlIHRvIHRoZSBjYW52YXNcbmV4cG9ydCBjb25zdCBkcmF3SW1hZ2VUb0NhbnZhcyA9IChjYW52YXMsIGJhY2tncm91bmRJbWFnZSkgPT4ge1xuICBpZiAoIWNhbnZhcyB8fCAhYmFja2dyb3VuZEltYWdlKSByZXR1cm47XG4gIFxuICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICBcbiAgLy8gRmlsbCB3aXRoIHdoaXRlIGJhY2tncm91bmQgZmlyc3RcbiAgY3R4LmZpbGxTdHlsZSA9IFwiI0ZGRkZGRlwiO1xuICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgXG4gIC8vIERyYXcgdGhlIGJhY2tncm91bmQgaW1hZ2VcbiAgY3R4LmRyYXdJbWFnZShcbiAgICBiYWNrZ3JvdW5kSW1hZ2UsXG4gICAgMCwgMCxcbiAgICBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHRcbiAgKTtcbn07XG5cbi8vIERyYXcgYmV6aWVyIGN1cnZlXG5leHBvcnQgY29uc3QgZHJhd0JlemllckN1cnZlID0gKGNhbnZhcywgcG9pbnRzKSA9PiB7XG4gIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBcbiAgaWYgKCFwb2ludHMgfHwgcG9pbnRzLmxlbmd0aCA8IDIpIHtcbiAgICBjb25zb2xlLmVycm9yKCdOZWVkIGF0IGxlYXN0IDIgcG9pbnRzIHRvIGRyYXcgYSBwYXRoJyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIFxuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5zdHJva2VTdHlsZSA9ICcjMDAwMDAwJztcbiAgY3R4LmxpbmVXaWR0aCA9IDM7XG4gIFxuICAvLyBTdGFydCBhdCB0aGUgZmlyc3QgYW5jaG9yIHBvaW50XG4gIGN0eC5tb3ZlVG8ocG9pbnRzWzBdLngsIHBvaW50c1swXS55KTtcbiAgXG4gIC8vIEZvciBlYWNoIHBhaXIgb2YgYW5jaG9yIHBvaW50cyAoYW5kIHRoZWlyIGNvbnRyb2wgcG9pbnRzKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBjb25zdCBjdXJyZW50ID0gcG9pbnRzW2ldO1xuICAgIGNvbnN0IG5leHQgPSBwb2ludHNbaSArIDFdO1xuICAgIFxuICAgIGlmIChjdXJyZW50LmhhbmRsZU91dCAmJiBuZXh0LmhhbmRsZUluKSB7XG4gICAgICAvLyBJZiBib3RoIHBvaW50cyBoYXZlIGhhbmRsZXMsIGRyYXcgYSBjdWJpYyBiZXppZXJcbiAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICBjdXJyZW50LnggKyAoY3VycmVudC5oYW5kbGVPdXQ/LnggfHwgMCksIGN1cnJlbnQueSArIChjdXJyZW50LmhhbmRsZU91dD8ueSB8fCAwKSxcbiAgICAgICAgbmV4dC54ICsgKG5leHQuaGFuZGxlSW4/LnggfHwgMCksIG5leHQueSArIChuZXh0LmhhbmRsZUluPy55IHx8IDApLFxuICAgICAgICBuZXh0LngsIG5leHQueVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm8gaGFuZGxlcywgZHJhdyBhIHN0cmFpZ2h0IGxpbmVcbiAgICAgIGN0eC5saW5lVG8obmV4dC54LCBuZXh0LnkpO1xuICAgIH1cbiAgfVxuICBcbiAgY3R4LnN0cm9rZSgpO1xufTtcblxuLy8gRHJhdyBiZXppZXIgZ3VpZGVzIChjb250cm9sIHBvaW50cyBhbmQgbGluZXMpXG5leHBvcnQgY29uc3QgZHJhd0Jlemllckd1aWRlcyA9IChjdHgsIHBvaW50cykgPT4ge1xuICBpZiAoIXBvaW50cyB8fCBwb2ludHMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gIFxuICAvLyBEcmF3IHRoZSBwYXRoIGl0c2VsZiBmaXJzdCAoYXMgYSBsaWdodCBwcmV2aWV3KVxuICBjdHguc2F2ZSgpO1xuICBjdHguZ2xvYmFsQWxwaGEgPSAwLjM7XG4gIGN0eC5zdHJva2VTdHlsZSA9ICcjODg4ODg4JztcbiAgY3R4LmxpbmVXaWR0aCA9IDEuNTtcbiAgXG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4Lm1vdmVUbyhwb2ludHNbMF0ueCwgcG9pbnRzWzBdLnkpO1xuICBcbiAgLy8gRm9yIGVhY2ggcGFpciBvZiBhbmNob3IgcG9pbnRzIChhbmQgdGhlaXIgY29udHJvbCBwb2ludHMpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBwb2ludHNbaV07XG4gICAgY29uc3QgbmV4dCA9IHBvaW50c1tpICsgMV07XG4gICAgXG4gICAgaWYgKGN1cnJlbnQuaGFuZGxlT3V0ICYmIG5leHQuaGFuZGxlSW4pIHtcbiAgICAgIC8vIElmIGJvdGggcG9pbnRzIGhhdmUgaGFuZGxlcywgZHJhdyBhIGN1YmljIGJlemllclxuICAgICAgY3R4LmJlemllckN1cnZlVG8oXG4gICAgICAgIGN1cnJlbnQueCArIChjdXJyZW50LmhhbmRsZU91dD8ueCB8fCAwKSwgY3VycmVudC55ICsgKGN1cnJlbnQuaGFuZGxlT3V0Py55IHx8IDApLFxuICAgICAgICBuZXh0LnggKyAobmV4dC5oYW5kbGVJbj8ueCB8fCAwKSwgbmV4dC55ICsgKG5leHQuaGFuZGxlSW4/LnkgfHwgMCksXG4gICAgICAgIG5leHQueCwgbmV4dC55XG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBubyBoYW5kbGVzLCBkcmF3IGEgc3RyYWlnaHQgbGluZVxuICAgICAgY3R4LmxpbmVUbyhuZXh0LngsIG5leHQueSk7XG4gICAgfVxuICB9XG4gIFxuICBjdHguc3Ryb2tlKCk7XG4gIGN0eC5yZXN0b3JlKCk7XG4gIFxuICAvLyBEcmF3IGd1aWRlIGxpbmVzIGJldHdlZW4gYW5jaG9yIHBvaW50cyBhbmQgdGhlaXIgaGFuZGxlc1xuICBjdHguc3Ryb2tlU3R5bGUgPSAncmdiYSgxMDAsIDEwMCwgMjU1LCAwLjUpJztcbiAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gIFxuICBwb2ludHMuZm9yRWFjaChwb2ludCA9PiB7XG4gICAgLy8gRHJhdyBsaW5lIGZyb20gYW5jaG9yIHRvIGluLWhhbmRsZSBpZiBpdCBleGlzdHNcbiAgICBpZiAocG9pbnQuaGFuZGxlSW4pIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICBjdHgubGluZVRvKHBvaW50LnggKyBwb2ludC5oYW5kbGVJbi54LCBwb2ludC55ICsgcG9pbnQuaGFuZGxlSW4ueSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxuICAgIFxuICAgIC8vIERyYXcgbGluZSBmcm9tIGFuY2hvciB0byBvdXQtaGFuZGxlIGlmIGl0IGV4aXN0c1xuICAgIGlmIChwb2ludC5oYW5kbGVPdXQpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICBjdHgubGluZVRvKHBvaW50LnggKyBwb2ludC5oYW5kbGVPdXQueCwgcG9pbnQueSArIHBvaW50LmhhbmRsZU91dC55KTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG4gIH0pO1xuICBcbiAgLy8gRHJhdyBhbmNob3IgcG9pbnRzIChtYWluIHBvaW50cyBvZiB0aGUgcGF0aClcbiAgcG9pbnRzLmZvckVhY2goKHBvaW50LCBpbmRleCkgPT4ge1xuICAgIC8vIERyYXcgdGhlIG1haW4gYW5jaG9yIHBvaW50XG4gICAgY3R4LmZpbGxTdHlsZSA9ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOSknO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZ2JhKDAsIDAsIDAsIDAuOCknO1xuICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgIFxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguYXJjKHBvaW50LngsIHBvaW50LnksIDUsIDAsIE1hdGguUEkgKiAyKTtcbiAgICBjdHguZmlsbCgpO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgICBcbiAgICAvLyBEcmF3IHRoZSBoYW5kbGUgcG9pbnRzIGlmIHRoZXkgZXhpc3RcbiAgICBpZiAocG9pbnQuaGFuZGxlSW4pIHtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAncmdiYSgxMDAsIDEwMCwgMjU1LCAwLjgpJztcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5hcmMocG9pbnQueCArIHBvaW50LmhhbmRsZUluLngsIHBvaW50LnkgKyBwb2ludC5oYW5kbGVJbi55LCA0LCAwLCBNYXRoLlBJICogMik7XG4gICAgICBjdHguZmlsbCgpO1xuICAgIH1cbiAgICBcbiAgICBpZiAocG9pbnQuaGFuZGxlT3V0KSB7XG4gICAgICBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMTAwLCAxMDAsIDI1NSwgMC44KSc7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguYXJjKHBvaW50LnggKyBwb2ludC5oYW5kbGVPdXQueCwgcG9pbnQueSArIHBvaW50LmhhbmRsZU91dC55LCA0LCAwLCBNYXRoLlBJICogMik7XG4gICAgICBjdHguZmlsbCgpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vLyBIZWxwZXIgdG8gY3JlYXRlIGEgbmV3IGFuY2hvciBwb2ludCB3aXRoIGhhbmRsZXNcbmV4cG9ydCBjb25zdCBjcmVhdGVBbmNob3JQb2ludCA9ICh4LCB5LCBwcmV2UG9pbnQgPSBudWxsKSA9PiB7XG4gIC8vIEJ5IGRlZmF1bHQsIGNyZWF0ZSBhIHBvaW50IHdpdGggbm8gaGFuZGxlc1xuICBjb25zdCBwb2ludCA9IHsgeCwgeSwgaGFuZGxlSW46IG51bGwsIGhhbmRsZU91dDogbnVsbCB9O1xuICBcbiAgLy8gSWYgdGhlcmUncyBhIHByZXZpb3VzIHBvaW50LCBhdXRvbWF0aWNhbGx5IGFkZCBzeW1tZXRyaWMgaGFuZGxlc1xuICBpZiAocHJldlBvaW50KSB7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBkZWZhdWx0IGhhbmRsZSBsZW5ndGggKGFzIGEgcGVyY2VudGFnZSBvZiBkaXN0YW5jZSB0byBwcmV2aW91cyBwb2ludClcbiAgICBjb25zdCBkeCA9IHggLSBwcmV2UG9pbnQueDtcbiAgICBjb25zdCBkeSA9IHkgLSBwcmV2UG9pbnQueTtcbiAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgY29uc3QgaGFuZGxlTGVuZ3RoID0gZGlzdGFuY2UgKiAwLjM7IC8vIDMwJSBvZiBkaXN0YW5jZSBiZXR3ZWVuIHBvaW50c1xuICAgIFxuICAgIC8vIENyZWF0ZSBoYW5kbGVzIHBlcnBlbmRpY3VsYXIgdG8gdGhlIGxpbmUgYmV0d2VlbiBwb2ludHNcbiAgICAvLyBGb3IgYSBzbW9vdGggY3VydmUsIG1ha2UgdGhlIHByZXZpb3VzIHBvaW50J3Mgb3V0IGhhbmRsZSBvcHBvc2l0ZSB0byB0aGlzIHBvaW50J3MgaW4gaGFuZGxlXG4gICAgY29uc3QgYW5nbGUgPSBNYXRoLmF0YW4yKGR5LCBkeCk7XG4gICAgXG4gICAgLy8gQWRkIGFuIG91dCBoYW5kbGUgdG8gdGhlIHByZXZpb3VzIHBvaW50IChpZiBpdCBkb2Vzbid0IGFscmVhZHkgaGF2ZSBvbmUpXG4gICAgaWYgKCFwcmV2UG9pbnQuaGFuZGxlT3V0KSB7XG4gICAgICBwcmV2UG9pbnQuaGFuZGxlT3V0ID0ge1xuICAgICAgICB4OiBNYXRoLmNvcyhhbmdsZSkgKiAtaGFuZGxlTGVuZ3RoLFxuICAgICAgICB5OiBNYXRoLnNpbihhbmdsZSkgKiAtaGFuZGxlTGVuZ3RoXG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICAvLyBBZGQgYW4gaW4gaGFuZGxlIHRvIHRoZSBjdXJyZW50IHBvaW50XG4gICAgcG9pbnQuaGFuZGxlSW4gPSB7XG4gICAgICB4OiBNYXRoLmNvcyhhbmdsZSkgKiAtaGFuZGxlTGVuZ3RoLFxuICAgICAgeTogTWF0aC5zaW4oYW5nbGUpICogLWhhbmRsZUxlbmd0aFxuICAgIH07XG4gIH1cbiAgXG4gIHJldHVybiBwb2ludDtcbn07XG5cbi8vIEhlbHBlciB0byBjaGVjayBpZiBhIHBvaW50IGlzIG5lYXIgYSBoYW5kbGVcbmV4cG9ydCBjb25zdCBpc05lYXJIYW5kbGUgPSAocG9pbnQsIGhhbmRsZVR5cGUsIHgsIHksIHJhZGl1cyA9IDEwKSA9PiB7XG4gIGlmICghcG9pbnQgfHwgIXBvaW50W2hhbmRsZVR5cGVdKSByZXR1cm4gZmFsc2U7XG4gIFxuICBjb25zdCBoYW5kbGVYID0gcG9pbnQueCArIHBvaW50W2hhbmRsZVR5cGVdLng7XG4gIGNvbnN0IGhhbmRsZVkgPSBwb2ludC55ICsgcG9pbnRbaGFuZGxlVHlwZV0ueTtcbiAgXG4gIGNvbnN0IGR4ID0gaGFuZGxlWCAtIHg7XG4gIGNvbnN0IGR5ID0gaGFuZGxlWSAtIHk7XG4gIFxuICByZXR1cm4gKGR4ICogZHggKyBkeSAqIGR5KSA8PSByYWRpdXMgKiByYWRpdXM7XG59O1xuXG4vLyBIZWxwZXIgdG8gdXBkYXRlIGEgaGFuZGxlIHBvc2l0aW9uXG5leHBvcnQgY29uc3QgdXBkYXRlSGFuZGxlID0gKHBvaW50LCBoYW5kbGVUeXBlLCBkeCwgZHksIHN5bW1ldHJpYyA9IHRydWUpID0+IHtcbiAgaWYgKCFwb2ludCB8fCAhcG9pbnRbaGFuZGxlVHlwZV0pIHJldHVybjtcbiAgXG4gIC8vIFVwZGF0ZSB0aGUgdGFyZ2V0IGhhbmRsZVxuICBwb2ludFtoYW5kbGVUeXBlXS54ICs9IGR4O1xuICBwb2ludFtoYW5kbGVUeXBlXS55ICs9IGR5O1xuICBcbiAgLy8gSWYgc3ltbWV0cmljIGFuZCB0aGUgb3RoZXIgaGFuZGxlIGV4aXN0cywgdXBkYXRlIGl0IHRvIGJlIHN5bW1ldHJpY2FsXG4gIGlmIChzeW1tZXRyaWMpIHtcbiAgICBjb25zdCBvdGhlclR5cGUgPSBoYW5kbGVUeXBlID09PSAnaGFuZGxlSW4nID8gJ2hhbmRsZU91dCcgOiAnaGFuZGxlSW4nO1xuICAgIFxuICAgIGlmIChwb2ludFtvdGhlclR5cGVdKSB7XG4gICAgICBwb2ludFtvdGhlclR5cGVdLnggPSAtcG9pbnRbaGFuZGxlVHlwZV0ueDtcbiAgICAgIHBvaW50W290aGVyVHlwZV0ueSA9IC1wb2ludFtoYW5kbGVUeXBlXS55O1xuICAgIH1cbiAgfVxufTsgIl0sIm5hbWVzIjpbImdldENvb3JkaW5hdGVzIiwiZSIsImNhbnZhcyIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJzY2FsZVgiLCJ3aWR0aCIsInNjYWxlWSIsImhlaWdodCIsIngiLCJuYXRpdmVFdmVudCIsIm9mZnNldFgiLCJ0b3VjaGVzIiwiY2xpZW50WCIsImxlZnQiLCJ5Iiwib2Zmc2V0WSIsImNsaWVudFkiLCJ0b3AiLCJpbml0aWFsaXplQ2FudmFzIiwiY3R4IiwiZ2V0Q29udGV4dCIsImZpbGxTdHlsZSIsImZpbGxSZWN0IiwiZHJhd0ltYWdlVG9DYW52YXMiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJkcmF3SW1hZ2UiLCJkcmF3QmV6aWVyQ3VydmUiLCJwb2ludHMiLCJsZW5ndGgiLCJjb25zb2xlIiwiZXJyb3IiLCJiZWdpblBhdGgiLCJzdHJva2VTdHlsZSIsImxpbmVXaWR0aCIsIm1vdmVUbyIsImkiLCJjdXJyZW50IiwibmV4dCIsImhhbmRsZU91dCIsImhhbmRsZUluIiwiYmV6aWVyQ3VydmVUbyIsImxpbmVUbyIsInN0cm9rZSIsImRyYXdCZXppZXJHdWlkZXMiLCJzYXZlIiwiZ2xvYmFsQWxwaGEiLCJyZXN0b3JlIiwiZm9yRWFjaCIsInBvaW50IiwiaW5kZXgiLCJhcmMiLCJNYXRoIiwiUEkiLCJmaWxsIiwiY3JlYXRlQW5jaG9yUG9pbnQiLCJwcmV2UG9pbnQiLCJkeCIsImR5IiwiZGlzdGFuY2UiLCJzcXJ0IiwiaGFuZGxlTGVuZ3RoIiwiYW5nbGUiLCJhdGFuMiIsImNvcyIsInNpbiIsImlzTmVhckhhbmRsZSIsImhhbmRsZVR5cGUiLCJyYWRpdXMiLCJoYW5kbGVYIiwiaGFuZGxlWSIsInVwZGF0ZUhhbmRsZSIsInN5bW1ldHJpYyIsIm90aGVyVHlwZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/utils/canvasUtils.js\n"));

/***/ })

});