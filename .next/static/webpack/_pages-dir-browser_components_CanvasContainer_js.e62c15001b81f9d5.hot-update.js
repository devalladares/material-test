"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_components_CanvasContainer_js",{

/***/ "(pages-dir-browser)/./components/utils/canvasUtils.js":
/*!*****************************************!*\
  !*** ./components/utils/canvasUtils.js ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createAnchorPoint: () => (/* binding */ createAnchorPoint),\n/* harmony export */   drawBezierCurve: () => (/* binding */ drawBezierCurve),\n/* harmony export */   drawBezierGuides: () => (/* binding */ drawBezierGuides),\n/* harmony export */   drawImageToCanvas: () => (/* binding */ drawImageToCanvas),\n/* harmony export */   getCoordinates: () => (/* binding */ getCoordinates),\n/* harmony export */   initializeCanvas: () => (/* binding */ initializeCanvas),\n/* harmony export */   isNearHandle: () => (/* binding */ isNearHandle),\n/* harmony export */   updateHandle: () => (/* binding */ updateHandle)\n/* harmony export */ });\n// Get the correct coordinates based on canvas scaling\nconst getCoordinates = (e, canvas)=>{\n    var _e_nativeEvent_touches_, _e_nativeEvent_touches, _e_nativeEvent_touches_1, _e_nativeEvent_touches1;\n    const rect = canvas.getBoundingClientRect();\n    // Calculate the scaling factor between the internal canvas size and displayed size\n    const scaleX = canvas.width / rect.width;\n    const scaleY = canvas.height / rect.height;\n    // Apply the scaling to get accurate coordinates\n    return {\n        x: (e.nativeEvent.offsetX || ((_e_nativeEvent_touches = e.nativeEvent.touches) === null || _e_nativeEvent_touches === void 0 ? void 0 : (_e_nativeEvent_touches_ = _e_nativeEvent_touches[0]) === null || _e_nativeEvent_touches_ === void 0 ? void 0 : _e_nativeEvent_touches_.clientX) - rect.left) * scaleX,\n        y: (e.nativeEvent.offsetY || ((_e_nativeEvent_touches1 = e.nativeEvent.touches) === null || _e_nativeEvent_touches1 === void 0 ? void 0 : (_e_nativeEvent_touches_1 = _e_nativeEvent_touches1[0]) === null || _e_nativeEvent_touches_1 === void 0 ? void 0 : _e_nativeEvent_touches_1.clientY) - rect.top) * scaleY\n    };\n};\n// Initialize canvas with white background\nconst initializeCanvas = (canvas)=>{\n    const ctx = canvas.getContext(\"2d\");\n    // Fill canvas with white background\n    ctx.fillStyle = \"#FFFFFF\";\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n};\n// Draw the background image to the canvas\nconst drawImageToCanvas = (canvas, backgroundImage)=>{\n    if (!canvas || !backgroundImage) return;\n    const ctx = canvas.getContext(\"2d\");\n    // Fill with white background first\n    ctx.fillStyle = \"#FFFFFF\";\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    // Draw the background image\n    ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);\n};\n// Draw bezier curve\nconst drawBezierCurve = (canvas, points)=>{\n    const ctx = canvas.getContext('2d');\n    if (!points || points.length < 2) {\n        console.error('Need at least 2 points to draw a path');\n        return;\n    }\n    ctx.beginPath();\n    ctx.strokeStyle = '#000000';\n    ctx.lineWidth = 3;\n    // Start at the first anchor point\n    ctx.moveTo(points[0].x, points[0].y);\n    // For each pair of anchor points (and their control points)\n    for(let i = 0; i < points.length - 1; i++){\n        const current = points[i];\n        const next = points[i + 1];\n        if (current.handleOut && next.handleIn) {\n            var _current_handleOut, _current_handleOut1, _next_handleIn, _next_handleIn1;\n            // If both points have handles, draw a cubic bezier\n            ctx.bezierCurveTo(current.x + (((_current_handleOut = current.handleOut) === null || _current_handleOut === void 0 ? void 0 : _current_handleOut.x) || 0), current.y + (((_current_handleOut1 = current.handleOut) === null || _current_handleOut1 === void 0 ? void 0 : _current_handleOut1.y) || 0), next.x + (((_next_handleIn = next.handleIn) === null || _next_handleIn === void 0 ? void 0 : _next_handleIn.x) || 0), next.y + (((_next_handleIn1 = next.handleIn) === null || _next_handleIn1 === void 0 ? void 0 : _next_handleIn1.y) || 0), next.x, next.y);\n        } else {\n            // If no handles, draw a straight line\n            ctx.lineTo(next.x, next.y);\n        }\n    }\n    ctx.stroke();\n};\n// Draw bezier guides (control points and lines)\nconst drawBezierGuides = (ctx, points)=>{\n    if (!points || points.length === 0) return;\n    // Draw the path itself first (as a light preview)\n    ctx.save();\n    ctx.globalAlpha = 0.3;\n    ctx.strokeStyle = '#888888';\n    ctx.lineWidth = 1.5;\n    ctx.beginPath();\n    ctx.moveTo(points[0].x, points[0].y);\n    // For each pair of anchor points (and their control points)\n    for(let i = 0; i < points.length - 1; i++){\n        const current = points[i];\n        const next = points[i + 1];\n        if (current.handleOut && next.handleIn) {\n            var _current_handleOut, _current_handleOut1, _next_handleIn, _next_handleIn1;\n            // If both points have handles, draw a cubic bezier\n            ctx.bezierCurveTo(current.x + (((_current_handleOut = current.handleOut) === null || _current_handleOut === void 0 ? void 0 : _current_handleOut.x) || 0), current.y + (((_current_handleOut1 = current.handleOut) === null || _current_handleOut1 === void 0 ? void 0 : _current_handleOut1.y) || 0), next.x + (((_next_handleIn = next.handleIn) === null || _next_handleIn === void 0 ? void 0 : _next_handleIn.x) || 0), next.y + (((_next_handleIn1 = next.handleIn) === null || _next_handleIn1 === void 0 ? void 0 : _next_handleIn1.y) || 0), next.x, next.y);\n        } else {\n            // If no handles, draw a straight line\n            ctx.lineTo(next.x, next.y);\n        }\n    }\n    ctx.stroke();\n    ctx.restore();\n    // Draw guide lines between anchor points and their handles\n    ctx.strokeStyle = 'rgba(100, 100, 255, 0.5)';\n    ctx.lineWidth = 1;\n    for (const point of points){\n        // Draw line from anchor to in-handle if it exists\n        if (point.handleIn) {\n            ctx.beginPath();\n            ctx.moveTo(point.x, point.y);\n            ctx.lineTo(point.x + point.handleIn.x, point.y + point.handleIn.y);\n            ctx.stroke();\n        }\n        // Draw line from anchor to out-handle if it exists\n        if (point.handleOut) {\n            ctx.beginPath();\n            ctx.moveTo(point.x, point.y);\n            ctx.lineTo(point.x + point.handleOut.x, point.y + point.handleOut.y);\n            ctx.stroke();\n        }\n    }\n    // Draw anchor points (main points of the path)\n    for (const point of points){\n        // Draw the main anchor point\n        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';\n        ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';\n        ctx.lineWidth = 1;\n        ctx.beginPath();\n        ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.stroke();\n        // Draw the handle points if they exist\n        if (point.handleIn) {\n            ctx.fillStyle = 'rgba(100, 100, 255, 0.8)';\n            ctx.beginPath();\n            ctx.arc(point.x + point.handleIn.x, point.y + point.handleIn.y, 4, 0, Math.PI * 2);\n            ctx.fill();\n        }\n        if (point.handleOut) {\n            ctx.fillStyle = 'rgba(100, 100, 255, 0.8)';\n            ctx.beginPath();\n            ctx.arc(point.x + point.handleOut.x, point.y + point.handleOut.y, 4, 0, Math.PI * 2);\n            ctx.fill();\n        }\n    }\n};\n// Helper to create a new anchor point with handles\nconst createAnchorPoint = function(x, y) {\n    let prevPoint = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;\n    // By default, create a point with no handles\n    const point = {\n        x,\n        y,\n        handleIn: null,\n        handleOut: null\n    };\n    // If there's a previous point, automatically add symmetric handles\n    if (prevPoint) {\n        // Calculate the default handle length (as a percentage of distance to previous point)\n        const dx = x - prevPoint.x;\n        const dy = y - prevPoint.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        const handleLength = distance * 0.3; // 30% of distance between points\n        // Create handles perpendicular to the line between points\n        // For a smooth curve, make the previous point's out handle opposite to this point's in handle\n        const angle = Math.atan2(dy, dx);\n        // Add an out handle to the previous point (if it doesn't already have one)\n        if (!prevPoint.handleOut) {\n            prevPoint.handleOut = {\n                x: Math.cos(angle) * -handleLength,\n                y: Math.sin(angle) * -handleLength\n            };\n        }\n        // Add an in handle to the current point\n        point.handleIn = {\n            x: Math.cos(angle) * -handleLength,\n            y: Math.sin(angle) * -handleLength\n        };\n    }\n    return point;\n};\n// Helper to check if a point is near a handle\nconst isNearHandle = function(point, handleType, x, y) {\n    let radius = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 10;\n    if (!point || !point[handleType]) return false;\n    const handleX = point.x + point[handleType].x;\n    const handleY = point.y + point[handleType].y;\n    const dx = handleX - x;\n    const dy = handleY - y;\n    return dx * dx + dy * dy <= radius * radius;\n};\n// Helper to update a handle position\nconst updateHandle = function(point, handleType, dx, dy) {\n    let symmetric = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;\n    if (!point || !point[handleType]) return;\n    // Update the target handle\n    point[handleType].x += dx;\n    point[handleType].y += dy;\n    // If symmetric and the other handle exists, update it to be symmetrical\n    if (symmetric) {\n        const otherType = handleType === 'handleIn' ? 'handleOut' : 'handleIn';\n        if (point[otherType]) {\n            point[otherType].x = -point[handleType].x;\n            point[otherType].y = -point[handleType].y;\n        }\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvdXRpbHMvY2FudmFzVXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQSxzREFBc0Q7QUFDL0MsTUFBTUEsaUJBQWlCLENBQUNDLEdBQUdDO1FBU0FELHlCQUFBQSx3QkFDQUEsMEJBQUFBO0lBVGhDLE1BQU1FLE9BQU9ELE9BQU9FLHFCQUFxQjtJQUV6QyxtRkFBbUY7SUFDbkYsTUFBTUMsU0FBU0gsT0FBT0ksS0FBSyxHQUFHSCxLQUFLRyxLQUFLO0lBQ3hDLE1BQU1DLFNBQVNMLE9BQU9NLE1BQU0sR0FBR0wsS0FBS0ssTUFBTTtJQUUxQyxnREFBZ0Q7SUFDaEQsT0FBTztRQUNMQyxHQUFHLENBQUNSLEVBQUVTLFdBQVcsQ0FBQ0MsT0FBTyxJQUFLVixFQUFBQSx5QkFBQUEsRUFBRVMsV0FBVyxDQUFDRSxPQUFPLGNBQXJCWCw4Q0FBQUEsMEJBQUFBLHNCQUF1QixDQUFDLEVBQUUsY0FBMUJBLDhDQUFBQSx3QkFBNEJZLE9BQU8sSUFBR1YsS0FBS1csSUFBSSxJQUFLVDtRQUNsRlUsR0FBRyxDQUFDZCxFQUFFUyxXQUFXLENBQUNNLE9BQU8sSUFBS2YsRUFBQUEsMEJBQUFBLEVBQUVTLFdBQVcsQ0FBQ0UsT0FBTyxjQUFyQlgsK0NBQUFBLDJCQUFBQSx1QkFBdUIsQ0FBQyxFQUFFLGNBQTFCQSwrQ0FBQUEseUJBQTRCZ0IsT0FBTyxJQUFHZCxLQUFLZSxHQUFHLElBQUtYO0lBQ25GO0FBQ0YsRUFBRTtBQUVGLDBDQUEwQztBQUNuQyxNQUFNWSxtQkFBbUIsQ0FBQ2pCO0lBQy9CLE1BQU1rQixNQUFNbEIsT0FBT21CLFVBQVUsQ0FBQztJQUU5QixvQ0FBb0M7SUFDcENELElBQUlFLFNBQVMsR0FBRztJQUNoQkYsSUFBSUcsUUFBUSxDQUFDLEdBQUcsR0FBR3JCLE9BQU9JLEtBQUssRUFBRUosT0FBT00sTUFBTTtBQUNoRCxFQUFFO0FBRUYsMENBQTBDO0FBQ25DLE1BQU1nQixvQkFBb0Is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cyI6WyIvVXNlcnMvdHJ1ZHlwL0Rlc2t0b3AvZGV2LWdlbWluaS0yLjAvY29tcG9uZW50cy91dGlscy9jYW52YXNVdGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBHZXQgdGhlIGNvcnJlY3QgY29vcmRpbmF0ZXMgYmFzZWQgb24gY2FudmFzIHNjYWxpbmdcbmV4cG9ydCBjb25zdCBnZXRDb29yZGluYXRlcyA9IChlLCBjYW52YXMpID0+IHtcbiAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgXG4gIC8vIENhbGN1bGF0ZSB0aGUgc2NhbGluZyBmYWN0b3IgYmV0d2VlbiB0aGUgaW50ZXJuYWwgY2FudmFzIHNpemUgYW5kIGRpc3BsYXllZCBzaXplXG4gIGNvbnN0IHNjYWxlWCA9IGNhbnZhcy53aWR0aCAvIHJlY3Qud2lkdGg7XG4gIGNvbnN0IHNjYWxlWSA9IGNhbnZhcy5oZWlnaHQgLyByZWN0LmhlaWdodDtcbiAgXG4gIC8vIEFwcGx5IHRoZSBzY2FsaW5nIHRvIGdldCBhY2N1cmF0ZSBjb29yZGluYXRlc1xuICByZXR1cm4ge1xuICAgIHg6IChlLm5hdGl2ZUV2ZW50Lm9mZnNldFggfHwgKGUubmF0aXZlRXZlbnQudG91Y2hlcz8uWzBdPy5jbGllbnRYIC0gcmVjdC5sZWZ0KSkgKiBzY2FsZVgsXG4gICAgeTogKGUubmF0aXZlRXZlbnQub2Zmc2V0WSB8fCAoZS5uYXRpdmVFdmVudC50b3VjaGVzPy5bMF0/LmNsaWVudFkgLSByZWN0LnRvcCkpICogc2NhbGVZXG4gIH07XG59O1xuXG4vLyBJbml0aWFsaXplIGNhbnZhcyB3aXRoIHdoaXRlIGJhY2tncm91bmRcbmV4cG9ydCBjb25zdCBpbml0aWFsaXplQ2FudmFzID0gKGNhbnZhcykgPT4ge1xuICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICBcbiAgLy8gRmlsbCBjYW52YXMgd2l0aCB3aGl0ZSBiYWNrZ3JvdW5kXG4gIGN0eC5maWxsU3R5bGUgPSBcIiNGRkZGRkZcIjtcbiAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG59O1xuXG4vLyBEcmF3IHRoZSBiYWNrZ3JvdW5kIGltYWdlIHRvIHRoZSBjYW52YXNcbmV4cG9ydCBjb25zdCBkcmF3SW1hZ2VUb0NhbnZhcyA9IChjYW52YXMsIGJhY2tncm91bmRJbWFnZSkgPT4ge1xuICBpZiAoIWNhbnZhcyB8fCAhYmFja2dyb3VuZEltYWdlKSByZXR1cm47XG4gIFxuICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICBcbiAgLy8gRmlsbCB3aXRoIHdoaXRlIGJhY2tncm91bmQgZmlyc3RcbiAgY3R4LmZpbGxTdHlsZSA9IFwiI0ZGRkZGRlwiO1xuICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgXG4gIC8vIERyYXcgdGhlIGJhY2tncm91bmQgaW1hZ2VcbiAgY3R4LmRyYXdJbWFnZShcbiAgICBiYWNrZ3JvdW5kSW1hZ2UsXG4gICAgMCwgMCxcbiAgICBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHRcbiAgKTtcbn07XG5cbi8vIERyYXcgYmV6aWVyIGN1cnZlXG5leHBvcnQgY29uc3QgZHJhd0JlemllckN1cnZlID0gKGNhbnZhcywgcG9pbnRzKSA9PiB7XG4gIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBcbiAgaWYgKCFwb2ludHMgfHwgcG9pbnRzLmxlbmd0aCA8IDIpIHtcbiAgICBjb25zb2xlLmVycm9yKCdOZWVkIGF0IGxlYXN0IDIgcG9pbnRzIHRvIGRyYXcgYSBwYXRoJyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIFxuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5zdHJva2VTdHlsZSA9ICcjMDAwMDAwJztcbiAgY3R4LmxpbmVXaWR0aCA9IDM7XG4gIFxuICAvLyBTdGFydCBhdCB0aGUgZmlyc3QgYW5jaG9yIHBvaW50XG4gIGN0eC5tb3ZlVG8ocG9pbnRzWzBdLngsIHBvaW50c1swXS55KTtcbiAgXG4gIC8vIEZvciBlYWNoIHBhaXIgb2YgYW5jaG9yIHBvaW50cyAoYW5kIHRoZWlyIGNvbnRyb2wgcG9pbnRzKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBjb25zdCBjdXJyZW50ID0gcG9pbnRzW2ldO1xuICAgIGNvbnN0IG5leHQgPSBwb2ludHNbaSArIDFdO1xuICAgIFxuICAgIGlmIChjdXJyZW50LmhhbmRsZU91dCAmJiBuZXh0LmhhbmRsZUluKSB7XG4gICAgICAvLyBJZiBib3RoIHBvaW50cyBoYXZlIGhhbmRsZXMsIGRyYXcgYSBjdWJpYyBiZXppZXJcbiAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICBjdXJyZW50LnggKyAoY3VycmVudC5oYW5kbGVPdXQ/LnggfHwgMCksIGN1cnJlbnQueSArIChjdXJyZW50LmhhbmRsZU91dD8ueSB8fCAwKSxcbiAgICAgICAgbmV4dC54ICsgKG5leHQuaGFuZGxlSW4/LnggfHwgMCksIG5leHQueSArIChuZXh0LmhhbmRsZUluPy55IHx8IDApLFxuICAgICAgICBuZXh0LngsIG5leHQueVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm8gaGFuZGxlcywgZHJhdyBhIHN0cmFpZ2h0IGxpbmVcbiAgICAgIGN0eC5saW5lVG8obmV4dC54LCBuZXh0LnkpO1xuICAgIH1cbiAgfVxuICBcbiAgY3R4LnN0cm9rZSgpO1xufTtcblxuLy8gRHJhdyBiZXppZXIgZ3VpZGVzIChjb250cm9sIHBvaW50cyBhbmQgbGluZXMpXG5leHBvcnQgY29uc3QgZHJhd0Jlemllckd1aWRlcyA9IChjdHgsIHBvaW50cykgPT4ge1xuICBpZiAoIXBvaW50cyB8fCBwb2ludHMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gIFxuICAvLyBEcmF3IHRoZSBwYXRoIGl0c2VsZiBmaXJzdCAoYXMgYSBsaWdodCBwcmV2aWV3KVxuICBjdHguc2F2ZSgpO1xuICBjdHguZ2xvYmFsQWxwaGEgPSAwLjM7XG4gIGN0eC5zdHJva2VTdHlsZSA9ICcjODg4ODg4JztcbiAgY3R4LmxpbmVXaWR0aCA9IDEuNTtcbiAgXG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4Lm1vdmVUbyhwb2ludHNbMF0ueCwgcG9pbnRzWzBdLnkpO1xuICBcbiAgLy8gRm9yIGVhY2ggcGFpciBvZiBhbmNob3IgcG9pbnRzIChhbmQgdGhlaXIgY29udHJvbCBwb2ludHMpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBwb2ludHNbaV07XG4gICAgY29uc3QgbmV4dCA9IHBvaW50c1tpICsgMV07XG4gICAgXG4gICAgaWYgKGN1cnJlbnQuaGFuZGxlT3V0ICYmIG5leHQuaGFuZGxlSW4pIHtcbiAgICAgIC8vIElmIGJvdGggcG9pbnRzIGhhdmUgaGFuZGxlcywgZHJhdyBhIGN1YmljIGJlemllclxuICAgICAgY3R4LmJlemllckN1cnZlVG8oXG4gICAgICAgIGN1cnJlbnQueCArIChjdXJyZW50LmhhbmRsZU91dD8ueCB8fCAwKSwgY3VycmVudC55ICsgKGN1cnJlbnQuaGFuZGxlT3V0Py55IHx8IDApLFxuICAgICAgICBuZXh0LnggKyAobmV4dC5oYW5kbGVJbj8ueCB8fCAwKSwgbmV4dC55ICsgKG5leHQuaGFuZGxlSW4/LnkgfHwgMCksXG4gICAgICAgIG5leHQueCwgbmV4dC55XG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBubyBoYW5kbGVzLCBkcmF3IGEgc3RyYWlnaHQgbGluZVxuICAgICAgY3R4LmxpbmVUbyhuZXh0LngsIG5leHQueSk7XG4gICAgfVxuICB9XG4gIFxuICBjdHguc3Ryb2tlKCk7XG4gIGN0eC5yZXN0b3JlKCk7XG4gIFxuICAvLyBEcmF3IGd1aWRlIGxpbmVzIGJldHdlZW4gYW5jaG9yIHBvaW50cyBhbmQgdGhlaXIgaGFuZGxlc1xuICBjdHguc3Ryb2tlU3R5bGUgPSAncmdiYSgxMDAsIDEwMCwgMjU1LCAwLjUpJztcbiAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gIFxuICBmb3IgKGNvbnN0IHBvaW50IG9mIHBvaW50cykge1xuICAgIC8vIERyYXcgbGluZSBmcm9tIGFuY2hvciB0byBpbi1oYW5kbGUgaWYgaXQgZXhpc3RzXG4gICAgaWYgKHBvaW50LmhhbmRsZUluKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgY3R4LmxpbmVUbyhwb2ludC54ICsgcG9pbnQuaGFuZGxlSW4ueCwgcG9pbnQueSArIHBvaW50LmhhbmRsZUluLnkpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgICBcbiAgICAvLyBEcmF3IGxpbmUgZnJvbSBhbmNob3IgdG8gb3V0LWhhbmRsZSBpZiBpdCBleGlzdHNcbiAgICBpZiAocG9pbnQuaGFuZGxlT3V0KSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgY3R4LmxpbmVUbyhwb2ludC54ICsgcG9pbnQuaGFuZGxlT3V0LngsIHBvaW50LnkgKyBwb2ludC5oYW5kbGVPdXQueSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxuICB9XG4gIFxuICAvLyBEcmF3IGFuY2hvciBwb2ludHMgKG1haW4gcG9pbnRzIG9mIHRoZSBwYXRoKVxuICBmb3IgKGNvbnN0IHBvaW50IG9mIHBvaW50cykge1xuICAgIC8vIERyYXcgdGhlIG1haW4gYW5jaG9yIHBvaW50XG4gICAgY3R4LmZpbGxTdHlsZSA9ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOSknO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZ2JhKDAsIDAsIDAsIDAuOCknO1xuICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgIFxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguYXJjKHBvaW50LngsIHBvaW50LnksIDUsIDAsIE1hdGguUEkgKiAyKTtcbiAgICBjdHguZmlsbCgpO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgICBcbiAgICAvLyBEcmF3IHRoZSBoYW5kbGUgcG9pbnRzIGlmIHRoZXkgZXhpc3RcbiAgICBpZiAocG9pbnQuaGFuZGxlSW4pIHtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAncmdiYSgxMDAsIDEwMCwgMjU1LCAwLjgpJztcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5hcmMocG9pbnQueCArIHBvaW50LmhhbmRsZUluLngsIHBvaW50LnkgKyBwb2ludC5oYW5kbGVJbi55LCA0LCAwLCBNYXRoLlBJICogMik7XG4gICAgICBjdHguZmlsbCgpO1xuICAgIH1cbiAgICBcbiAgICBpZiAocG9pbnQuaGFuZGxlT3V0KSB7XG4gICAgICBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMTAwLCAxMDAsIDI1NSwgMC44KSc7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguYXJjKHBvaW50LnggKyBwb2ludC5oYW5kbGVPdXQueCwgcG9pbnQueSArIHBvaW50LmhhbmRsZU91dC55LCA0LCAwLCBNYXRoLlBJICogMik7XG4gICAgICBjdHguZmlsbCgpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gSGVscGVyIHRvIGNyZWF0ZSBhIG5ldyBhbmNob3IgcG9pbnQgd2l0aCBoYW5kbGVzXG5leHBvcnQgY29uc3QgY3JlYXRlQW5jaG9yUG9pbnQgPSAoeCwgeSwgcHJldlBvaW50ID0gbnVsbCkgPT4ge1xuICAvLyBCeSBkZWZhdWx0LCBjcmVhdGUgYSBwb2ludCB3aXRoIG5vIGhhbmRsZXNcbiAgY29uc3QgcG9pbnQgPSB7IHgsIHksIGhhbmRsZUluOiBudWxsLCBoYW5kbGVPdXQ6IG51bGwgfTtcbiAgXG4gIC8vIElmIHRoZXJlJ3MgYSBwcmV2aW91cyBwb2ludCwgYXV0b21hdGljYWxseSBhZGQgc3ltbWV0cmljIGhhbmRsZXNcbiAgaWYgKHByZXZQb2ludCkge1xuICAgIC8vIENhbGN1bGF0ZSB0aGUgZGVmYXVsdCBoYW5kbGUgbGVuZ3RoIChhcyBhIHBlcmNlbnRhZ2Ugb2YgZGlzdGFuY2UgdG8gcHJldmlvdXMgcG9pbnQpXG4gICAgY29uc3QgZHggPSB4IC0gcHJldlBvaW50Lng7XG4gICAgY29uc3QgZHkgPSB5IC0gcHJldlBvaW50Lnk7XG4gICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIGNvbnN0IGhhbmRsZUxlbmd0aCA9IGRpc3RhbmNlICogMC4zOyAvLyAzMCUgb2YgZGlzdGFuY2UgYmV0d2VlbiBwb2ludHNcbiAgICBcbiAgICAvLyBDcmVhdGUgaGFuZGxlcyBwZXJwZW5kaWN1bGFyIHRvIHRoZSBsaW5lIGJldHdlZW4gcG9pbnRzXG4gICAgLy8gRm9yIGEgc21vb3RoIGN1cnZlLCBtYWtlIHRoZSBwcmV2aW91cyBwb2ludCdzIG91dCBoYW5kbGUgb3Bwb3NpdGUgdG8gdGhpcyBwb2ludCdzIGluIGhhbmRsZVxuICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5hdGFuMihkeSwgZHgpO1xuICAgIFxuICAgIC8vIEFkZCBhbiBvdXQgaGFuZGxlIHRvIHRoZSBwcmV2aW91cyBwb2ludCAoaWYgaXQgZG9lc24ndCBhbHJlYWR5IGhhdmUgb25lKVxuICAgIGlmICghcHJldlBvaW50LmhhbmRsZU91dCkge1xuICAgICAgcHJldlBvaW50LmhhbmRsZU91dCA9IHtcbiAgICAgICAgeDogTWF0aC5jb3MoYW5nbGUpICogLWhhbmRsZUxlbmd0aCxcbiAgICAgICAgeTogTWF0aC5zaW4oYW5nbGUpICogLWhhbmRsZUxlbmd0aFxuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgLy8gQWRkIGFuIGluIGhhbmRsZSB0byB0aGUgY3VycmVudCBwb2ludFxuICAgIHBvaW50LmhhbmRsZUluID0ge1xuICAgICAgeDogTWF0aC5jb3MoYW5nbGUpICogLWhhbmRsZUxlbmd0aCxcbiAgICAgIHk6IE1hdGguc2luKGFuZ2xlKSAqIC1oYW5kbGVMZW5ndGhcbiAgICB9O1xuICB9XG4gIFxuICByZXR1cm4gcG9pbnQ7XG59O1xuXG4vLyBIZWxwZXIgdG8gY2hlY2sgaWYgYSBwb2ludCBpcyBuZWFyIGEgaGFuZGxlXG5leHBvcnQgY29uc3QgaXNOZWFySGFuZGxlID0gKHBvaW50LCBoYW5kbGVUeXBlLCB4LCB5LCByYWRpdXMgPSAxMCkgPT4ge1xuICBpZiAoIXBvaW50IHx8ICFwb2ludFtoYW5kbGVUeXBlXSkgcmV0dXJuIGZhbHNlO1xuICBcbiAgY29uc3QgaGFuZGxlWCA9IHBvaW50LnggKyBwb2ludFtoYW5kbGVUeXBlXS54O1xuICBjb25zdCBoYW5kbGVZID0gcG9pbnQueSArIHBvaW50W2hhbmRsZVR5cGVdLnk7XG4gIFxuICBjb25zdCBkeCA9IGhhbmRsZVggLSB4O1xuICBjb25zdCBkeSA9IGhhbmRsZVkgLSB5O1xuICBcbiAgcmV0dXJuIChkeCAqIGR4ICsgZHkgKiBkeSkgPD0gcmFkaXVzICogcmFkaXVzO1xufTtcblxuLy8gSGVscGVyIHRvIHVwZGF0ZSBhIGhhbmRsZSBwb3NpdGlvblxuZXhwb3J0IGNvbnN0IHVwZGF0ZUhhbmRsZSA9IChwb2ludCwgaGFuZGxlVHlwZSwgZHgsIGR5LCBzeW1tZXRyaWMgPSB0cnVlKSA9PiB7XG4gIGlmICghcG9pbnQgfHwgIXBvaW50W2hhbmRsZVR5cGVdKSByZXR1cm47XG4gIFxuICAvLyBVcGRhdGUgdGhlIHRhcmdldCBoYW5kbGVcbiAgcG9pbnRbaGFuZGxlVHlwZV0ueCArPSBkeDtcbiAgcG9pbnRbaGFuZGxlVHlwZV0ueSArPSBkeTtcbiAgXG4gIC8vIElmIHN5bW1ldHJpYyBhbmQgdGhlIG90aGVyIGhhbmRsZSBleGlzdHMsIHVwZGF0ZSBpdCB0byBiZSBzeW1tZXRyaWNhbFxuICBpZiAoc3ltbWV0cmljKSB7XG4gICAgY29uc3Qgb3RoZXJUeXBlID0gaGFuZGxlVHlwZSA9PT0gJ2hhbmRsZUluJyA/ICdoYW5kbGVPdXQnIDogJ2hhbmRsZUluJztcbiAgICBcbiAgICBpZiAocG9pbnRbb3RoZXJUeXBlXSkge1xuICAgICAgcG9pbnRbb3RoZXJUeXBlXS54ID0gLXBvaW50W2hhbmRsZVR5cGVdLng7XG4gICAgICBwb2ludFtvdGhlclR5cGVdLnkgPSAtcG9pbnRbaGFuZGxlVHlwZV0ueTtcbiAgICB9XG4gIH1cbn07ICJdLCJuYW1lcyI6WyJnZXRDb29yZGluYXRlcyIsImUiLCJjYW52YXMiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwic2NhbGVYIiwid2lkdGgiLCJzY2FsZVkiLCJoZWlnaHQiLCJ4IiwibmF0aXZlRXZlbnQiLCJvZmZzZXRYIiwidG91Y2hlcyIsImNsaWVudFgiLCJsZWZ0IiwieSIsIm9mZnNldFkiLCJjbGllbnRZIiwidG9wIiwiaW5pdGlhbGl6ZUNhbnZhcyIsImN0eCIsImdldENvbnRleHQiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsImRyYXdJbWFnZVRvQ2FudmFzIiwiYmFja2dyb3VuZEltYWdlIiwiZHJhd0ltYWdlIiwiZHJhd0JlemllckN1cnZlIiwicG9pbnRzIiwibGVuZ3RoIiwiY29uc29sZSIsImVycm9yIiwiYmVnaW5QYXRoIiwic3Ryb2tlU3R5bGUiLCJsaW5lV2lkdGgiLCJtb3ZlVG8iLCJpIiwiY3VycmVudCIsIm5leHQiLCJoYW5kbGVPdXQiLCJoYW5kbGVJbiIsImJlemllckN1cnZlVG8iLCJsaW5lVG8iLCJzdHJva2UiLCJkcmF3QmV6aWVyR3VpZGVzIiwic2F2ZSIsImdsb2JhbEFscGhhIiwicmVzdG9yZSIsInBvaW50IiwiYXJjIiwiTWF0aCIsIlBJIiwiZmlsbCIsImNyZWF0ZUFuY2hvclBvaW50IiwicHJldlBvaW50IiwiZHgiLCJkeSIsImRpc3RhbmNlIiwic3FydCIsImhhbmRsZUxlbmd0aCIsImFuZ2xlIiwiYXRhbjIiLCJjb3MiLCJzaW4iLCJpc05lYXJIYW5kbGUiLCJoYW5kbGVUeXBlIiwicmFkaXVzIiwiaGFuZGxlWCIsImhhbmRsZVkiLCJ1cGRhdGVIYW5kbGUiLCJzeW1tZXRyaWMiLCJvdGhlclR5cGUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/utils/canvasUtils.js\n"));

/***/ })

});