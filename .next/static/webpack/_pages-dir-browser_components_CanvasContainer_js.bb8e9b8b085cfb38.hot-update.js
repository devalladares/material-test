"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_components_CanvasContainer_js",{

/***/ "(pages-dir-browser)/./components/Canvas.js":
/*!******************************!*\
  !*** ./components/Canvas.js ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\nvar _s = $RefreshSig$();\n\nconst Canvas = (param)=>{\n    let { canvasRef, currentTool, isDrawing, startDrawing, draw, stopDrawing, handleCanvasClick, handlePenClick, handleGeneration, tempPoints, setTempPoints } = param;\n    _s();\n    const [showBezierGuides, setShowBezierGuides] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [dragPointIndex, setDragPointIndex] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(-1);\n    // Add touch event prevention function\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Canvas.useEffect\": ()=>{\n            // Function to prevent default touch behavior on canvas\n            const preventTouchDefault = {\n                \"Canvas.useEffect.preventTouchDefault\": (e)=>{\n                    if (isDrawing) {\n                        e.preventDefault();\n                    }\n                }\n            }[\"Canvas.useEffect.preventTouchDefault\"];\n            // Add event listener when component mounts\n            const canvas = canvasRef.current;\n            if (canvas) {\n                canvas.addEventListener('touchstart', preventTouchDefault, {\n                    passive: false\n                });\n                canvas.addEventListener('touchmove', preventTouchDefault, {\n                    passive: false\n                });\n            }\n            // Remove event listener when component unmounts\n            return ({\n                \"Canvas.useEffect\": ()=>{\n                    if (canvas) {\n                        canvas.removeEventListener('touchstart', preventTouchDefault);\n                        canvas.removeEventListener('touchmove', preventTouchDefault);\n                    }\n                }\n            })[\"Canvas.useEffect\"];\n        }\n    }[\"Canvas.useEffect\"], [\n        isDrawing,\n        canvasRef\n    ]);\n    // Add debugging info to console\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Canvas.useEffect\": ()=>{\n            console.log('Canvas tool changed or isDrawing changed:', {\n                currentTool,\n                isDrawing\n            });\n        }\n    }[\"Canvas.useEffect\"], [\n        currentTool,\n        isDrawing\n    ]);\n    // Redraw bezier guides and control points when tempPoints change\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Canvas.useEffect\": ()=>{\n            if (currentTool === 'pen' && tempPoints.length > 0 && showBezierGuides) {\n                redrawBezierGuides();\n            }\n        }\n    }[\"Canvas.useEffect\"], [\n        tempPoints,\n        showBezierGuides,\n        currentTool\n    ]);\n    const handleKeyDown = (e)=>{\n        // Add keyboard accessibility\n        if (e.key === 'Enter' || e.key === ' ') {\n            handleCanvasClick(e);\n        }\n    };\n    // Draw bezier control points and guide lines\n    const redrawBezierGuides = ()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        // Get the canvas context\n        const ctx = canvas.getContext('2d');\n        // Save the current canvas state to redraw later\n        const canvasImage = new Image();\n        canvasImage.src = canvas.toDataURL();\n        canvasImage.onload = ()=>{\n            // Clear canvas\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            // Redraw the canvas content\n            ctx.drawImage(canvasImage, 0, 0);\n            // Draw the control points and guide lines\n            drawBezierGuides(ctx);\n        };\n    };\n    // Draw bezier control points and guide lines\n    const drawBezierGuides = (ctx)=>{\n        if (tempPoints.length === 0) return;\n        // Draw guide lines between control points\n        ctx.beginPath();\n        ctx.strokeStyle = 'rgba(100, 100, 255, 0.5)';\n        ctx.lineWidth = 1;\n        ctx.moveTo(tempPoints[0].x, tempPoints[0].y);\n        for(let i = 1; i < tempPoints.length; i++){\n            ctx.lineTo(tempPoints[i].x, tempPoints[i].y);\n        }\n        ctx.stroke();\n        // Draw control points\n        tempPoints.forEach((point, index)=>{\n            ctx.fillStyle = index === 0 || index === tempPoints.length - 1 ? 'rgba(255, 100, 100, 0.8)' : 'rgba(100, 100, 255, 0.8)';\n            ctx.beginPath();\n            ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);\n            ctx.fill();\n            // Add index label to each control point\n            ctx.fillStyle = 'white';\n            ctx.font = '10px Arial';\n            ctx.textAlign = 'center';\n            ctx.textBaseline = 'middle';\n            ctx.fillText(index + 1, point.x, point.y);\n        });\n    };\n    // Custom handler for stopping drawing with pen tool\n    const handleStopDrawing = (e)=>{\n        console.log('handleStopDrawing called', {\n            eventType: e.type,\n            currentTool,\n            isDrawing,\n            handleGenerationExists: !!handleGeneration\n        });\n        // Log more details about the isDrawing state just before processing\n        console.log('CRITICAL CHECK - Before stopDrawing: isDrawing =', isDrawing, 'currentTool =', currentTool);\n        // If we were dragging a bezier control point, stop dragging\n        if (currentTool === 'pen' && dragPointIndex !== -1) {\n            setDragPointIndex(-1);\n            return;\n        }\n        stopDrawing(e);\n        // If using the pen tool or pencil tool and we've just finished a drag, trigger generation\n        if ((currentTool === 'pen' || currentTool === 'pencil') && isDrawing) {\n            console.log(\"\".concat(currentTool, \" tool condition met, will try to trigger generation\"));\n            // Small delay to ensure the drawing is complete\n            setTimeout(()=>{\n                console.log('Attempting to call handleGeneration after timeout');\n                if (typeof handleGeneration === 'function') {\n                    console.log('Calling handleGeneration function');\n                    handleGeneration();\n                } else {\n                    console.error('handleGeneration is not a function:', handleGeneration);\n                }\n            }, 100);\n        } else {\n            console.log('Generation not triggered because:', {\n                isPenTool: currentTool === 'pen',\n                isPencilTool: currentTool === 'pencil',\n                wasDrawing: isDrawing\n            });\n        }\n    };\n    // Handle mouse down for bezier control point dragging\n    const handleBezierMouseDown = (e)=>{\n        if (currentTool !== 'pen' || !showBezierGuides || tempPoints.length === 0) {\n            return false;\n        }\n        const canvas = canvasRef.current;\n        const { x, y } = getCoordinates(e, canvas);\n        // Check if we clicked on a control point\n        for(let i = 0; i < tempPoints.length; i++){\n            const point = tempPoints[i];\n            const distance = Math.sqrt((point.x - x) ** 2 + (point.y - y) ** 2);\n            if (distance <= 10) {\n                setDragPointIndex(i);\n                return true;\n            }\n        }\n        return false;\n    };\n    // Handle mouse move for bezier control point dragging\n    const handleBezierMouseMove = (e)=>{\n        if (currentTool !== 'pen' || dragPointIndex === -1) {\n            return false;\n        }\n        const canvas = canvasRef.current;\n        const { x, y } = getCoordinates(e, canvas);\n        // Update the position of the control point being dragged\n        const newPoints = [\n            ...tempPoints\n        ];\n        newPoints[dragPointIndex] = {\n            x,\n            y\n        };\n        setTempPoints(newPoints);\n        return true;\n    };\n    // Get coordinates relative to canvas\n    const getCoordinates = (e, canvas)=>{\n        const rect = canvas.getBoundingClientRect();\n        const scaleX = canvas.width / rect.width;\n        const scaleY = canvas.height / rect.height;\n        if (e.type.includes('touch')) {\n            return {\n                x: (e.touches[0].clientX - rect.left) * scaleX,\n                y: (e.touches[0].clientY - rect.top) * scaleY\n            };\n        }\n        return {\n            x: (e.clientX - rect.left) * scaleX,\n            y: (e.clientY - rect.top) * scaleY\n        };\n    };\n    // Handle doubleclick to add a control point between two existing points\n    const handleDoubleClick = (e)=>{\n        if (currentTool !== 'pen' || !showBezierGuides || tempPoints.length < 2) {\n            return;\n        }\n        const canvas = canvasRef.current;\n        const { x, y } = getCoordinates(e, canvas);\n        // Find the closest line segment to add a point to\n        let closestDistance = Number.POSITIVE_INFINITY;\n        let insertIndex = -1;\n        for(let i = 0; i < tempPoints.length - 1; i++){\n            const p1 = tempPoints[i];\n            const p2 = tempPoints[i + 1];\n            // Calculate distance from point to line segment\n            const distance = distanceToLineSegment(p1, p2, {\n                x,\n                y\n            });\n            if (distance < closestDistance && distance < 20) {\n                closestDistance = distance;\n                insertIndex = i + 1;\n            }\n        }\n        // If we found a close line segment, insert the new point\n        if (insertIndex !== -1) {\n            const newPoints = [\n                ...tempPoints\n            ];\n            newPoints.splice(insertIndex, 0, {\n                x,\n                y\n            });\n            setTempPoints(newPoints);\n        }\n    };\n    // Calculate distance from point to line segment\n    const distanceToLineSegment = (p1, p2, p)=>{\n        const { x: x1, y: y1 } = p1;\n        const { x: x2, y: y2 } = p2;\n        const { x, y } = p;\n        // Length of the line segment squared\n        const lengthSquared = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n        // If the line segment is just a point, return the distance to that point\n        if (lengthSquared === 0) return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));\n        // Calculate the projection ratio\n        const t = Math.max(0, Math.min(1, ((x - x1) * (x2 - x1) + (y - y1) * (y2 - y1)) / lengthSquared));\n        // Calculate the closest point on the line segment\n        const projectionX = x1 + t * (x2 - x1);\n        const projectionY = y1 + t * (y2 - y1);\n        // Return the distance to the closest point\n        return Math.sqrt((x - projectionX) * (x - projectionX) + (y - projectionY) * (y - projectionY));\n    };\n    // Handle clicks for bezier curve tool\n    const handlePenToolClick = (e)=>{\n        const canvas = canvasRef.current;\n        const { x, y } = getCoordinates(e, canvas);\n        // Add the point to our list of control points\n        handlePenClick(e);\n        // After adding 4 points (or more for complex beziers), draw the curve\n        if (tempPoints.length >= 3) {\n            // Show guide lines and control points\n            setShowBezierGuides(true);\n        }\n    };\n    // Toggle bezier guide visibility\n    const toggleBezierGuides = ()=>{\n        setShowBezierGuides(!showBezierGuides);\n        if (showBezierGuides) {\n            redrawBezierGuides();\n        }\n    };\n    // Draw the final bezier curve and clear control points\n    const finalizeBezierCurve = ()=>{\n        if (tempPoints.length < 4) {\n            // Need at least 4 points for cubic bezier\n            console.log('Need at least 4 control points to draw a cubic bezier curve');\n            return;\n        }\n        const canvas = canvasRef.current;\n        const ctx = canvas.getContext('2d');\n        // Draw the actual bezier curve\n        ctx.beginPath();\n        ctx.strokeStyle = '#000000';\n        ctx.lineWidth = 3;\n        ctx.moveTo(tempPoints[0].x, tempPoints[0].y);\n        // For cubic bezier curve with multiple segments\n        for(let i = 0; i < tempPoints.length - 3; i += 3){\n            ctx.bezierCurveTo(tempPoints[i + 1].x, tempPoints[i + 1].y, tempPoints[i + 2].x, tempPoints[i + 2].y, tempPoints[i + 3].x, tempPoints[i + 3].y);\n        }\n        ctx.stroke();\n        // Hide guides and reset control points\n        setShowBezierGuides(false);\n        setTempPoints([]);\n        // Trigger generation\n        setTimeout(()=>{\n            if (typeof handleGeneration === 'function') {\n                handleGeneration();\n            }\n        }, 100);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"relative\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                className: \"text-lg font-bold mb-2\",\n                children: \"Draw here:\"\n            }, void 0, false, {\n                fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                lineNumber: 343,\n                columnNumber: 7\n            }, undefined),\n            currentTool === 'pen' && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex mb-2 gap-2\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        type: \"button\",\n                        onClick: toggleBezierGuides,\n                        className: \"px-2 py-1 bg-blue-500 text-white rounded text-sm\",\n                        children: showBezierGuides ? 'Hide Guides' : 'Show Guides'\n                    }, void 0, false, {\n                        fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                        lineNumber: 347,\n                        columnNumber: 11\n                    }, undefined),\n                    tempPoints.length >= 4 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        type: \"button\",\n                        onClick: finalizeBezierCurve,\n                        className: \"px-2 py-1 bg-green-500 text-white rounded text-sm\",\n                        children: \"Draw Curve\"\n                    }, void 0, false, {\n                        fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                        lineNumber: 356,\n                        columnNumber: 13\n                    }, undefined),\n                    tempPoints.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        type: \"button\",\n                        onClick: ()=>setTempPoints([]),\n                        className: \"px-2 py-1 bg-red-500 text-white rounded text-sm\",\n                        children: \"Clear Points\"\n                    }, void 0, false, {\n                        fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                        lineNumber: 366,\n                        columnNumber: 13\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"text-sm\",\n                        children: [\n                            tempPoints.length,\n                            \" points \",\n                            tempPoints.length >= 4 ? '(ready)' : '(need 4+)'\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                        lineNumber: 375,\n                        columnNumber: 11\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                lineNumber: 346,\n                columnNumber: 9\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n                ref: canvasRef,\n                width: 960,\n                height: 540,\n                onMouseDown: (e)=>{\n                    console.log('Canvas onMouseDown', {\n                        currentTool,\n                        isDrawing\n                    });\n                    // For pen (bezier) tool, handle differently\n                    if (currentTool === 'pen') {\n                        // First check if we're interacting with a control point\n                        if (!handleBezierMouseDown(e)) {\n                            // If not interacting with existing points, add a new point\n                            handlePenToolClick(e);\n                        }\n                    } else {\n                        // For other tools, use the regular drawing behavior\n                        console.log('Executing regular startDrawing handler');\n                        startDrawing(e);\n                    }\n                },\n                onMouseMove: (e)=>{\n                    // For pen (bezier) tool, handle control point dragging\n                    if (currentTool === 'pen' && handleBezierMouseMove(e)) {\n                        // If we handled a bezier control point move, return early\n                        return;\n                    }\n                    // For other tools, use regular drawing\n                    draw(e);\n                },\n                onMouseUp: (e)=>{\n                    console.log('onMouseUp event triggered', {\n                        currentTool,\n                        isDrawing\n                    });\n                    handleStopDrawing(e);\n                },\n                onMouseLeave: (e)=>{\n                    console.log('onMouseLeave event triggered', {\n                        currentTool,\n                        isDrawing\n                    });\n                    handleStopDrawing(e);\n                },\n                onDoubleClick: handleDoubleClick,\n                onClick: handleCanvasClick,\n                onTouchStart: startDrawing,\n                onTouchMove: draw,\n                onTouchEnd: handleStopDrawing,\n                onKeyDown: handleKeyDown,\n                tabIndex: 0,\n                className: \"border-2 border-black w-full sm:h-[60vh] h-[30vh] min-h-[320px] bg-white/90 touch-none \".concat(currentTool === 'pen' ? 'cursor-crosshair' : 'hover:cursor-crosshair'),\n                \"aria-label\": \"Drawing canvas\"\n            }, void 0, false, {\n                fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                lineNumber: 381,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n        lineNumber: 342,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Canvas, \"5UOPcRNYdIkoafSpF5C8POG/t8Q=\");\n_c = Canvas;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Canvas);\nvar _c;\n$RefreshReg$(_c, \"Canvas\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QkFBc0IzRCxJQUFJO3dCQUNyRCwwREFBMEQ7d0JBQzFEO29CQUNGO29CQUVBLHVDQUF1QztvQkFDdkNaLEtBQUtZO2dCQUNQO2dCQUNBd0csV0FBVyxDQUFDeEc7b0JBQ1ZPLFFBQVFDLEdBQUcsQ0FBQyw2QkFBNkI7d0JBQUV2Qjt3QkFBYUM7b0JBQVU7b0JBQ2xFNEQsa0JBQWtCOUM7Z0JBQ3BCO2dCQUNBeUcsY0FBYyxDQUFDekc7b0JBQ2JPLFFBQVFDLEdBQUcsQ0FBQyxnQ0FBZ0M7d0JBQUV2Qjt3QkFBYUM7b0JBQVU7b0JBQ3JFNEQsa0JBQWtCOUM7Z0JBQ3BCO2dCQUNBMEcsZUFBZW5DO2dCQUNmNEIsU0FBUzdHO2dCQUNUcUgsY0FBY3hIO2dCQUNkeUgsYUFBYXhIO2dCQUNieUgsWUFBWS9EO2dCQUNaZ0UsV0FBV25HO2dCQUNYb0csVUFBVTtnQkFDVmYsV0FBVywwRkFFVixPQURDL0csZ0JBQWdCLFFBQVEscUJBQXFCO2dCQUUvQytILGNBQVc7Ozs7Ozs7Ozs7OztBQUluQjtHQTlhTWpJO0tBQUFBO0FBZ2JOLGlFQUFlQSxNQUFNQSxFQUFDIiwic291cmNlcyI6WyIvVXNlcnMvdHJ1ZHlwL0Rlc2t0b3AvZGV2LWdlbWluaS0yLjAvY29tcG9uZW50cy9DYW52YXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlUmVmLCB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuXG5jb25zdCBDYW52YXMgPSAoe1xuICBjYW52YXNSZWYsXG4gIGN1cnJlbnRUb29sLFxuICBpc0RyYXdpbmcsXG4gIHN0YXJ0RHJhd2luZyxcbiAgZHJhdyxcbiAgc3RvcERyYXdpbmcsXG4gIGhhbmRsZUNhbnZhc0NsaWNrLFxuICBoYW5kbGVQZW5DbGljayxcbiAgaGFuZGxlR2VuZXJhdGlvbixcbiAgdGVtcFBvaW50cyxcbiAgc2V0VGVtcFBvaW50c1xufSkgPT4ge1xuICBjb25zdCBbc2hvd0Jlemllckd1aWRlcywgc2V0U2hvd0Jlemllckd1aWRlc10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtkcmFnUG9pbnRJbmRleCwgc2V0RHJhZ1BvaW50SW5kZXhdID0gdXNlU3RhdGUoLTEpO1xuXG4gIC8vIEFkZCB0b3VjaCBldmVudCBwcmV2ZW50aW9uIGZ1bmN0aW9uXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gRnVuY3Rpb24gdG8gcHJldmVudCBkZWZhdWx0IHRvdWNoIGJlaGF2aW9yIG9uIGNhbnZhc1xuICAgIGNvbnN0IHByZXZlbnRUb3VjaERlZmF1bHQgPSAoZSkgPT4ge1xuICAgICAgaWYgKGlzRHJhd2luZykge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIEFkZCBldmVudCBsaXN0ZW5lciB3aGVuIGNvbXBvbmVudCBtb3VudHNcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBpZiAoY2FudmFzKSB7XG4gICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHByZXZlbnRUb3VjaERlZmF1bHQsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgcHJldmVudFRvdWNoRGVmYXVsdCwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgZXZlbnQgbGlzdGVuZXIgd2hlbiBjb21wb25lbnQgdW5tb3VudHNcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHByZXZlbnRUb3VjaERlZmF1bHQpO1xuICAgICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgcHJldmVudFRvdWNoRGVmYXVsdCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2lzRHJhd2luZywgY2FudmFzUmVmXSk7XG5cbiAgLy8gQWRkIGRlYnVnZ2luZyBpbmZvIHRvIGNvbnNvbGVcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zb2xlLmxvZygnQ2FudmFzIHRvb2wgY2hhbmdlZCBvciBpc0RyYXdpbmcgY2hhbmdlZDonLCB7IGN1cnJlbnRUb29sLCBpc0RyYXdpbmcgfSk7XG4gIH0sIFtjdXJyZW50VG9vbCwgaXNEcmF3aW5nXSk7XG5cbiAgLy8gUmVkcmF3IGJlemllciBndWlkZXMgYW5kIGNvbnRyb2wgcG9pbnRzIHdoZW4gdGVtcFBvaW50cyBjaGFuZ2VcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoY3VycmVudFRvb2wgPT09ICdwZW4nICYmIHRlbXBQb2ludHMubGVuZ3RoID4gMCAmJiBzaG93QmV6aWVyR3VpZGVzKSB7XG4gICAgICByZWRyYXdCZXppZXJHdWlkZXMoKTtcbiAgICB9XG4gIH0sIFt0ZW1wUG9pbnRzLCBzaG93QmV6aWVyR3VpZGVzLCBjdXJyZW50VG9vbF0pO1xuXG4gIGNvbnN0IGhhbmRsZUtleURvd24gPSAoZSkgPT4ge1xuICAgIC8vIEFkZCBrZXlib2FyZCBhY2Nlc3NpYmlsaXR5XG4gICAgaWYgKGUua2V5ID09PSAnRW50ZXInIHx8IGUua2V5ID09PSAnICcpIHtcbiAgICAgIGhhbmRsZUNhbnZhc0NsaWNrKGUpO1xuICAgIH1cbiAgfTtcblxuICAvLyBEcmF3IGJlemllciBjb250cm9sIHBvaW50cyBhbmQgZ3VpZGUgbGluZXNcbiAgY29uc3QgcmVkcmF3QmV6aWVyR3VpZGVzID0gKCkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGlmICghY2FudmFzKSByZXR1cm47XG4gICAgXG4gICAgLy8gR2V0IHRoZSBjYW52YXMgY29udGV4dFxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIFxuICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgY2FudmFzIHN0YXRlIHRvIHJlZHJhdyBsYXRlclxuICAgIGNvbnN0IGNhbnZhc0ltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgY2FudmFzSW1hZ2Uuc3JjID0gY2FudmFzLnRvRGF0YVVSTCgpO1xuICAgIFxuICAgIGNhbnZhc0ltYWdlLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIC8vIENsZWFyIGNhbnZhc1xuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgXG4gICAgICAvLyBSZWRyYXcgdGhlIGNhbnZhcyBjb250ZW50XG4gICAgICBjdHguZHJhd0ltYWdlKGNhbnZhc0ltYWdlLCAwLCAwKTtcbiAgICAgIFxuICAgICAgLy8gRHJhdyB0aGUgY29udHJvbCBwb2ludHMgYW5kIGd1aWRlIGxpbmVzXG4gICAgICBkcmF3QmV6aWVyR3VpZGVzKGN0eCk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBEcmF3IGJlemllciBjb250cm9sIHBvaW50cyBhbmQgZ3VpZGUgbGluZXNcbiAgY29uc3QgZHJhd0Jlemllckd1aWRlcyA9IChjdHgpID0+IHtcbiAgICBpZiAodGVtcFBvaW50cy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICBcbiAgICAvLyBEcmF3IGd1aWRlIGxpbmVzIGJldHdlZW4gY29udHJvbCBwb2ludHNcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gJ3JnYmEoMTAwLCAxMDAsIDI1NSwgMC41KSc7XG4gICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgY3R4Lm1vdmVUbyh0ZW1wUG9pbnRzWzBdLngsIHRlbXBQb2ludHNbMF0ueSk7XG4gICAgXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0ZW1wUG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjdHgubGluZVRvKHRlbXBQb2ludHNbaV0ueCwgdGVtcFBvaW50c1tpXS55KTtcbiAgICB9XG4gICAgY3R4LnN0cm9rZSgpO1xuICAgIFxuICAgIC8vIERyYXcgY29udHJvbCBwb2ludHNcbiAgICB0ZW1wUG9pbnRzLmZvckVhY2goKHBvaW50LCBpbmRleCkgPT4ge1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGluZGV4ID09PSAwIHx8IGluZGV4ID09PSB0ZW1wUG9pbnRzLmxlbmd0aCAtIDEgPyBcbiAgICAgICAgJ3JnYmEoMjU1LCAxMDAsIDEwMCwgMC44KScgOiAncmdiYSgxMDAsIDEwMCwgMjU1LCAwLjgpJztcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5hcmMocG9pbnQueCwgcG9pbnQueSwgNSwgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIFxuICAgICAgLy8gQWRkIGluZGV4IGxhYmVsIHRvIGVhY2ggY29udHJvbCBwb2ludFxuICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICBjdHguZm9udCA9ICcxMHB4IEFyaWFsJztcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgIGN0eC5maWxsVGV4dChpbmRleCArIDEsIHBvaW50LngsIHBvaW50LnkpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIEN1c3RvbSBoYW5kbGVyIGZvciBzdG9wcGluZyBkcmF3aW5nIHdpdGggcGVuIHRvb2xcbiAgY29uc3QgaGFuZGxlU3RvcERyYXdpbmcgPSAoZSkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdoYW5kbGVTdG9wRHJhd2luZyBjYWxsZWQnLCB7IFxuICAgICAgZXZlbnRUeXBlOiBlLnR5cGUsIFxuICAgICAgY3VycmVudFRvb2wsIFxuICAgICAgaXNEcmF3aW5nLCBcbiAgICAgIGhhbmRsZUdlbmVyYXRpb25FeGlzdHM6ICEhaGFuZGxlR2VuZXJhdGlvbiBcbiAgICB9KTtcbiAgICBcbiAgICAvLyBMb2cgbW9yZSBkZXRhaWxzIGFib3V0IHRoZSBpc0RyYXdpbmcgc3RhdGUganVzdCBiZWZvcmUgcHJvY2Vzc2luZ1xuICAgIGNvbnNvbGUubG9nKCdDUklUSUNBTCBDSEVDSyAtIEJlZm9yZSBzdG9wRHJhd2luZzogaXNEcmF3aW5nID0nLCBpc0RyYXdpbmcsICdjdXJyZW50VG9vbCA9JywgY3VycmVudFRvb2wpO1xuICAgIFxuICAgIC8vIElmIHdlIHdlcmUgZHJhZ2dpbmcgYSBiZXppZXIgY29udHJvbCBwb2ludCwgc3RvcCBkcmFnZ2luZ1xuICAgIGlmIChjdXJyZW50VG9vbCA9PT0gJ3BlbicgJiYgZHJhZ1BvaW50SW5kZXggIT09IC0xKSB7XG4gICAgICBzZXREcmFnUG9pbnRJbmRleCgtMSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIHN0b3BEcmF3aW5nKGUpO1xuICAgIFxuICAgIC8vIElmIHVzaW5nIHRoZSBwZW4gdG9vbCBvciBwZW5jaWwgdG9vbCBhbmQgd2UndmUganVzdCBmaW5pc2hlZCBhIGRyYWcsIHRyaWdnZXIgZ2VuZXJhdGlvblxuICAgIGlmICgoY3VycmVudFRvb2wgPT09ICdwZW4nIHx8IGN1cnJlbnRUb29sID09PSAncGVuY2lsJykgJiYgaXNEcmF3aW5nKSB7XG4gICAgICBjb25zb2xlLmxvZyhgJHtjdXJyZW50VG9vbH0gdG9vbCBjb25kaXRpb24gbWV0LCB3aWxsIHRyeSB0byB0cmlnZ2VyIGdlbmVyYXRpb25gKTtcbiAgICAgIFxuICAgICAgLy8gU21hbGwgZGVsYXkgdG8gZW5zdXJlIHRoZSBkcmF3aW5nIGlzIGNvbXBsZXRlXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ0F0dGVtcHRpbmcgdG8gY2FsbCBoYW5kbGVHZW5lcmF0aW9uIGFmdGVyIHRpbWVvdXQnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVHZW5lcmF0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ0NhbGxpbmcgaGFuZGxlR2VuZXJhdGlvbiBmdW5jdGlvbicpO1xuICAgICAgICAgIGhhbmRsZUdlbmVyYXRpb24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdoYW5kbGVHZW5lcmF0aW9uIGlzIG5vdCBhIGZ1bmN0aW9uOicsIGhhbmRsZUdlbmVyYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9LCAxMDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZygnR2VuZXJhdGlvbiBub3QgdHJpZ2dlcmVkIGJlY2F1c2U6JywgeyBcbiAgICAgICAgaXNQZW5Ub29sOiBjdXJyZW50VG9vbCA9PT0gJ3BlbicsXG4gICAgICAgIGlzUGVuY2lsVG9vbDogY3VycmVudFRvb2wgPT09ICdwZW5jaWwnLFxuICAgICAgICB3YXNEcmF3aW5nOiBpc0RyYXdpbmcgXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gSGFuZGxlIG1vdXNlIGRvd24gZm9yIGJlemllciBjb250cm9sIHBvaW50IGRyYWdnaW5nXG4gIGNvbnN0IGhhbmRsZUJlemllck1vdXNlRG93biA9IChlKSA9PiB7XG4gICAgaWYgKGN1cnJlbnRUb29sICE9PSAncGVuJyB8fCAhc2hvd0Jlemllckd1aWRlcyB8fCB0ZW1wUG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGdldENvb3JkaW5hdGVzKGUsIGNhbnZhcyk7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgd2UgY2xpY2tlZCBvbiBhIGNvbnRyb2wgcG9pbnRcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRlbXBQb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gdGVtcFBvaW50c1tpXTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KChwb2ludC54IC0geCkgKiogMiArIChwb2ludC55IC0geSkgKiogMik7XG4gICAgICBcbiAgICAgIGlmIChkaXN0YW5jZSA8PSAxMCkgeyAvLyBJZiB3aXRoaW4gMTBweCByYWRpdXMgb2YgY29udHJvbCBwb2ludFxuICAgICAgICBzZXREcmFnUG9pbnRJbmRleChpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgXG4gIC8vIEhhbmRsZSBtb3VzZSBtb3ZlIGZvciBiZXppZXIgY29udHJvbCBwb2ludCBkcmFnZ2luZ1xuICBjb25zdCBoYW5kbGVCZXppZXJNb3VzZU1vdmUgPSAoZSkgPT4ge1xuICAgIGlmIChjdXJyZW50VG9vbCAhPT0gJ3BlbicgfHwgZHJhZ1BvaW50SW5kZXggPT09IC0xKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0Q29vcmRpbmF0ZXMoZSwgY2FudmFzKTtcbiAgICBcbiAgICAvLyBVcGRhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sIHBvaW50IGJlaW5nIGRyYWdnZWRcbiAgICBjb25zdCBuZXdQb2ludHMgPSBbLi4udGVtcFBvaW50c107XG4gICAgbmV3UG9pbnRzW2RyYWdQb2ludEluZGV4XSA9IHsgeCwgeSB9O1xuICAgIHNldFRlbXBQb2ludHMobmV3UG9pbnRzKTtcbiAgICBcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBHZXQgY29vcmRpbmF0ZXMgcmVsYXRpdmUgdG8gY2FudmFzXG4gIGNvbnN0IGdldENvb3JkaW5hdGVzID0gKGUsIGNhbnZhcykgPT4ge1xuICAgIGNvbnN0IHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3Qgc2NhbGVYID0gY2FudmFzLndpZHRoIC8gcmVjdC53aWR0aDtcbiAgICBjb25zdCBzY2FsZVkgPSBjYW52YXMuaGVpZ2h0IC8gcmVjdC5oZWlnaHQ7XG4gICAgXG4gICAgaWYgKGUudHlwZS5pbmNsdWRlcygndG91Y2gnKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogKGUudG91Y2hlc1swXS5jbGllbnRYIC0gcmVjdC5sZWZ0KSAqIHNjYWxlWCxcbiAgICAgICAgeTogKGUudG91Y2hlc1swXS5jbGllbnRZIC0gcmVjdC50b3ApICogc2NhbGVZXG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgeDogKGUuY2xpZW50WCAtIHJlY3QubGVmdCkgKiBzY2FsZVgsXG4gICAgICB5OiAoZS5jbGllbnRZIC0gcmVjdC50b3ApICogc2NhbGVZXG4gICAgfTtcbiAgfTtcblxuICAvLyBIYW5kbGUgZG91YmxlY2xpY2sgdG8gYWRkIGEgY29udHJvbCBwb2ludCBiZXR3ZWVuIHR3byBleGlzdGluZyBwb2ludHNcbiAgY29uc3QgaGFuZGxlRG91YmxlQ2xpY2sgPSAoZSkgPT4ge1xuICAgIGlmIChjdXJyZW50VG9vbCAhPT0gJ3BlbicgfHwgIXNob3dCZXppZXJHdWlkZXMgfHwgdGVtcFBvaW50cy5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0Q29vcmRpbmF0ZXMoZSwgY2FudmFzKTtcbiAgICBcbiAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IGxpbmUgc2VnbWVudCB0byBhZGQgYSBwb2ludCB0b1xuICAgIGxldCBjbG9zZXN0RGlzdGFuY2UgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IGluc2VydEluZGV4ID0gLTE7XG4gICAgXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZW1wUG9pbnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgY29uc3QgcDEgPSB0ZW1wUG9pbnRzW2ldO1xuICAgICAgY29uc3QgcDIgPSB0ZW1wUG9pbnRzW2kgKyAxXTtcbiAgICAgIFxuICAgICAgLy8gQ2FsY3VsYXRlIGRpc3RhbmNlIGZyb20gcG9pbnQgdG8gbGluZSBzZWdtZW50XG4gICAgICBjb25zdCBkaXN0YW5jZSA9IGRpc3RhbmNlVG9MaW5lU2VnbWVudChwMSwgcDIsIHsgeCwgeSB9KTtcbiAgICAgIFxuICAgICAgaWYgKGRpc3RhbmNlIDwgY2xvc2VzdERpc3RhbmNlICYmIGRpc3RhbmNlIDwgMjApIHsgLy8gV2l0aGluIDIwcHggb2YgbGluZVxuICAgICAgICBjbG9zZXN0RGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgICAgaW5zZXJ0SW5kZXggPSBpICsgMTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gSWYgd2UgZm91bmQgYSBjbG9zZSBsaW5lIHNlZ21lbnQsIGluc2VydCB0aGUgbmV3IHBvaW50XG4gICAgaWYgKGluc2VydEluZGV4ICE9PSAtMSkge1xuICAgICAgY29uc3QgbmV3UG9pbnRzID0gWy4uLnRlbXBQb2ludHNdO1xuICAgICAgbmV3UG9pbnRzLnNwbGljZShpbnNlcnRJbmRleCwgMCwgeyB4LCB5IH0pO1xuICAgICAgc2V0VGVtcFBvaW50cyhuZXdQb2ludHMpO1xuICAgIH1cbiAgfTtcbiAgXG4gIC8vIENhbGN1bGF0ZSBkaXN0YW5jZSBmcm9tIHBvaW50IHRvIGxpbmUgc2VnbWVudFxuICBjb25zdCBkaXN0YW5jZVRvTGluZVNlZ21lbnQgPSAocDEsIHAyLCBwKSA9PiB7XG4gICAgY29uc3QgeyB4OiB4MSwgeTogeTEgfSA9IHAxO1xuICAgIGNvbnN0IHsgeDogeDIsIHk6IHkyIH0gPSBwMjtcbiAgICBjb25zdCB7IHgsIHkgfSA9IHA7XG4gICAgXG4gICAgLy8gTGVuZ3RoIG9mIHRoZSBsaW5lIHNlZ21lbnQgc3F1YXJlZFxuICAgIGNvbnN0IGxlbmd0aFNxdWFyZWQgPSAoeDIgLSB4MSkgKiAoeDIgLSB4MSkgKyAoeTIgLSB5MSkgKiAoeTIgLSB5MSk7XG4gICAgXG4gICAgLy8gSWYgdGhlIGxpbmUgc2VnbWVudCBpcyBqdXN0IGEgcG9pbnQsIHJldHVybiB0aGUgZGlzdGFuY2UgdG8gdGhhdCBwb2ludFxuICAgIGlmIChsZW5ndGhTcXVhcmVkID09PSAwKSByZXR1cm4gTWF0aC5zcXJ0KCh4IC0geDEpICogKHggLSB4MSkgKyAoeSAtIHkxKSAqICh5IC0geTEpKTtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgdGhlIHByb2plY3Rpb24gcmF0aW9cbiAgICBjb25zdCB0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKCh4IC0geDEpICogKHgyIC0geDEpICsgKHkgLSB5MSkgKiAoeTIgLSB5MSkpIC8gbGVuZ3RoU3F1YXJlZCkpO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSB0aGUgY2xvc2VzdCBwb2ludCBvbiB0aGUgbGluZSBzZWdtZW50XG4gICAgY29uc3QgcHJvamVjdGlvblggPSB4MSArIHQgKiAoeDIgLSB4MSk7XG4gICAgY29uc3QgcHJvamVjdGlvblkgPSB5MSArIHQgKiAoeTIgLSB5MSk7XG4gICAgXG4gICAgLy8gUmV0dXJuIHRoZSBkaXN0YW5jZSB0byB0aGUgY2xvc2VzdCBwb2ludFxuICAgIHJldHVybiBNYXRoLnNxcnQoKHggLSBwcm9qZWN0aW9uWCkgKiAoeCAtIHByb2plY3Rpb25YKSArICh5IC0gcHJvamVjdGlvblkpICogKHkgLSBwcm9qZWN0aW9uWSkpO1xuICB9O1xuXG4gIC8vIEhhbmRsZSBjbGlja3MgZm9yIGJlemllciBjdXJ2ZSB0b29sXG4gIGNvbnN0IGhhbmRsZVBlblRvb2xDbGljayA9IChlKSA9PiB7XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBnZXRDb29yZGluYXRlcyhlLCBjYW52YXMpO1xuICAgIFxuICAgIC8vIEFkZCB0aGUgcG9pbnQgdG8gb3VyIGxpc3Qgb2YgY29udHJvbCBwb2ludHNcbiAgICBoYW5kbGVQZW5DbGljayhlKTtcbiAgICBcbiAgICAvLyBBZnRlciBhZGRpbmcgNCBwb2ludHMgKG9yIG1vcmUgZm9yIGNvbXBsZXggYmV6aWVycyksIGRyYXcgdGhlIGN1cnZlXG4gICAgaWYgKHRlbXBQb2ludHMubGVuZ3RoID49IDMpIHtcbiAgICAgIC8vIFNob3cgZ3VpZGUgbGluZXMgYW5kIGNvbnRyb2wgcG9pbnRzXG4gICAgICBzZXRTaG93QmV6aWVyR3VpZGVzKHRydWUpO1xuICAgIH1cbiAgfTtcbiAgXG4gIC8vIFRvZ2dsZSBiZXppZXIgZ3VpZGUgdmlzaWJpbGl0eVxuICBjb25zdCB0b2dnbGVCZXppZXJHdWlkZXMgPSAoKSA9PiB7XG4gICAgc2V0U2hvd0Jlemllckd1aWRlcyghc2hvd0Jlemllckd1aWRlcyk7XG4gICAgaWYgKHNob3dCZXppZXJHdWlkZXMpIHtcbiAgICAgIHJlZHJhd0Jlemllckd1aWRlcygpO1xuICAgIH1cbiAgfTtcblxuICAvLyBEcmF3IHRoZSBmaW5hbCBiZXppZXIgY3VydmUgYW5kIGNsZWFyIGNvbnRyb2wgcG9pbnRzXG4gIGNvbnN0IGZpbmFsaXplQmV6aWVyQ3VydmUgPSAoKSA9PiB7XG4gICAgaWYgKHRlbXBQb2ludHMubGVuZ3RoIDwgNCkge1xuICAgICAgLy8gTmVlZCBhdCBsZWFzdCA0IHBvaW50cyBmb3IgY3ViaWMgYmV6aWVyXG4gICAgICBjb25zb2xlLmxvZygnTmVlZCBhdCBsZWFzdCA0IGNvbnRyb2wgcG9pbnRzIHRvIGRyYXcgYSBjdWJpYyBiZXppZXIgY3VydmUnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgXG4gICAgLy8gRHJhdyB0aGUgYWN0dWFsIGJlemllciBjdXJ2ZVxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAnIzAwMDAwMCc7XG4gICAgY3R4LmxpbmVXaWR0aCA9IDM7XG4gICAgY3R4Lm1vdmVUbyh0ZW1wUG9pbnRzWzBdLngsIHRlbXBQb2ludHNbMF0ueSk7XG4gICAgXG4gICAgLy8gRm9yIGN1YmljIGJlemllciBjdXJ2ZSB3aXRoIG11bHRpcGxlIHNlZ21lbnRzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZW1wUG9pbnRzLmxlbmd0aCAtIDM7IGkgKz0gMykge1xuICAgICAgY3R4LmJlemllckN1cnZlVG8oXG4gICAgICAgIHRlbXBQb2ludHNbaSArIDFdLngsIHRlbXBQb2ludHNbaSArIDFdLnksXG4gICAgICAgIHRlbXBQb2ludHNbaSArIDJdLngsIHRlbXBQb2ludHNbaSArIDJdLnksXG4gICAgICAgIHRlbXBQb2ludHNbaSArIDNdLngsIHRlbXBQb2ludHNbaSArIDNdLnlcbiAgICAgICk7XG4gICAgfVxuICAgIFxuICAgIGN0eC5zdHJva2UoKTtcbiAgICBcbiAgICAvLyBIaWRlIGd1aWRlcyBhbmQgcmVzZXQgY29udHJvbCBwb2ludHNcbiAgICBzZXRTaG93QmV6aWVyR3VpZGVzKGZhbHNlKTtcbiAgICBzZXRUZW1wUG9pbnRzKFtdKTtcbiAgICBcbiAgICAvLyBUcmlnZ2VyIGdlbmVyYXRpb25cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlR2VuZXJhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBoYW5kbGVHZW5lcmF0aW9uKCk7XG4gICAgICB9XG4gICAgfSwgMTAwKTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwicmVsYXRpdmVcIj5cbiAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LWxnIGZvbnQtYm9sZCBtYi0yXCI+RHJhdyBoZXJlOjwvaDI+XG4gICAgICBcbiAgICAgIHtjdXJyZW50VG9vbCA9PT0gJ3BlbicgJiYgKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggbWItMiBnYXAtMlwiPlxuICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgb25DbGljaz17dG9nZ2xlQmV6aWVyR3VpZGVzfVxuICAgICAgICAgICAgY2xhc3NOYW1lPVwicHgtMiBweS0xIGJnLWJsdWUtNTAwIHRleHQtd2hpdGUgcm91bmRlZCB0ZXh0LXNtXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICB7c2hvd0Jlemllckd1aWRlcyA/ICdIaWRlIEd1aWRlcycgOiAnU2hvdyBHdWlkZXMnfVxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgIFxuICAgICAgICAgIHt0ZW1wUG9pbnRzLmxlbmd0aCA+PSA0ICYmIChcbiAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgIG9uQ2xpY2s9e2ZpbmFsaXplQmV6aWVyQ3VydmV9XG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cInB4LTIgcHktMSBiZy1ncmVlbi01MDAgdGV4dC13aGl0ZSByb3VuZGVkIHRleHQtc21cIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICBEcmF3IEN1cnZlXG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICApfVxuICAgICAgICAgIFxuICAgICAgICAgIHt0ZW1wUG9pbnRzLmxlbmd0aCA+IDAgJiYgKFxuICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0VGVtcFBvaW50cyhbXSl9XG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cInB4LTIgcHktMSBiZy1yZWQtNTAwIHRleHQtd2hpdGUgcm91bmRlZCB0ZXh0LXNtXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgQ2xlYXIgUG9pbnRzXG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICApfVxuICAgICAgICAgIFxuICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtc21cIj5cbiAgICAgICAgICAgIHt0ZW1wUG9pbnRzLmxlbmd0aH0gcG9pbnRzIHt0ZW1wUG9pbnRzLmxlbmd0aCA+PSA0ID8gJyhyZWFkeSknIDogJyhuZWVkIDQrKSd9XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG4gICAgICBcbiAgICAgIDxjYW52YXNcbiAgICAgICAgcmVmPXtjYW52YXNSZWZ9XG4gICAgICAgIHdpZHRoPXs5NjB9XG4gICAgICAgIGhlaWdodD17NTQwfVxuICAgICAgICBvbk1vdXNlRG93bj17KGUpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnQ2FudmFzIG9uTW91c2VEb3duJywgeyBjdXJyZW50VG9vbCwgaXNEcmF3aW5nIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEZvciBwZW4gKGJlemllcikgdG9vbCwgaGFuZGxlIGRpZmZlcmVudGx5XG4gICAgICAgICAgaWYgKGN1cnJlbnRUb29sID09PSAncGVuJykge1xuICAgICAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgd2UncmUgaW50ZXJhY3Rpbmcgd2l0aCBhIGNvbnRyb2wgcG9pbnRcbiAgICAgICAgICAgIGlmICghaGFuZGxlQmV6aWVyTW91c2VEb3duKGUpKSB7XG4gICAgICAgICAgICAgIC8vIElmIG5vdCBpbnRlcmFjdGluZyB3aXRoIGV4aXN0aW5nIHBvaW50cywgYWRkIGEgbmV3IHBvaW50XG4gICAgICAgICAgICAgIGhhbmRsZVBlblRvb2xDbGljayhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRm9yIG90aGVyIHRvb2xzLCB1c2UgdGhlIHJlZ3VsYXIgZHJhd2luZyBiZWhhdmlvclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0V4ZWN1dGluZyByZWd1bGFyIHN0YXJ0RHJhd2luZyBoYW5kbGVyJyk7XG4gICAgICAgICAgICBzdGFydERyYXdpbmcoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9fVxuICAgICAgICBvbk1vdXNlTW92ZT17KGUpID0+IHtcbiAgICAgICAgICAvLyBGb3IgcGVuIChiZXppZXIpIHRvb2wsIGhhbmRsZSBjb250cm9sIHBvaW50IGRyYWdnaW5nXG4gICAgICAgICAgaWYgKGN1cnJlbnRUb29sID09PSAncGVuJyAmJiBoYW5kbGVCZXppZXJNb3VzZU1vdmUoZSkpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGhhbmRsZWQgYSBiZXppZXIgY29udHJvbCBwb2ludCBtb3ZlLCByZXR1cm4gZWFybHlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRm9yIG90aGVyIHRvb2xzLCB1c2UgcmVndWxhciBkcmF3aW5nXG4gICAgICAgICAgZHJhdyhlKTtcbiAgICAgICAgfX1cbiAgICAgICAgb25Nb3VzZVVwPXsoZSkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdvbk1vdXNlVXAgZXZlbnQgdHJpZ2dlcmVkJywgeyBjdXJyZW50VG9vbCwgaXNEcmF3aW5nIH0pO1xuICAgICAgICAgIGhhbmRsZVN0b3BEcmF3aW5nKGUpO1xuICAgICAgICB9fVxuICAgICAgICBvbk1vdXNlTGVhdmU9eyhlKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ29uTW91c2VMZWF2ZSBldmVudCB0cmlnZ2VyZWQnLCB7IGN1cnJlbnRUb29sLCBpc0RyYXdpbmcgfSk7XG4gICAgICAgICAgaGFuZGxlU3RvcERyYXdpbmcoZSk7XG4gICAgICAgIH19XG4gICAgICAgIG9uRG91YmxlQ2xpY2s9e2hhbmRsZURvdWJsZUNsaWNrfVxuICAgICAgICBvbkNsaWNrPXtoYW5kbGVDYW52YXNDbGlja31cbiAgICAgICAgb25Ub3VjaFN0YXJ0PXtzdGFydERyYXdpbmd9XG4gICAgICAgIG9uVG91Y2hNb3ZlPXtkcmF3fVxuICAgICAgICBvblRvdWNoRW5kPXtoYW5kbGVTdG9wRHJhd2luZ31cbiAgICAgICAgb25LZXlEb3duPXtoYW5kbGVLZXlEb3dufVxuICAgICAgICB0YWJJbmRleD17MH1cbiAgICAgICAgY2xhc3NOYW1lPXtgYm9yZGVyLTIgYm9yZGVyLWJsYWNrIHctZnVsbCBzbTpoLVs2MHZoXSBoLVszMHZoXSBtaW4taC1bMzIwcHhdIGJnLXdoaXRlLzkwIHRvdWNoLW5vbmUgJHtcbiAgICAgICAgICBjdXJyZW50VG9vbCA9PT0gJ3BlbicgPyAnY3Vyc29yLWNyb3NzaGFpcicgOiAnaG92ZXI6Y3Vyc29yLWNyb3NzaGFpcidcbiAgICAgICAgfWB9XG4gICAgICAgIGFyaWEtbGFiZWw9XCJEcmF3aW5nIGNhbnZhc1wiXG4gICAgICAvPlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQ2FudmFzOyAiXSwibmFtZXMiOlsidXNlUmVmIiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJDYW52YXMiLCJjYW52YXNSZWYiLCJjdXJyZW50VG9vbCIsImlzRHJhd2luZyIsInN0YXJ0RHJhd2luZyIsImRyYXciLCJzdG9wRHJhd2luZyIsImhhbmRsZUNhbnZhc0NsaWNrIiwiaGFuZGxlUGVuQ2xpY2siLCJoYW5kbGVHZW5lcmF0aW9uIiwidGVtcFBvaW50cyIsInNldFRlbXBQb2ludHMiLCJzaG93QmV6aWVyR3VpZGVzIiwic2V0U2hvd0Jlemllckd1aWRlcyIsImRyYWdQb2ludEluZGV4Iiwic2V0RHJhZ1BvaW50SW5kZXgiLCJwcmV2ZW50VG91Y2hEZWZhdWx0IiwiZSIsInByZXZlbnREZWZhdWx0IiwiY2FudmFzIiwiY3VycmVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJwYXNzaXZlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNvbnNvbGUiLCJsb2ciLCJsZW5ndGgiLCJyZWRyYXdCZXppZXJHdWlkZXMiLCJoYW5kbGVLZXlEb3duIiwia2V5IiwiY3R4IiwiZ2V0Q29udGV4dCIsImNhbnZhc0ltYWdlIiwiSW1hZ2UiLCJzcmMiLCJ0b0RhdGFVUkwiLCJvbmxvYWQiLCJjbGVhclJlY3QiLCJ3aWR0aCIsImhlaWdodCIsImRyYXdJbWFnZSIsImRyYXdCZXppZXJHdWlkZXMiLCJiZWdpblBhdGgiLCJzdHJva2VTdHlsZSIsImxpbmVXaWR0aCIsIm1vdmVUbyIsIngiLCJ5IiwiaSIsImxpbmVUbyIsInN0cm9rZSIsImZvckVhY2giLCJwb2ludCIsImluZGV4IiwiZmlsbFN0eWxlIiwiYXJjIiwiTWF0aCIsIlBJIiwiZmlsbCIsImZvbnQiLCJ0ZXh0QWxpZ24iLCJ0ZXh0QmFzZWxpbmUiLCJmaWxsVGV4dCIsImhhbmRsZVN0b3BEcmF3aW5nIiwiZXZlbnRUeXBlIiwidHlwZSIsImhhbmRsZUdlbmVyYXRpb25FeGlzdHMiLCJzZXRUaW1lb3V0IiwiZXJyb3IiLCJpc1BlblRvb2wiLCJpc1BlbmNpbFRvb2wiLCJ3YXNEcmF3aW5nIiwiaGFuZGxlQmV6aWVyTW91c2VEb3duIiwiZ2V0Q29vcmRpbmF0ZXMiLCJkaXN0YW5jZSIsInNxcnQiLCJoYW5kbGVCZXppZXJNb3VzZU1vdmUiLCJuZXdQb2ludHMiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwic2NhbGVYIiwic2NhbGVZIiwiaW5jbHVkZXMiLCJ0b3VjaGVzIiwiY2xpZW50WCIsImxlZnQiLCJjbGllbnRZIiwidG9wIiwiaGFuZGxlRG91YmxlQ2xpY2siLCJjbG9zZXN0RGlzdGFuY2UiLCJOdW1iZXIiLCJQT1NJVElWRV9JTkZJTklUWSIsImluc2VydEluZGV4IiwicDEiLCJwMiIsImRpc3RhbmNlVG9MaW5lU2VnbWVudCIsInNwbGljZSIsInAiLCJ4MSIsInkxIiwieDIiLCJ5MiIsImxlbmd0aFNxdWFyZWQiLCJ0IiwibWF4IiwibWluIiwicHJvamVjdGlvblgiLCJwcm9qZWN0aW9uWSIsImhhbmRsZVBlblRvb2xDbGljayIsInRvZ2dsZUJlemllckd1aWRlcyIsImZpbmFsaXplQmV6aWVyQ3VydmUiLCJiZXppZXJDdXJ2ZVRvIiwiZGl2IiwiY2xhc3NOYW1lIiwiaDIiLCJidXR0b24iLCJvbkNsaWNrIiwic3BhbiIsInJlZiIsIm9uTW91c2VEb3duIiwib25Nb3VzZU1vdmUiLCJvbk1vdXNlVXAiLCJvbk1vdXNlTGVhdmUiLCJvbkRvdWJsZUNsaWNrIiwib25Ub3VjaFN0YXJ0Iiwib25Ub3VjaE1vdmUiLCJvblRvdWNoRW5kIiwib25LZXlEb3duIiwidGFiSW5kZXgiLCJhcmlhLWxhYmVsIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/Canvas.js\n"));

/***/ })

});