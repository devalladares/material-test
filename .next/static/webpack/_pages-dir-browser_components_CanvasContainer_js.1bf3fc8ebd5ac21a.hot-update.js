"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_components_CanvasContainer_js",{

/***/ "(pages-dir-browser)/./components/Canvas.js":
/*!******************************!*\
  !*** ./components/Canvas.js ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/canvasUtils */ \"(pages-dir-browser)/./components/utils/canvasUtils.js\");\n\nvar _s = $RefreshSig$();\n\n\nconst Canvas = (param)=>{\n    let { canvasRef, currentTool, isDrawing, startDrawing, draw, stopDrawing, handleCanvasClick, handlePenClick, handleGeneration, tempPoints, setTempPoints } = param;\n    _s();\n    const [showBezierGuides, setShowBezierGuides] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [activePoint, setActivePoint] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(-1);\n    const [activeHandle, setActiveHandle] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [symmetric, setSymmetric] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [lastMousePos, setLastMousePos] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        x: 0,\n        y: 0\n    });\n    const [hasDrawing, setHasDrawing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [strokeCount, setStrokeCount] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    // Add touch event prevention function\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Canvas.useEffect\": ()=>{\n            // Function to prevent default touch behavior on canvas\n            const preventTouchDefault = {\n                \"Canvas.useEffect.preventTouchDefault\": (e)=>{\n                    if (isDrawing) {\n                        e.preventDefault();\n                    }\n                }\n            }[\"Canvas.useEffect.preventTouchDefault\"];\n            // Add event listener when component mounts\n            const canvas = canvasRef.current;\n            if (canvas) {\n                canvas.addEventListener('touchstart', preventTouchDefault, {\n                    passive: false\n                });\n                canvas.addEventListener('touchmove', preventTouchDefault, {\n                    passive: false\n                });\n            }\n            // Remove event listener when component unmounts\n            return ({\n                \"Canvas.useEffect\": ()=>{\n                    if (canvas) {\n                        canvas.removeEventListener('touchstart', preventTouchDefault);\n                        canvas.removeEventListener('touchmove', preventTouchDefault);\n                    }\n                }\n            })[\"Canvas.useEffect\"];\n        }\n    }[\"Canvas.useEffect\"], [\n        isDrawing,\n        canvasRef\n    ]);\n    // Add debugging info to console\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Canvas.useEffect\": ()=>{\n            console.log('Canvas tool changed or isDrawing changed:', {\n                currentTool,\n                isDrawing\n            });\n        }\n    }[\"Canvas.useEffect\"], [\n        currentTool,\n        isDrawing\n    ]);\n    // Redraw bezier guides and control points when tempPoints change\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Canvas.useEffect\": ()=>{\n            if (currentTool === 'pen' && tempPoints.length > 0 && showBezierGuides) {\n                redrawBezierGuides();\n            }\n        }\n    }[\"Canvas.useEffect\"], [\n        tempPoints,\n        showBezierGuides,\n        currentTool\n    ]);\n    // Add useEffect to draw placeholder text on empty canvas\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Canvas.useEffect\": ()=>{\n            const canvas = canvasRef.current;\n            if (!canvas) return;\n            const ctx = canvas.getContext('2d');\n            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n            // Check if canvas has any non-white pixels (i.e., has a drawing)\n            const hasNonWhitePixels = Array.from(imageData.data).some({\n                \"Canvas.useEffect.hasNonWhitePixels\": (pixel, index)=>{\n                    // Check only RGB values (skip alpha)\n                    return index % 4 !== 3 && pixel !== 255;\n                }\n            }[\"Canvas.useEffect.hasNonWhitePixels\"]);\n            setHasDrawing(hasNonWhitePixels);\n            // If canvas is empty, draw placeholder text\n            if (!hasNonWhitePixels && !isDrawing) {\n                ctx.fillStyle = '#999999';\n                ctx.font = '20px Arial';\n                ctx.textAlign = 'center';\n                ctx.fillText('Draw here', canvas.width / 2, canvas.height / 2);\n            }\n        }\n    }[\"Canvas.useEffect\"], [\n        isDrawing,\n        canvasRef\n    ]);\n    const handleKeyDown = (e)=>{\n        // Add keyboard accessibility\n        if (e.key === 'Enter' || e.key === ' ') {\n            handleCanvasClick(e);\n        }\n        // Toggle symmetric handles with Shift key\n        if (e.key === 'Shift') {\n            setSymmetric(!symmetric);\n        }\n    };\n    // Draw bezier control points and guide lines\n    const redrawBezierGuides = ()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        // Get the canvas context\n        const ctx = canvas.getContext('2d');\n        // Save the current canvas state to redraw later\n        const canvasImage = new Image();\n        canvasImage.src = canvas.toDataURL();\n        canvasImage.onload = ()=>{\n            // Clear canvas\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            // Redraw the canvas content\n            ctx.drawImage(canvasImage, 0, 0);\n            // Draw the control points and guide lines\n            (0,_utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.drawBezierGuides)(ctx, tempPoints);\n        };\n    };\n    // Custom handler for stopping drawing with pen tool\n    const handleStopDrawing = (e)=>{\n        console.log('handleStopDrawing called', {\n            eventType: e === null || e === void 0 ? void 0 : e.type,\n            currentTool,\n            isDrawing,\n            activePoint,\n            activeHandle\n        });\n        // If we're using the pen tool with active point or handle\n        if (currentTool === 'pen') {\n            // If we were dragging a handle, just release it\n            if (activeHandle) {\n                setActiveHandle(null);\n                return;\n            }\n            // If we were dragging an anchor point, just release it\n            if (activePoint !== -1) {\n                setActivePoint(-1);\n                return;\n            }\n        }\n        stopDrawing(e);\n        // If using the pencil tool and we've just finished a drag, trigger generation\n        if (currentTool === 'pencil' && isDrawing) {\n            console.log(\"\".concat(currentTool, \" tool condition met, will try to trigger generation\"));\n            // Small delay to ensure the drawing is complete\n            setTimeout(()=>{\n                console.log('Attempting to call handleGeneration after timeout');\n                if (typeof handleGeneration === 'function') {\n                    console.log('Calling handleGeneration function');\n                    handleGeneration();\n                } else {\n                    console.error('handleGeneration is not a function:', handleGeneration);\n                }\n            }, 100);\n        } else {\n            console.log('Generation not triggered because:', {\n                isPenTool: currentTool === 'pen',\n                isPencilTool: currentTool === 'pencil',\n                wasDrawing: isDrawing\n            });\n        }\n    };\n    // Check if we clicked on an existing point or handle\n    const checkForPointOrHandle = (e)=>{\n        if (currentTool !== 'pen' || !showBezierGuides || tempPoints.length === 0) {\n            return false;\n        }\n        const canvas = canvasRef.current;\n        const { x, y } = (0,_utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.getCoordinates)(e, canvas);\n        setLastMousePos({\n            x,\n            y\n        });\n        // Check if we clicked on a handle\n        for(let i = 0; i < tempPoints.length; i++){\n            const point = tempPoints[i];\n            // Check for handleIn\n            if ((0,_utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.isNearHandle)(point, 'handleIn', x, y)) {\n                setActivePoint(i);\n                setActiveHandle('handleIn');\n                return true;\n            }\n            // Check for handleOut\n            if ((0,_utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.isNearHandle)(point, 'handleOut', x, y)) {\n                setActivePoint(i);\n                setActiveHandle('handleOut');\n                return true;\n            }\n            // Check for the anchor point itself\n            const distance = Math.sqrt((point.x - x) ** 2 + (point.y - y) ** 2);\n            if (distance <= 10) {\n                setActivePoint(i);\n                setActiveHandle(null);\n                return true;\n            }\n        }\n        return false;\n    };\n    // Handle mouse move for bezier control point or handle dragging\n    const handleBezierMouseMove = (e)=>{\n        if (currentTool !== 'pen') {\n            return false;\n        }\n        const canvas = canvasRef.current;\n        const { x, y } = (0,_utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.getCoordinates)(e, canvas);\n        const dx = x - lastMousePos.x;\n        const dy = y - lastMousePos.y;\n        // If we're dragging a handle\n        if (activePoint !== -1 && activeHandle) {\n            const newPoints = [\n                ...tempPoints\n            ];\n            (0,_utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.updateHandle)(newPoints[activePoint], activeHandle, dx, dy, symmetric);\n            setTempPoints(newPoints);\n            setLastMousePos({\n                x,\n                y\n            });\n            return true;\n        }\n        // If we're dragging an anchor point\n        if (activePoint !== -1) {\n            const newPoints = [\n                ...tempPoints\n            ];\n            newPoints[activePoint].x += dx;\n            newPoints[activePoint].y += dy;\n            // If this point has handles, move them with the point\n            if (newPoints[activePoint].handleIn) {\n            // No need to change the handle's offset, just move with the point\n            }\n            if (newPoints[activePoint].handleOut) {\n            // No need to change the handle's offset, just move with the point\n            }\n            setTempPoints(newPoints);\n            setLastMousePos({\n                x,\n                y\n            });\n            return true;\n        }\n        return false;\n    };\n    // Handle clicks for bezier curve tool\n    const handlePenToolClick = (e)=>{\n        const canvas = canvasRef.current;\n        const { x, y } = (0,_utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.getCoordinates)(e, canvas);\n        // Add a new point\n        if (tempPoints.length === 0) {\n            // First point has no handles initially\n            const newPoint = {\n                x,\n                y,\n                handleIn: null,\n                handleOut: null\n            };\n            setTempPoints([\n                newPoint\n            ]);\n        } else {\n            // Create a new point with handles relative to the last point\n            const newPoint = (0,_utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.createAnchorPoint)(x, y, tempPoints[tempPoints.length - 1]);\n            setTempPoints([\n                ...tempPoints,\n                newPoint\n            ]);\n        }\n        // Always show guides when adding points\n        setShowBezierGuides(true);\n    };\n    // Toggle bezier guide visibility\n    const toggleBezierGuides = ()=>{\n        setShowBezierGuides(!showBezierGuides);\n        if (showBezierGuides) {\n            redrawBezierGuides();\n        }\n    };\n    // Draw the final bezier curve and clear control points\n    const finalizeBezierCurve = ()=>{\n        if (tempPoints.length < 2) {\n            // Need at least 2 points for a path\n            console.log('Need at least 2 control points to draw a path');\n            return;\n        }\n        const canvas = canvasRef.current;\n        // Draw the actual bezier curve\n        (0,_utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.drawBezierCurve)(canvas, tempPoints);\n        // Hide guides and reset control points\n        setShowBezierGuides(false);\n        setTempPoints([]);\n        // Trigger generation\n        setTimeout(()=>{\n            if (typeof handleGeneration === 'function') {\n                handleGeneration();\n            }\n        }, 100);\n    };\n    // Add control point to segment\n    const addControlPoint = (e)=>{\n        if (currentTool !== 'pen' || tempPoints.length < 2) return;\n        const canvas = canvasRef.current;\n        const { x, y } = (0,_utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.getCoordinates)(e, canvas);\n        // Find the closest segment to add a point to\n        let closestDistance = Number.POSITIVE_INFINITY;\n        let insertIndex = -1;\n        for(let i = 0; i < tempPoints.length - 1; i++){\n            const p1 = tempPoints[i];\n            const p2 = tempPoints[i + 1];\n            // Calculate distance from click to line between points\n            // This is a simplified distance calculation for demo purposes\n            const lineLength = Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);\n            if (lineLength === 0) continue;\n            // Project point onto line\n            const t = ((x - p1.x) * (p2.x - p1.x) + (y - p1.y) * (p2.y - p1.y)) / (lineLength * lineLength);\n            // If projection is outside the line segment, skip\n            if (t < 0 || t > 1) continue;\n            // Calculate closest point on line\n            const closestX = p1.x + t * (p2.x - p1.x);\n            const closestY = p1.y + t * (p2.y - p1.y);\n            // Calculate distance to closest point\n            const distance = Math.sqrt((x - closestX) ** 2 + (y - closestY) ** 2);\n            if (distance < closestDistance && distance < 20) {\n                closestDistance = distance;\n                insertIndex = i + 1;\n            }\n        }\n        if (insertIndex > 0) {\n            // Create a new array with the new point inserted\n            const newPoints = [\n                ...tempPoints\n            ];\n            const prevPoint = newPoints[insertIndex - 1];\n            const nextPoint = newPoints[insertIndex];\n            // Create a new point at the click position with automatically calculated handles\n            const newPoint = {\n                x,\n                y,\n                // Calculate handles based on the positions of adjacent points\n                handleIn: {\n                    x: (prevPoint.x - x) * 0.25,\n                    y: (prevPoint.y - y) * 0.25\n                },\n                handleOut: {\n                    x: (nextPoint.x - x) * 0.25,\n                    y: (nextPoint.y - y) * 0.25\n                }\n            };\n            // Insert the new point\n            newPoints.splice(insertIndex, 0, newPoint);\n            setTempPoints(newPoints);\n        }\n    };\n    // Wrap the original startDrawing function to clear placeholder text\n    const handleStartDrawing = (e)=>{\n        const canvas = canvasRef.current;\n        // Clear the canvas if it only contains placeholder text\n        if (!hasDrawing) {\n            const ctx = canvas.getContext(\"2d\");\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n        }\n        // Call the original startDrawing function\n        startDrawing(e);\n        setHasDrawing(true);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"relative\",\n        children: [\n            currentTool === 'pen' && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex flex-wrap mb-2 gap-2\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        type: \"button\",\n                        onClick: toggleBezierGuides,\n                        className: \"px-2 py-1 bg-blue-500 text-white rounded text-sm\",\n                        children: showBezierGuides ? 'Hide Guides' : 'Show Guides'\n                    }, void 0, false, {\n                        fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                        lineNumber: 401,\n                        columnNumber: 11\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        type: \"button\",\n                        onClick: ()=>setSymmetric(!symmetric),\n                        className: \"px-2 py-1 \".concat(symmetric ? 'bg-green-500' : 'bg-gray-500', \" text-white rounded text-sm\"),\n                        children: symmetric ? 'Symmetric Handles' : 'Free Handles'\n                    }, void 0, false, {\n                        fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                        lineNumber: 409,\n                        columnNumber: 11\n                    }, undefined),\n                    tempPoints.length >= 2 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        type: \"button\",\n                        onClick: finalizeBezierCurve,\n                        className: \"px-2 py-1 bg-green-500 text-white rounded text-sm\",\n                        children: \"Draw Path\"\n                    }, void 0, false, {\n                        fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                        lineNumber: 418,\n                        columnNumber: 13\n                    }, undefined),\n                    tempPoints.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        type: \"button\",\n                        onClick: ()=>setTempPoints([]),\n                        className: \"px-2 py-1 bg-red-500 text-white rounded text-sm\",\n                        children: \"Clear Points\"\n                    }, void 0, false, {\n                        fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                        lineNumber: 428,\n                        columnNumber: 13\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"text-sm ml-2\",\n                        children: [\n                            tempPoints.length,\n                            \" point\",\n                            tempPoints.length !== 1 ? 's' : '',\n                            tempPoints.length >= 2 ? ' (ready)' : ' (need 2+)'\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                        lineNumber: 437,\n                        columnNumber: 11\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"w-full text-xs text-gray-600 mt-1\",\n                        children: \"Tip: Click to add points, click + drag handles to adjust curves, double-click on segments to add points\"\n                    }, void 0, false, {\n                        fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                        lineNumber: 442,\n                        columnNumber: 11\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                lineNumber: 400,\n                columnNumber: 9\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n                ref: canvasRef,\n                width: 960,\n                height: 540,\n                onMouseDown: (e)=>{\n                    console.log('Canvas onMouseDown', {\n                        currentTool,\n                        isDrawing\n                    });\n                    // For pen (bezier) tool, handle differently\n                    if (currentTool === 'pen') {\n                        // Check if we clicked on an existing point or handle\n                        if (!checkForPointOrHandle(e)) {\n                            // If not interacting with existing points/handles, add a new point\n                            handlePenToolClick(e);\n                        }\n                    } else {\n                        // For other tools, use the regular drawing behavior with placeholder handling\n                        console.log('Executing regular startDrawing handler');\n                        handleStartDrawing(e);\n                    }\n                },\n                onMouseMove: (e)=>{\n                    // For pen (bezier) tool, handle control point/handle dragging\n                    if (currentTool === 'pen' && handleBezierMouseMove(e)) {\n                        // If we handled a bezier element move, return early\n                        return;\n                    }\n                    // For other tools, use regular drawing\n                    draw(e);\n                },\n                onMouseUp: (e)=>{\n                    console.log('onMouseUp event triggered', {\n                        currentTool,\n                        isDrawing\n                    });\n                    handleStopDrawing(e);\n                },\n                onMouseLeave: (e)=>{\n                    console.log('onMouseLeave event triggered', {\n                        currentTool,\n                        isDrawing\n                    });\n                    handleStopDrawing(e);\n                },\n                onDoubleClick: (e)=>{\n                    if (currentTool === 'pen') {\n                        addControlPoint(e);\n                    } else {\n                        handleCanvasClick(e);\n                    }\n                },\n                onClick: handleCanvasClick,\n                onTouchStart: handleStartDrawing,\n                onTouchMove: draw,\n                onTouchEnd: handleStopDrawing,\n                onKeyDown: handleKeyDown,\n                tabIndex: 0,\n                className: \"border-2 border-black w-full sm:h-[60vh] h-[30vh] min-h-[320px] bg-white/90 touch-none \".concat(currentTool === 'pen' ? 'cursor-crosshair' : 'hover:cursor-crosshair'),\n                \"aria-label\": \"Drawing canvas\"\n            }, void 0, false, {\n                fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                lineNumber: 448,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n        lineNumber: 398,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Canvas, \"FE+guw1aGCajRuwpOxHqFERoNxg=\");\n_c = Canvas;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Canvas);\nvar _c;\n$RefreshReg$(_c, \"Canvas\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q3pCd0YsZ0JBQWdCN0Q7b0JBQ2xCLE9BQU87d0JBQ0x0QixrQkFBa0JzQjtvQkFDcEI7Z0JBQ0Y7Z0JBQ0ErRSxTQUFTckc7Z0JBQ1Q2RyxjQUFjWjtnQkFDZGEsYUFBYWhIO2dCQUNiaUgsWUFBWXBEO2dCQUNacUQsV0FBVzlEO2dCQUNYK0QsVUFBVTtnQkFDVmQsV0FBVywwRkFFVixPQURDeEcsZ0JBQWdCLFFBQVEscUJBQXFCO2dCQUUvQ3VILGNBQVc7Ozs7Ozs7Ozs7OztBQUluQjtHQS9lTXpIO0tBQUFBO0FBaWZOLGlFQUFlQSxNQUFNQSxFQUFDIiwic291cmNlcyI6WyIvVXNlcnMvdHJ1ZHlwL0Rlc2t0b3AvZGV2LWdlbWluaS0yLjAvY29tcG9uZW50cy9DYW52YXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlUmVmLCB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgXG4gIGdldENvb3JkaW5hdGVzLCBcbiAgZHJhd0JlemllckN1cnZlLCBcbiAgZHJhd0Jlemllckd1aWRlcywgXG4gIGNyZWF0ZUFuY2hvclBvaW50LFxuICBpc05lYXJIYW5kbGUsXG4gIHVwZGF0ZUhhbmRsZVxufSBmcm9tICcuL3V0aWxzL2NhbnZhc1V0aWxzJztcblxuY29uc3QgQ2FudmFzID0gKHtcbiAgY2FudmFzUmVmLFxuICBjdXJyZW50VG9vbCxcbiAgaXNEcmF3aW5nLFxuICBzdGFydERyYXdpbmcsXG4gIGRyYXcsXG4gIHN0b3BEcmF3aW5nLFxuICBoYW5kbGVDYW52YXNDbGljayxcbiAgaGFuZGxlUGVuQ2xpY2ssXG4gIGhhbmRsZUdlbmVyYXRpb24sXG4gIHRlbXBQb2ludHMsXG4gIHNldFRlbXBQb2ludHNcbn0pID0+IHtcbiAgY29uc3QgW3Nob3dCZXppZXJHdWlkZXMsIHNldFNob3dCZXppZXJHdWlkZXNdID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFthY3RpdmVQb2ludCwgc2V0QWN0aXZlUG9pbnRdID0gdXNlU3RhdGUoLTEpO1xuICBjb25zdCBbYWN0aXZlSGFuZGxlLCBzZXRBY3RpdmVIYW5kbGVdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtzeW1tZXRyaWMsIHNldFN5bW1ldHJpY10gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgY29uc3QgW2xhc3RNb3VzZVBvcywgc2V0TGFzdE1vdXNlUG9zXSA9IHVzZVN0YXRlKHsgeDogMCwgeTogMCB9KTtcbiAgY29uc3QgW2hhc0RyYXdpbmcsIHNldEhhc0RyYXdpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc3Ryb2tlQ291bnQsIHNldFN0cm9rZUNvdW50XSA9IHVzZVN0YXRlKDApO1xuXG4gIC8vIEFkZCB0b3VjaCBldmVudCBwcmV2ZW50aW9uIGZ1bmN0aW9uXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gRnVuY3Rpb24gdG8gcHJldmVudCBkZWZhdWx0IHRvdWNoIGJlaGF2aW9yIG9uIGNhbnZhc1xuICAgIGNvbnN0IHByZXZlbnRUb3VjaERlZmF1bHQgPSAoZSkgPT4ge1xuICAgICAgaWYgKGlzRHJhd2luZykge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIEFkZCBldmVudCBsaXN0ZW5lciB3aGVuIGNvbXBvbmVudCBtb3VudHNcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBpZiAoY2FudmFzKSB7XG4gICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHByZXZlbnRUb3VjaERlZmF1bHQsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgcHJldmVudFRvdWNoRGVmYXVsdCwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgZXZlbnQgbGlzdGVuZXIgd2hlbiBjb21wb25lbnQgdW5tb3VudHNcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHByZXZlbnRUb3VjaERlZmF1bHQpO1xuICAgICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgcHJldmVudFRvdWNoRGVmYXVsdCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2lzRHJhd2luZywgY2FudmFzUmVmXSk7XG5cbiAgLy8gQWRkIGRlYnVnZ2luZyBpbmZvIHRvIGNvbnNvbGVcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zb2xlLmxvZygnQ2FudmFzIHRvb2wgY2hhbmdlZCBvciBpc0RyYXdpbmcgY2hhbmdlZDonLCB7IGN1cnJlbnRUb29sLCBpc0RyYXdpbmcgfSk7XG4gIH0sIFtjdXJyZW50VG9vbCwgaXNEcmF3aW5nXSk7XG5cbiAgLy8gUmVkcmF3IGJlemllciBndWlkZXMgYW5kIGNvbnRyb2wgcG9pbnRzIHdoZW4gdGVtcFBvaW50cyBjaGFuZ2VcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoY3VycmVudFRvb2wgPT09ICdwZW4nICYmIHRlbXBQb2ludHMubGVuZ3RoID4gMCAmJiBzaG93QmV6aWVyR3VpZGVzKSB7XG4gICAgICByZWRyYXdCZXppZXJHdWlkZXMoKTtcbiAgICB9XG4gIH0sIFt0ZW1wUG9pbnRzLCBzaG93QmV6aWVyR3VpZGVzLCBjdXJyZW50VG9vbF0pO1xuXG4gIC8vIEFkZCB1c2VFZmZlY3QgdG8gZHJhdyBwbGFjZWhvbGRlciB0ZXh0IG9uIGVtcHR5IGNhbnZhc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGlmICghY2FudmFzKSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgY29uc3QgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIGNhbnZhcyBoYXMgYW55IG5vbi13aGl0ZSBwaXhlbHMgKGkuZS4sIGhhcyBhIGRyYXdpbmcpXG4gICAgY29uc3QgaGFzTm9uV2hpdGVQaXhlbHMgPSBBcnJheS5mcm9tKGltYWdlRGF0YS5kYXRhKS5zb21lKChwaXhlbCwgaW5kZXgpID0+IHtcbiAgICAgIC8vIENoZWNrIG9ubHkgUkdCIHZhbHVlcyAoc2tpcCBhbHBoYSlcbiAgICAgIHJldHVybiBpbmRleCAlIDQgIT09IDMgJiYgcGl4ZWwgIT09IDI1NTtcbiAgICB9KTtcbiAgICBcbiAgICBzZXRIYXNEcmF3aW5nKGhhc05vbldoaXRlUGl4ZWxzKTtcbiAgICBcbiAgICAvLyBJZiBjYW52YXMgaXMgZW1wdHksIGRyYXcgcGxhY2Vob2xkZXIgdGV4dFxuICAgIGlmICghaGFzTm9uV2hpdGVQaXhlbHMgJiYgIWlzRHJhd2luZykge1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjOTk5OTk5JztcbiAgICAgIGN0eC5mb250ID0gJzIwcHggQXJpYWwnO1xuICAgICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgY3R4LmZpbGxUZXh0KCdEcmF3IGhlcmUnLCBjYW52YXMud2lkdGggLyAyLCBjYW52YXMuaGVpZ2h0IC8gMik7XG4gICAgfVxuICB9LCBbaXNEcmF3aW5nLCBjYW52YXNSZWZdKTtcblxuICBjb25zdCBoYW5kbGVLZXlEb3duID0gKGUpID0+IHtcbiAgICAvLyBBZGQga2V5Ym9hcmQgYWNjZXNzaWJpbGl0eVxuICAgIGlmIChlLmtleSA9PT0gJ0VudGVyJyB8fCBlLmtleSA9PT0gJyAnKSB7XG4gICAgICBoYW5kbGVDYW52YXNDbGljayhlKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVG9nZ2xlIHN5bW1ldHJpYyBoYW5kbGVzIHdpdGggU2hpZnQga2V5XG4gICAgaWYgKGUua2V5ID09PSAnU2hpZnQnKSB7XG4gICAgICBzZXRTeW1tZXRyaWMoIXN5bW1ldHJpYyk7XG4gICAgfVxuICB9O1xuXG4gIC8vIERyYXcgYmV6aWVyIGNvbnRyb2wgcG9pbnRzIGFuZCBndWlkZSBsaW5lc1xuICBjb25zdCByZWRyYXdCZXppZXJHdWlkZXMgPSAoKSA9PiB7XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFjYW52YXMpIHJldHVybjtcbiAgICBcbiAgICAvLyBHZXQgdGhlIGNhbnZhcyBjb250ZXh0XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgXG4gICAgLy8gU2F2ZSB0aGUgY3VycmVudCBjYW52YXMgc3RhdGUgdG8gcmVkcmF3IGxhdGVyXG4gICAgY29uc3QgY2FudmFzSW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICBjYW52YXNJbWFnZS5zcmMgPSBjYW52YXMudG9EYXRhVVJMKCk7XG4gICAgXG4gICAgY2FudmFzSW1hZ2Uub25sb2FkID0gKCkgPT4ge1xuICAgICAgLy8gQ2xlYXIgY2FudmFzXG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICBcbiAgICAgIC8vIFJlZHJhdyB0aGUgY2FudmFzIGNvbnRlbnRcbiAgICAgIGN0eC5kcmF3SW1hZ2UoY2FudmFzSW1hZ2UsIDAsIDApO1xuICAgICAgXG4gICAgICAvLyBEcmF3IHRoZSBjb250cm9sIHBvaW50cyBhbmQgZ3VpZGUgbGluZXNcbiAgICAgIGRyYXdCZXppZXJHdWlkZXMoY3R4LCB0ZW1wUG9pbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEN1c3RvbSBoYW5kbGVyIGZvciBzdG9wcGluZyBkcmF3aW5nIHdpdGggcGVuIHRvb2xcbiAgY29uc3QgaGFuZGxlU3RvcERyYXdpbmcgPSAoZSkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdoYW5kbGVTdG9wRHJhd2luZyBjYWxsZWQnLCB7IFxuICAgICAgZXZlbnRUeXBlOiBlPy50eXBlLCBcbiAgICAgIGN1cnJlbnRUb29sLCBcbiAgICAgIGlzRHJhd2luZywgXG4gICAgICBhY3RpdmVQb2ludCwgXG4gICAgICBhY3RpdmVIYW5kbGVcbiAgICB9KTtcbiAgICBcbiAgICAvLyBJZiB3ZSdyZSB1c2luZyB0aGUgcGVuIHRvb2wgd2l0aCBhY3RpdmUgcG9pbnQgb3IgaGFuZGxlXG4gICAgaWYgKGN1cnJlbnRUb29sID09PSAncGVuJykge1xuICAgICAgLy8gSWYgd2Ugd2VyZSBkcmFnZ2luZyBhIGhhbmRsZSwganVzdCByZWxlYXNlIGl0XG4gICAgICBpZiAoYWN0aXZlSGFuZGxlKSB7XG4gICAgICAgIHNldEFjdGl2ZUhhbmRsZShudWxsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBJZiB3ZSB3ZXJlIGRyYWdnaW5nIGFuIGFuY2hvciBwb2ludCwganVzdCByZWxlYXNlIGl0XG4gICAgICBpZiAoYWN0aXZlUG9pbnQgIT09IC0xKSB7XG4gICAgICAgIHNldEFjdGl2ZVBvaW50KC0xKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBzdG9wRHJhd2luZyhlKTtcbiAgICBcbiAgICAvLyBJZiB1c2luZyB0aGUgcGVuY2lsIHRvb2wgYW5kIHdlJ3ZlIGp1c3QgZmluaXNoZWQgYSBkcmFnLCB0cmlnZ2VyIGdlbmVyYXRpb25cbiAgICBpZiAoY3VycmVudFRvb2wgPT09ICdwZW5jaWwnICYmIGlzRHJhd2luZykge1xuICAgICAgY29uc29sZS5sb2coYCR7Y3VycmVudFRvb2x9IHRvb2wgY29uZGl0aW9uIG1ldCwgd2lsbCB0cnkgdG8gdHJpZ2dlciBnZW5lcmF0aW9uYCk7XG4gICAgICBcbiAgICAgIC8vIFNtYWxsIGRlbGF5IHRvIGVuc3VyZSB0aGUgZHJhd2luZyBpcyBjb21wbGV0ZVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdBdHRlbXB0aW5nIHRvIGNhbGwgaGFuZGxlR2VuZXJhdGlvbiBhZnRlciB0aW1lb3V0Jyk7XG4gICAgICAgIGlmICh0eXBlb2YgaGFuZGxlR2VuZXJhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdDYWxsaW5nIGhhbmRsZUdlbmVyYXRpb24gZnVuY3Rpb24nKTtcbiAgICAgICAgICBoYW5kbGVHZW5lcmF0aW9uKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignaGFuZGxlR2VuZXJhdGlvbiBpcyBub3QgYSBmdW5jdGlvbjonLCBoYW5kbGVHZW5lcmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSwgMTAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coJ0dlbmVyYXRpb24gbm90IHRyaWdnZXJlZCBiZWNhdXNlOicsIHsgXG4gICAgICAgIGlzUGVuVG9vbDogY3VycmVudFRvb2wgPT09ICdwZW4nLFxuICAgICAgICBpc1BlbmNpbFRvb2w6IGN1cnJlbnRUb29sID09PSAncGVuY2lsJyxcbiAgICAgICAgd2FzRHJhd2luZzogaXNEcmF3aW5nIFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIENoZWNrIGlmIHdlIGNsaWNrZWQgb24gYW4gZXhpc3RpbmcgcG9pbnQgb3IgaGFuZGxlXG4gIGNvbnN0IGNoZWNrRm9yUG9pbnRPckhhbmRsZSA9IChlKSA9PiB7XG4gICAgaWYgKGN1cnJlbnRUb29sICE9PSAncGVuJyB8fCAhc2hvd0Jlemllckd1aWRlcyB8fCB0ZW1wUG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGdldENvb3JkaW5hdGVzKGUsIGNhbnZhcyk7XG4gICAgc2V0TGFzdE1vdXNlUG9zKHsgeCwgeSB9KTtcbiAgICBcbiAgICAvLyBDaGVjayBpZiB3ZSBjbGlja2VkIG9uIGEgaGFuZGxlXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZW1wUG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHRlbXBQb2ludHNbaV07XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciBoYW5kbGVJblxuICAgICAgaWYgKGlzTmVhckhhbmRsZShwb2ludCwgJ2hhbmRsZUluJywgeCwgeSkpIHtcbiAgICAgICAgc2V0QWN0aXZlUG9pbnQoaSk7XG4gICAgICAgIHNldEFjdGl2ZUhhbmRsZSgnaGFuZGxlSW4nKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciBoYW5kbGVPdXRcbiAgICAgIGlmIChpc05lYXJIYW5kbGUocG9pbnQsICdoYW5kbGVPdXQnLCB4LCB5KSkge1xuICAgICAgICBzZXRBY3RpdmVQb2ludChpKTtcbiAgICAgICAgc2V0QWN0aXZlSGFuZGxlKCdoYW5kbGVPdXQnKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciB0aGUgYW5jaG9yIHBvaW50IGl0c2VsZlxuICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoKHBvaW50LnggLSB4KSAqKiAyICsgKHBvaW50LnkgLSB5KSAqKiAyKTtcbiAgICAgIGlmIChkaXN0YW5jZSA8PSAxMCkge1xuICAgICAgICBzZXRBY3RpdmVQb2ludChpKTtcbiAgICAgICAgc2V0QWN0aXZlSGFuZGxlKG51bGwpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBcbiAgLy8gSGFuZGxlIG1vdXNlIG1vdmUgZm9yIGJlemllciBjb250cm9sIHBvaW50IG9yIGhhbmRsZSBkcmFnZ2luZ1xuICBjb25zdCBoYW5kbGVCZXppZXJNb3VzZU1vdmUgPSAoZSkgPT4ge1xuICAgIGlmIChjdXJyZW50VG9vbCAhPT0gJ3BlbicpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBnZXRDb29yZGluYXRlcyhlLCBjYW52YXMpO1xuICAgIGNvbnN0IGR4ID0geCAtIGxhc3RNb3VzZVBvcy54O1xuICAgIGNvbnN0IGR5ID0geSAtIGxhc3RNb3VzZVBvcy55O1xuICAgIFxuICAgIC8vIElmIHdlJ3JlIGRyYWdnaW5nIGEgaGFuZGxlXG4gICAgaWYgKGFjdGl2ZVBvaW50ICE9PSAtMSAmJiBhY3RpdmVIYW5kbGUpIHtcbiAgICAgIGNvbnN0IG5ld1BvaW50cyA9IFsuLi50ZW1wUG9pbnRzXTtcbiAgICAgIHVwZGF0ZUhhbmRsZShuZXdQb2ludHNbYWN0aXZlUG9pbnRdLCBhY3RpdmVIYW5kbGUsIGR4LCBkeSwgc3ltbWV0cmljKTtcbiAgICAgIHNldFRlbXBQb2ludHMobmV3UG9pbnRzKTtcbiAgICAgIHNldExhc3RNb3VzZVBvcyh7IHgsIHkgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgLy8gSWYgd2UncmUgZHJhZ2dpbmcgYW4gYW5jaG9yIHBvaW50XG4gICAgaWYgKGFjdGl2ZVBvaW50ICE9PSAtMSkge1xuICAgICAgY29uc3QgbmV3UG9pbnRzID0gWy4uLnRlbXBQb2ludHNdO1xuICAgICAgbmV3UG9pbnRzW2FjdGl2ZVBvaW50XS54ICs9IGR4O1xuICAgICAgbmV3UG9pbnRzW2FjdGl2ZVBvaW50XS55ICs9IGR5O1xuICAgICAgXG4gICAgICAvLyBJZiB0aGlzIHBvaW50IGhhcyBoYW5kbGVzLCBtb3ZlIHRoZW0gd2l0aCB0aGUgcG9pbnRcbiAgICAgIGlmIChuZXdQb2ludHNbYWN0aXZlUG9pbnRdLmhhbmRsZUluKSB7XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gY2hhbmdlIHRoZSBoYW5kbGUncyBvZmZzZXQsIGp1c3QgbW92ZSB3aXRoIHRoZSBwb2ludFxuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAobmV3UG9pbnRzW2FjdGl2ZVBvaW50XS5oYW5kbGVPdXQpIHtcbiAgICAgICAgLy8gTm8gbmVlZCB0byBjaGFuZ2UgdGhlIGhhbmRsZSdzIG9mZnNldCwganVzdCBtb3ZlIHdpdGggdGhlIHBvaW50XG4gICAgICB9XG4gICAgICBcbiAgICAgIHNldFRlbXBQb2ludHMobmV3UG9pbnRzKTtcbiAgICAgIHNldExhc3RNb3VzZVBvcyh7IHgsIHkgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8vIEhhbmRsZSBjbGlja3MgZm9yIGJlemllciBjdXJ2ZSB0b29sXG4gIGNvbnN0IGhhbmRsZVBlblRvb2xDbGljayA9IChlKSA9PiB7XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBnZXRDb29yZGluYXRlcyhlLCBjYW52YXMpO1xuICAgIFxuICAgIC8vIEFkZCBhIG5ldyBwb2ludFxuICAgIGlmICh0ZW1wUG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gRmlyc3QgcG9pbnQgaGFzIG5vIGhhbmRsZXMgaW5pdGlhbGx5XG4gICAgICBjb25zdCBuZXdQb2ludCA9IHsgeCwgeSwgaGFuZGxlSW46IG51bGwsIGhhbmRsZU91dDogbnVsbCB9O1xuICAgICAgc2V0VGVtcFBvaW50cyhbbmV3UG9pbnRdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ3JlYXRlIGEgbmV3IHBvaW50IHdpdGggaGFuZGxlcyByZWxhdGl2ZSB0byB0aGUgbGFzdCBwb2ludFxuICAgICAgY29uc3QgbmV3UG9pbnQgPSBjcmVhdGVBbmNob3JQb2ludCh4LCB5LCB0ZW1wUG9pbnRzW3RlbXBQb2ludHMubGVuZ3RoIC0gMV0pO1xuICAgICAgc2V0VGVtcFBvaW50cyhbLi4udGVtcFBvaW50cywgbmV3UG9pbnRdKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQWx3YXlzIHNob3cgZ3VpZGVzIHdoZW4gYWRkaW5nIHBvaW50c1xuICAgIHNldFNob3dCZXppZXJHdWlkZXModHJ1ZSk7XG4gIH07XG4gIFxuICAvLyBUb2dnbGUgYmV6aWVyIGd1aWRlIHZpc2liaWxpdHlcbiAgY29uc3QgdG9nZ2xlQmV6aWVyR3VpZGVzID0gKCkgPT4ge1xuICAgIHNldFNob3dCZXppZXJHdWlkZXMoIXNob3dCZXppZXJHdWlkZXMpO1xuICAgIGlmIChzaG93QmV6aWVyR3VpZGVzKSB7XG4gICAgICByZWRyYXdCZXppZXJHdWlkZXMoKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRHJhdyB0aGUgZmluYWwgYmV6aWVyIGN1cnZlIGFuZCBjbGVhciBjb250cm9sIHBvaW50c1xuICBjb25zdCBmaW5hbGl6ZUJlemllckN1cnZlID0gKCkgPT4ge1xuICAgIGlmICh0ZW1wUG9pbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIC8vIE5lZWQgYXQgbGVhc3QgMiBwb2ludHMgZm9yIGEgcGF0aFxuICAgICAgY29uc29sZS5sb2coJ05lZWQgYXQgbGVhc3QgMiBjb250cm9sIHBvaW50cyB0byBkcmF3IGEgcGF0aCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBcbiAgICAvLyBEcmF3IHRoZSBhY3R1YWwgYmV6aWVyIGN1cnZlXG4gICAgZHJhd0JlemllckN1cnZlKGNhbnZhcywgdGVtcFBvaW50cyk7XG4gICAgXG4gICAgLy8gSGlkZSBndWlkZXMgYW5kIHJlc2V0IGNvbnRyb2wgcG9pbnRzXG4gICAgc2V0U2hvd0Jlemllckd1aWRlcyhmYWxzZSk7XG4gICAgc2V0VGVtcFBvaW50cyhbXSk7XG4gICAgXG4gICAgLy8gVHJpZ2dlciBnZW5lcmF0aW9uXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGhhbmRsZUdlbmVyYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaGFuZGxlR2VuZXJhdGlvbigpO1xuICAgICAgfVxuICAgIH0sIDEwMCk7XG4gIH07XG5cbiAgLy8gQWRkIGNvbnRyb2wgcG9pbnQgdG8gc2VnbWVudFxuICBjb25zdCBhZGRDb250cm9sUG9pbnQgPSAoZSkgPT4ge1xuICAgIGlmIChjdXJyZW50VG9vbCAhPT0gJ3BlbicgfHwgdGVtcFBvaW50cy5sZW5ndGggPCAyKSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBnZXRDb29yZGluYXRlcyhlLCBjYW52YXMpO1xuICAgIFxuICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3Qgc2VnbWVudCB0byBhZGQgYSBwb2ludCB0b1xuICAgIGxldCBjbG9zZXN0RGlzdGFuY2UgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IGluc2VydEluZGV4ID0gLTE7XG4gICAgXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZW1wUG9pbnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgY29uc3QgcDEgPSB0ZW1wUG9pbnRzW2ldO1xuICAgICAgY29uc3QgcDIgPSB0ZW1wUG9pbnRzW2kgKyAxXTtcbiAgICAgIFxuICAgICAgLy8gQ2FsY3VsYXRlIGRpc3RhbmNlIGZyb20gY2xpY2sgdG8gbGluZSBiZXR3ZWVuIHBvaW50c1xuICAgICAgLy8gVGhpcyBpcyBhIHNpbXBsaWZpZWQgZGlzdGFuY2UgY2FsY3VsYXRpb24gZm9yIGRlbW8gcHVycG9zZXNcbiAgICAgIGNvbnN0IGxpbmVMZW5ndGggPSBNYXRoLnNxcnQoKHAyLnggLSBwMS54KSAqKiAyICsgKHAyLnkgLSBwMS55KSAqKiAyKTtcbiAgICAgIGlmIChsaW5lTGVuZ3RoID09PSAwKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgLy8gUHJvamVjdCBwb2ludCBvbnRvIGxpbmVcbiAgICAgIGNvbnN0IHQgPSAoKHggLSBwMS54KSAqIChwMi54IC0gcDEueCkgKyAoeSAtIHAxLnkpICogKHAyLnkgLSBwMS55KSkgLyAobGluZUxlbmd0aCAqIGxpbmVMZW5ndGgpO1xuICAgICAgXG4gICAgICAvLyBJZiBwcm9qZWN0aW9uIGlzIG91dHNpZGUgdGhlIGxpbmUgc2VnbWVudCwgc2tpcFxuICAgICAgaWYgKHQgPCAwIHx8IHQgPiAxKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgLy8gQ2FsY3VsYXRlIGNsb3Nlc3QgcG9pbnQgb24gbGluZVxuICAgICAgY29uc3QgY2xvc2VzdFggPSBwMS54ICsgdCAqIChwMi54IC0gcDEueCk7XG4gICAgICBjb25zdCBjbG9zZXN0WSA9IHAxLnkgKyB0ICogKHAyLnkgLSBwMS55KTtcbiAgICAgIFxuICAgICAgLy8gQ2FsY3VsYXRlIGRpc3RhbmNlIHRvIGNsb3Nlc3QgcG9pbnRcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KCh4IC0gY2xvc2VzdFgpICoqIDIgKyAoeSAtIGNsb3Nlc3RZKSAqKiAyKTtcbiAgICAgIFxuICAgICAgaWYgKGRpc3RhbmNlIDwgY2xvc2VzdERpc3RhbmNlICYmIGRpc3RhbmNlIDwgMjApIHtcbiAgICAgICAgY2xvc2VzdERpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICAgIGluc2VydEluZGV4ID0gaSArIDE7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmIChpbnNlcnRJbmRleCA+IDApIHtcbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBhcnJheSB3aXRoIHRoZSBuZXcgcG9pbnQgaW5zZXJ0ZWRcbiAgICAgIGNvbnN0IG5ld1BvaW50cyA9IFsuLi50ZW1wUG9pbnRzXTtcbiAgICAgIGNvbnN0IHByZXZQb2ludCA9IG5ld1BvaW50c1tpbnNlcnRJbmRleCAtIDFdO1xuICAgICAgY29uc3QgbmV4dFBvaW50ID0gbmV3UG9pbnRzW2luc2VydEluZGV4XTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGEgbmV3IHBvaW50IGF0IHRoZSBjbGljayBwb3NpdGlvbiB3aXRoIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlZCBoYW5kbGVzXG4gICAgICBjb25zdCBuZXdQb2ludCA9IHsgXG4gICAgICAgIHgsIFxuICAgICAgICB5LFxuICAgICAgICAvLyBDYWxjdWxhdGUgaGFuZGxlcyBiYXNlZCBvbiB0aGUgcG9zaXRpb25zIG9mIGFkamFjZW50IHBvaW50c1xuICAgICAgICBoYW5kbGVJbjogeyBcbiAgICAgICAgICB4OiAocHJldlBvaW50LnggLSB4KSAqIDAuMjUsIFxuICAgICAgICAgIHk6IChwcmV2UG9pbnQueSAtIHkpICogMC4yNSBcbiAgICAgICAgfSxcbiAgICAgICAgaGFuZGxlT3V0OiB7IFxuICAgICAgICAgIHg6IChuZXh0UG9pbnQueCAtIHgpICogMC4yNSwgXG4gICAgICAgICAgeTogKG5leHRQb2ludC55IC0geSkgKiAwLjI1IFxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBJbnNlcnQgdGhlIG5ldyBwb2ludFxuICAgICAgbmV3UG9pbnRzLnNwbGljZShpbnNlcnRJbmRleCwgMCwgbmV3UG9pbnQpO1xuICAgICAgc2V0VGVtcFBvaW50cyhuZXdQb2ludHMpO1xuICAgIH1cbiAgfTtcblxuICAvLyBXcmFwIHRoZSBvcmlnaW5hbCBzdGFydERyYXdpbmcgZnVuY3Rpb24gdG8gY2xlYXIgcGxhY2Vob2xkZXIgdGV4dFxuICBjb25zdCBoYW5kbGVTdGFydERyYXdpbmcgPSAoZSkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgIFxuICAgIC8vIENsZWFyIHRoZSBjYW52YXMgaWYgaXQgb25seSBjb250YWlucyBwbGFjZWhvbGRlciB0ZXh0XG4gICAgaWYgKCFoYXNEcmF3aW5nKSB7XG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIH1cbiAgICBcbiAgICAvLyBDYWxsIHRoZSBvcmlnaW5hbCBzdGFydERyYXdpbmcgZnVuY3Rpb25cbiAgICBzdGFydERyYXdpbmcoZSk7XG4gICAgc2V0SGFzRHJhd2luZyh0cnVlKTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwicmVsYXRpdmVcIj5cbiAgICAgIHtjdXJyZW50VG9vbCA9PT0gJ3BlbicgJiYgKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC13cmFwIG1iLTIgZ2FwLTJcIj5cbiAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIG9uQ2xpY2s9e3RvZ2dsZUJlemllckd1aWRlc31cbiAgICAgICAgICAgIGNsYXNzTmFtZT1cInB4LTIgcHktMSBiZy1ibHVlLTUwMCB0ZXh0LXdoaXRlIHJvdW5kZWQgdGV4dC1zbVwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAge3Nob3dCZXppZXJHdWlkZXMgPyAnSGlkZSBHdWlkZXMnIDogJ1Nob3cgR3VpZGVzJ31cbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICBcbiAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldFN5bW1ldHJpYyghc3ltbWV0cmljKX1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17YHB4LTIgcHktMSAke3N5bW1ldHJpYyA/ICdiZy1ncmVlbi01MDAnIDogJ2JnLWdyYXktNTAwJ30gdGV4dC13aGl0ZSByb3VuZGVkIHRleHQtc21gfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtzeW1tZXRyaWMgPyAnU3ltbWV0cmljIEhhbmRsZXMnIDogJ0ZyZWUgSGFuZGxlcyd9XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgXG4gICAgICAgICAge3RlbXBQb2ludHMubGVuZ3RoID49IDIgJiYgKFxuICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgb25DbGljaz17ZmluYWxpemVCZXppZXJDdXJ2ZX1cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwicHgtMiBweS0xIGJnLWdyZWVuLTUwMCB0ZXh0LXdoaXRlIHJvdW5kZWQgdGV4dC1zbVwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIERyYXcgUGF0aFxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgKX1cbiAgICAgICAgICBcbiAgICAgICAgICB7dGVtcFBvaW50cy5sZW5ndGggPiAwICYmIChcbiAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldFRlbXBQb2ludHMoW10pfVxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJweC0yIHB5LTEgYmctcmVkLTUwMCB0ZXh0LXdoaXRlIHJvdW5kZWQgdGV4dC1zbVwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIENsZWFyIFBvaW50c1xuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgKX1cbiAgICAgICAgICBcbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXNtIG1sLTJcIj5cbiAgICAgICAgICAgIHt0ZW1wUG9pbnRzLmxlbmd0aH0gcG9pbnR7dGVtcFBvaW50cy5sZW5ndGggIT09IDEgPyAncycgOiAnJ30gXG4gICAgICAgICAgICB7dGVtcFBvaW50cy5sZW5ndGggPj0gMiA/ICcgKHJlYWR5KScgOiAnIChuZWVkIDIrKSd9XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgIFxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIHRleHQteHMgdGV4dC1ncmF5LTYwMCBtdC0xXCI+XG4gICAgICAgICAgICBUaXA6IENsaWNrIHRvIGFkZCBwb2ludHMsIGNsaWNrICsgZHJhZyBoYW5kbGVzIHRvIGFkanVzdCBjdXJ2ZXMsIGRvdWJsZS1jbGljayBvbiBzZWdtZW50cyB0byBhZGQgcG9pbnRzXG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cbiAgICAgIFxuICAgICAgPGNhbnZhc1xuICAgICAgICByZWY9e2NhbnZhc1JlZn1cbiAgICAgICAgd2lkdGg9ezk2MH1cbiAgICAgICAgaGVpZ2h0PXs1NDB9XG4gICAgICAgIG9uTW91c2VEb3duPXsoZSkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdDYW52YXMgb25Nb3VzZURvd24nLCB7IGN1cnJlbnRUb29sLCBpc0RyYXdpbmcgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRm9yIHBlbiAoYmV6aWVyKSB0b29sLCBoYW5kbGUgZGlmZmVyZW50bHlcbiAgICAgICAgICBpZiAoY3VycmVudFRvb2wgPT09ICdwZW4nKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBjbGlja2VkIG9uIGFuIGV4aXN0aW5nIHBvaW50IG9yIGhhbmRsZVxuICAgICAgICAgICAgaWYgKCFjaGVja0ZvclBvaW50T3JIYW5kbGUoZSkpIHtcbiAgICAgICAgICAgICAgLy8gSWYgbm90IGludGVyYWN0aW5nIHdpdGggZXhpc3RpbmcgcG9pbnRzL2hhbmRsZXMsIGFkZCBhIG5ldyBwb2ludFxuICAgICAgICAgICAgICBoYW5kbGVQZW5Ub29sQ2xpY2soZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZvciBvdGhlciB0b29scywgdXNlIHRoZSByZWd1bGFyIGRyYXdpbmcgYmVoYXZpb3Igd2l0aCBwbGFjZWhvbGRlciBoYW5kbGluZ1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0V4ZWN1dGluZyByZWd1bGFyIHN0YXJ0RHJhd2luZyBoYW5kbGVyJyk7XG4gICAgICAgICAgICBoYW5kbGVTdGFydERyYXdpbmcoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9fVxuICAgICAgICBvbk1vdXNlTW92ZT17KGUpID0+IHtcbiAgICAgICAgICAvLyBGb3IgcGVuIChiZXppZXIpIHRvb2wsIGhhbmRsZSBjb250cm9sIHBvaW50L2hhbmRsZSBkcmFnZ2luZ1xuICAgICAgICAgIGlmIChjdXJyZW50VG9vbCA9PT0gJ3BlbicgJiYgaGFuZGxlQmV6aWVyTW91c2VNb3ZlKGUpKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYW5kbGVkIGEgYmV6aWVyIGVsZW1lbnQgbW92ZSwgcmV0dXJuIGVhcmx5XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIEZvciBvdGhlciB0b29scywgdXNlIHJlZ3VsYXIgZHJhd2luZ1xuICAgICAgICAgIGRyYXcoZSk7XG4gICAgICAgIH19XG4gICAgICAgIG9uTW91c2VVcD17KGUpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnb25Nb3VzZVVwIGV2ZW50IHRyaWdnZXJlZCcsIHsgY3VycmVudFRvb2wsIGlzRHJhd2luZyB9KTtcbiAgICAgICAgICBoYW5kbGVTdG9wRHJhd2luZyhlKTtcbiAgICAgICAgfX1cbiAgICAgICAgb25Nb3VzZUxlYXZlPXsoZSkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdvbk1vdXNlTGVhdmUgZXZlbnQgdHJpZ2dlcmVkJywgeyBjdXJyZW50VG9vbCwgaXNEcmF3aW5nIH0pO1xuICAgICAgICAgIGhhbmRsZVN0b3BEcmF3aW5nKGUpO1xuICAgICAgICB9fVxuICAgICAgICBvbkRvdWJsZUNsaWNrPXsoZSkgPT4ge1xuICAgICAgICAgIGlmIChjdXJyZW50VG9vbCA9PT0gJ3BlbicpIHtcbiAgICAgICAgICAgIGFkZENvbnRyb2xQb2ludChlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlQ2FudmFzQ2xpY2soZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9fVxuICAgICAgICBvbkNsaWNrPXtoYW5kbGVDYW52YXNDbGlja31cbiAgICAgICAgb25Ub3VjaFN0YXJ0PXtoYW5kbGVTdGFydERyYXdpbmd9XG4gICAgICAgIG9uVG91Y2hNb3ZlPXtkcmF3fVxuICAgICAgICBvblRvdWNoRW5kPXtoYW5kbGVTdG9wRHJhd2luZ31cbiAgICAgICAgb25LZXlEb3duPXtoYW5kbGVLZXlEb3dufVxuICAgICAgICB0YWJJbmRleD17MH1cbiAgICAgICAgY2xhc3NOYW1lPXtgYm9yZGVyLTIgYm9yZGVyLWJsYWNrIHctZnVsbCBzbTpoLVs2MHZoXSBoLVszMHZoXSBtaW4taC1bMzIwcHhdIGJnLXdoaXRlLzkwIHRvdWNoLW5vbmUgJHtcbiAgICAgICAgICBjdXJyZW50VG9vbCA9PT0gJ3BlbicgPyAnY3Vyc29yLWNyb3NzaGFpcicgOiAnaG92ZXI6Y3Vyc29yLWNyb3NzaGFpcidcbiAgICAgICAgfWB9XG4gICAgICAgIGFyaWEtbGFiZWw9XCJEcmF3aW5nIGNhbnZhc1wiXG4gICAgICAvPlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQ2FudmFzOyAiXSwibmFtZXMiOlsidXNlUmVmIiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJnZXRDb29yZGluYXRlcyIsImRyYXdCZXppZXJDdXJ2ZSIsImRyYXdCZXppZXJHdWlkZXMiLCJjcmVhdGVBbmNob3JQb2ludCIsImlzTmVhckhhbmRsZSIsInVwZGF0ZUhhbmRsZSIsIkNhbnZhcyIsImNhbnZhc1JlZiIsImN1cnJlbnRUb29sIiwiaXNEcmF3aW5nIiwic3RhcnREcmF3aW5nIiwiZHJhdyIsInN0b3BEcmF3aW5nIiwiaGFuZGxlQ2FudmFzQ2xpY2siLCJoYW5kbGVQZW5DbGljayIsImhhbmRsZUdlbmVyYXRpb24iLCJ0ZW1wUG9pbnRzIiwic2V0VGVtcFBvaW50cyIsInNob3dCZXppZXJHdWlkZXMiLCJzZXRTaG93QmV6aWVyR3VpZGVzIiwiYWN0aXZlUG9pbnQiLCJzZXRBY3RpdmVQb2ludCIsImFjdGl2ZUhhbmRsZSIsInNldEFjdGl2ZUhhbmRsZSIsInN5bW1ldHJpYyIsInNldFN5bW1ldHJpYyIsImxhc3RNb3VzZVBvcyIsInNldExhc3RNb3VzZVBvcyIsIngiLCJ5IiwiaGFzRHJhd2luZyIsInNldEhhc0RyYXdpbmciLCJzdHJva2VDb3VudCIsInNldFN0cm9rZUNvdW50IiwicHJldmVudFRvdWNoRGVmYXVsdCIsImUiLCJwcmV2ZW50RGVmYXVsdCIsImNhbnZhcyIsImN1cnJlbnQiLCJhZGRFdmVudExpc3RlbmVyIiwicGFzc2l2ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjb25zb2xlIiwibG9nIiwibGVuZ3RoIiwicmVkcmF3QmV6aWVyR3VpZGVzIiwiY3R4IiwiZ2V0Q29udGV4dCIsImltYWdlRGF0YSIsImdldEltYWdlRGF0YSIsIndpZHRoIiwiaGVpZ2h0IiwiaGFzTm9uV2hpdGVQaXhlbHMiLCJBcnJheSIsImZyb20iLCJkYXRhIiwic29tZSIsInBpeGVsIiwiaW5kZXgiLCJmaWxsU3R5bGUiLCJmb250IiwidGV4dEFsaWduIiwiZmlsbFRleHQiLCJoYW5kbGVLZXlEb3duIiwia2V5IiwiY2FudmFzSW1hZ2UiLCJJbWFnZSIsInNyYyIsInRvRGF0YVVSTCIsIm9ubG9hZCIsImNsZWFyUmVjdCIsImRyYXdJbWFnZSIsImhhbmRsZVN0b3BEcmF3aW5nIiwiZXZlbnRUeXBlIiwidHlwZSIsInNldFRpbWVvdXQiLCJlcnJvciIsImlzUGVuVG9vbCIsImlzUGVuY2lsVG9vbCIsIndhc0RyYXdpbmciLCJjaGVja0ZvclBvaW50T3JIYW5kbGUiLCJpIiwicG9pbnQiLCJkaXN0YW5jZSIsIk1hdGgiLCJzcXJ0IiwiaGFuZGxlQmV6aWVyTW91c2VNb3ZlIiwiZHgiLCJkeSIsIm5ld1BvaW50cyIsImhhbmRsZUluIiwiaGFuZGxlT3V0IiwiaGFuZGxlUGVuVG9vbENsaWNrIiwibmV3UG9pbnQiLCJ0b2dnbGVCZXppZXJHdWlkZXMiLCJmaW5hbGl6ZUJlemllckN1cnZlIiwiYWRkQ29udHJvbFBvaW50IiwiY2xvc2VzdERpc3RhbmNlIiwiTnVtYmVyIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJpbnNlcnRJbmRleCIsInAxIiwicDIiLCJsaW5lTGVuZ3RoIiwidCIsImNsb3Nlc3RYIiwiY2xvc2VzdFkiLCJwcmV2UG9pbnQiLCJuZXh0UG9pbnQiLCJzcGxpY2UiLCJoYW5kbGVTdGFydERyYXdpbmciLCJkaXYiLCJjbGFzc05hbWUiLCJidXR0b24iLCJvbkNsaWNrIiwic3BhbiIsInJlZiIsIm9uTW91c2VEb3duIiwib25Nb3VzZU1vdmUiLCJvbk1vdXNlVXAiLCJvbk1vdXNlTGVhdmUiLCJvbkRvdWJsZUNsaWNrIiwib25Ub3VjaFN0YXJ0Iiwib25Ub3VjaE1vdmUiLCJvblRvdWNoRW5kIiwib25LZXlEb3duIiwidGFiSW5kZXgiLCJhcmlhLWxhYmVsIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/Canvas.js\n"));

/***/ })

});