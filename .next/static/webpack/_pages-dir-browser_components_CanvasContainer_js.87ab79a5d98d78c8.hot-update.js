"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_components_CanvasContainer_js",{

/***/ "(pages-dir-browser)/./components/Canvas.js":
/*!******************************!*\
  !*** ./components/Canvas.js ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\nvar _s = $RefreshSig$();\n\nconst Canvas = (param)=>{\n    let { canvasRef, currentTool, isDrawing, startDrawing, draw, stopDrawing, handleCanvasClick, handlePenClick, handleGeneration, tempPoints, setTempPoints } = param;\n    _s();\n    const [showBezierGuides, setShowBezierGuides] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [dragPointIndex, setDragPointIndex] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(-1);\n    // Add touch event prevention function\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Canvas.useEffect\": ()=>{\n            // Function to prevent default touch behavior on canvas\n            const preventTouchDefault = {\n                \"Canvas.useEffect.preventTouchDefault\": (e)=>{\n                    if (isDrawing) {\n                        e.preventDefault();\n                    }\n                }\n            }[\"Canvas.useEffect.preventTouchDefault\"];\n            // Add event listener when component mounts\n            const canvas = canvasRef.current;\n            if (canvas) {\n                canvas.addEventListener('touchstart', preventTouchDefault, {\n                    passive: false\n                });\n                canvas.addEventListener('touchmove', preventTouchDefault, {\n                    passive: false\n                });\n            }\n            // Remove event listener when component unmounts\n            return ({\n                \"Canvas.useEffect\": ()=>{\n                    if (canvas) {\n                        canvas.removeEventListener('touchstart', preventTouchDefault);\n                        canvas.removeEventListener('touchmove', preventTouchDefault);\n                    }\n                }\n            })[\"Canvas.useEffect\"];\n        }\n    }[\"Canvas.useEffect\"], [\n        isDrawing,\n        canvasRef\n    ]);\n    // Add debugging info to console\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Canvas.useEffect\": ()=>{\n            console.log('Canvas tool changed or isDrawing changed:', {\n                currentTool,\n                isDrawing\n            });\n        }\n    }[\"Canvas.useEffect\"], [\n        currentTool,\n        isDrawing\n    ]);\n    // Redraw bezier guides and control points when tempPoints change\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Canvas.useEffect\": ()=>{\n            if (currentTool === 'pen' && tempPoints.length > 0 && showBezierGuides) {\n                redrawBezierGuides();\n            }\n        }\n    }[\"Canvas.useEffect\"], [\n        tempPoints,\n        showBezierGuides,\n        currentTool\n    ]);\n    const handleKeyDown = (e)=>{\n        // Add keyboard accessibility\n        if (e.key === 'Enter' || e.key === ' ') {\n            handleCanvasClick(e);\n        }\n    };\n    // Draw bezier control points and guide lines\n    const redrawBezierGuides = ()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        // Get the canvas context\n        const ctx = canvas.getContext('2d');\n        // Save the current canvas state to redraw later\n        const canvasImage = new Image();\n        canvasImage.src = canvas.toDataURL();\n        canvasImage.onload = ()=>{\n            // Clear canvas\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            // Redraw the canvas content\n            ctx.drawImage(canvasImage, 0, 0);\n            // Draw the control points and guide lines\n            drawBezierGuides(ctx);\n        };\n    };\n    // Draw bezier control points and guide lines\n    const drawBezierGuides = (ctx)=>{\n        if (tempPoints.length === 0) return;\n        // Draw guide lines between control points\n        ctx.beginPath();\n        ctx.strokeStyle = 'rgba(100, 100, 255, 0.5)';\n        ctx.lineWidth = 1;\n        ctx.moveTo(tempPoints[0].x, tempPoints[0].y);\n        for(let i = 1; i < tempPoints.length; i++){\n            ctx.lineTo(tempPoints[i].x, tempPoints[i].y);\n        }\n        ctx.stroke();\n        // Draw control points\n        tempPoints.forEach((point, index)=>{\n            ctx.fillStyle = index === 0 || index === tempPoints.length - 1 ? 'rgba(255, 100, 100, 0.8)' : 'rgba(100, 100, 255, 0.8)';\n            ctx.beginPath();\n            ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);\n            ctx.fill();\n            // Add index label to each control point\n            ctx.fillStyle = 'white';\n            ctx.font = '10px Arial';\n            ctx.textAlign = 'center';\n            ctx.textBaseline = 'middle';\n            ctx.fillText(index + 1, point.x, point.y);\n        });\n    };\n    // Custom handler for stopping drawing with pen tool\n    const handleStopDrawing = (e)=>{\n        console.log('handleStopDrawing called', {\n            eventType: e.type,\n            currentTool,\n            isDrawing,\n            handleGenerationExists: !!handleGeneration\n        });\n        // Log more details about the isDrawing state just before processing\n        console.log('CRITICAL CHECK - Before stopDrawing: isDrawing =', isDrawing, 'currentTool =', currentTool);\n        // If we were dragging a bezier control point, stop dragging\n        if (currentTool === 'pen' && dragPointIndex !== -1) {\n            setDragPointIndex(-1);\n            return;\n        }\n        stopDrawing(e);\n        // If using the pen tool or pencil tool and we've just finished a drag, trigger generation\n        if ((currentTool === 'pen' || currentTool === 'pencil') && isDrawing) {\n            console.log(\"\".concat(currentTool, \" tool condition met, will try to trigger generation\"));\n            // Small delay to ensure the drawing is complete\n            setTimeout(()=>{\n                console.log('Attempting to call handleGeneration after timeout');\n                if (typeof handleGeneration === 'function') {\n                    console.log('Calling handleGeneration function');\n                    handleGeneration();\n                } else {\n                    console.error('handleGeneration is not a function:', handleGeneration);\n                }\n            }, 100);\n        } else {\n            console.log('Generation not triggered because:', {\n                isPenTool: currentTool === 'pen',\n                isPencilTool: currentTool === 'pencil',\n                wasDrawing: isDrawing\n            });\n        }\n    };\n    // Handle mouse down for bezier control point dragging\n    const handleBezierMouseDown = (e)=>{\n        if (currentTool !== 'pen' || !showBezierGuides || tempPoints.length === 0) {\n            return false;\n        }\n        const canvas = canvasRef.current;\n        const { x, y } = getCoordinates(e, canvas);\n        // Check if we clicked on a control point\n        for(let i = 0; i < tempPoints.length; i++){\n            const point = tempPoints[i];\n            const distance = Math.sqrt(Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2));\n            if (distance <= 10) {\n                setDragPointIndex(i);\n                return true;\n            }\n        }\n        return false;\n    };\n    // Handle mouse move for bezier control point dragging\n    const handleBezierMouseMove = (e)=>{\n        if (currentTool !== 'pen' || dragPointIndex === -1) {\n            return false;\n        }\n        const canvas = canvasRef.current;\n        const { x, y } = getCoordinates(e, canvas);\n        // Update the position of the control point being dragged\n        const newPoints = [\n            ...tempPoints\n        ];\n        newPoints[dragPointIndex] = {\n            x,\n            y\n        };\n        setTempPoints(newPoints);\n        return true;\n    };\n    // Get coordinates relative to canvas\n    const getCoordinates = (e, canvas)=>{\n        const rect = canvas.getBoundingClientRect();\n        const scaleX = canvas.width / rect.width;\n        const scaleY = canvas.height / rect.height;\n        if (e.type.includes('touch')) {\n            return {\n                x: (e.touches[0].clientX - rect.left) * scaleX,\n                y: (e.touches[0].clientY - rect.top) * scaleY\n            };\n        }\n        return {\n            x: (e.clientX - rect.left) * scaleX,\n            y: (e.clientY - rect.top) * scaleY\n        };\n    };\n    // Handle doubleclick to add a control point between two existing points\n    const handleDoubleClick = (e)=>{\n        if (currentTool !== 'pen' || !showBezierGuides || tempPoints.length < 2) {\n            return;\n        }\n        const canvas = canvasRef.current;\n        const { x, y } = getCoordinates(e, canvas);\n        // Find the closest line segment to add a point to\n        let closestDistance = Infinity;\n        let insertIndex = -1;\n        for(let i = 0; i < tempPoints.length - 1; i++){\n            const p1 = tempPoints[i];\n            const p2 = tempPoints[i + 1];\n            // Calculate distance from point to line segment\n            const distance = distanceToLineSegment(p1, p2, {\n                x,\n                y\n            });\n            if (distance < closestDistance && distance < 20) {\n                closestDistance = distance;\n                insertIndex = i + 1;\n            }\n        }\n        // If we found a close line segment, insert the new point\n        if (insertIndex !== -1) {\n            const newPoints = [\n                ...tempPoints\n            ];\n            newPoints.splice(insertIndex, 0, {\n                x,\n                y\n            });\n            setTempPoints(newPoints);\n        }\n    };\n    // Calculate distance from point to line segment\n    const distanceToLineSegment = (p1, p2, p)=>{\n        const { x: x1, y: y1 } = p1;\n        const { x: x2, y: y2 } = p2;\n        const { x, y } = p;\n        // Length of the line segment squared\n        const lengthSquared = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n        // If the line segment is just a point, return the distance to that point\n        if (lengthSquared === 0) return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));\n        // Calculate the projection ratio\n        const t = Math.max(0, Math.min(1, ((x - x1) * (x2 - x1) + (y - y1) * (y2 - y1)) / lengthSquared));\n        // Calculate the closest point on the line segment\n        const projectionX = x1 + t * (x2 - x1);\n        const projectionY = y1 + t * (y2 - y1);\n        // Return the distance to the closest point\n        return Math.sqrt((x - projectionX) * (x - projectionX) + (y - projectionY) * (y - projectionY));\n    };\n    // Handle clicks for bezier curve tool\n    const handlePenToolClick = (e)=>{\n        const canvas = canvasRef.current;\n        const { x, y } = getCoordinates(e, canvas);\n        // Add the point to our list of control points\n        handlePenClick(e);\n        // After adding 4 points (or more for complex beziers), draw the curve\n        if (tempPoints.length >= 3) {\n            // Show guide lines and control points\n            setShowBezierGuides(true);\n        }\n    };\n    // Toggle bezier guide visibility\n    const toggleBezierGuides = ()=>{\n        setShowBezierGuides(!showBezierGuides);\n        if (showBezierGuides) {\n            redrawBezierGuides();\n        }\n    };\n    // Draw the final bezier curve and clear control points\n    const finalizeBezierCurve = ()=>{\n        if (tempPoints.length < 4) {\n            // Need at least 4 points for cubic bezier\n            console.log('Need at least 4 control points to draw a cubic bezier curve');\n            return;\n        }\n        const canvas = canvasRef.current;\n        const ctx = canvas.getContext('2d');\n        // Draw the actual bezier curve\n        ctx.beginPath();\n        ctx.strokeStyle = '#000000';\n        ctx.lineWidth = 3;\n        ctx.moveTo(tempPoints[0].x, tempPoints[0].y);\n        // For cubic bezier curve with multiple segments\n        for(let i = 0; i < tempPoints.length - 3; i += 3){\n            ctx.bezierCurveTo(tempPoints[i + 1].x, tempPoints[i + 1].y, tempPoints[i + 2].x, tempPoints[i + 2].y, tempPoints[i + 3].x, tempPoints[i + 3].y);\n        }\n        ctx.stroke();\n        // Hide guides and reset control points\n        setShowBezierGuides(false);\n        setTempPoints([]);\n        // Trigger generation\n        setTimeout(()=>{\n            if (typeof handleGeneration === 'function') {\n                handleGeneration();\n            }\n        }, 100);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"relative\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                className: \"text-lg font-bold mb-2\",\n                children: \"Draw here:\"\n            }, void 0, false, {\n                fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                lineNumber: 343,\n                columnNumber: 7\n            }, undefined),\n            currentTool === 'pen' && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex mb-2 gap-2\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        type: \"button\",\n                        onClick: toggleBezierGuides,\n                        className: \"px-2 py-1 bg-blue-500 text-white rounded text-sm\",\n                        children: showBezierGuides ? 'Hide Guides' : 'Show Guides'\n                    }, void 0, false, {\n                        fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                        lineNumber: 347,\n                        columnNumber: 11\n                    }, undefined),\n                    tempPoints.length >= 4 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        type: \"button\",\n                        onClick: finalizeBezierCurve,\n                        className: \"px-2 py-1 bg-green-500 text-white rounded text-sm\",\n                        children: \"Draw Curve\"\n                    }, void 0, false, {\n                        fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                        lineNumber: 356,\n                        columnNumber: 13\n                    }, undefined),\n                    tempPoints.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        type: \"button\",\n                        onClick: ()=>setTempPoints([]),\n                        className: \"px-2 py-1 bg-red-500 text-white rounded text-sm\",\n                        children: \"Clear Points\"\n                    }, void 0, false, {\n                        fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                        lineNumber: 366,\n                        columnNumber: 13\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"text-sm\",\n                        children: [\n                            tempPoints.length,\n                            \" points \",\n                            tempPoints.length >= 4 ? '(ready)' : '(need 4+)'\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                        lineNumber: 375,\n                        columnNumber: 11\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                lineNumber: 346,\n                columnNumber: 9\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n                ref: canvasRef,\n                width: 960,\n                height: 540,\n                onMouseDown: (e)=>{\n                    console.log('Canvas onMouseDown', {\n                        currentTool,\n                        isDrawing\n                    });\n                    // For pen (bezier) tool, handle differently\n                    if (currentTool === 'pen') {\n                        // First check if we're interacting with a control point\n                        if (!handleBezierMouseDown(e)) {\n                            // If not interacting with existing points, add a new point\n                            handlePenToolClick(e);\n                        }\n                    } else {\n                        // For other tools, use the regular drawing behavior\n                        console.log('Executing regular startDrawing handler');\n                        startDrawing(e);\n                    }\n                },\n                onMouseMove: (e)=>{\n                    // For pen (bezier) tool, handle control point dragging\n                    if (currentTool === 'pen' && handleBezierMouseMove(e)) {\n                        // If we handled a bezier control point move, return early\n                        return;\n                    }\n                    // For other tools, use regular drawing\n                    draw(e);\n                },\n                onMouseUp: (e)=>{\n                    console.log('onMouseUp event triggered', {\n                        currentTool,\n                        isDrawing\n                    });\n                    handleStopDrawing(e);\n                },\n                onMouseLeave: (e)=>{\n                    console.log('onMouseLeave event triggered', {\n                        currentTool,\n                        isDrawing\n                    });\n                    handleStopDrawing(e);\n                },\n                onDoubleClick: handleDoubleClick,\n                onClick: handleCanvasClick,\n                onTouchStart: startDrawing,\n                onTouchMove: draw,\n                onTouchEnd: handleStopDrawing,\n                onKeyDown: handleKeyDown,\n                tabIndex: 0,\n                className: \"border-2 border-black w-full sm:h-[60vh] h-[30vh] min-h-[320px] bg-white/90 touch-none \".concat(currentTool === 'pen' ? 'cursor-crosshair' : 'hover:cursor-crosshair'),\n                \"aria-label\": \"Drawing canvas\"\n            }, void 0, false, {\n                fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                lineNumber: 381,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n        lineNumber: 342,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Canvas, \"5UOPcRNYdIkoafSpF5C8POG/t8Q=\");\n_c = Canvas;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Canvas);\nvar _c;\n$RefreshReg$(_c, \"Canvas\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvQ2FudmFzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBb0Q7QUFFcEQsTUFBTUcsU0FBUztRQUFDLEVBQ2RDLFNBQVMsRUFDVEMsV0FBVyxFQUNYQyxTQUFTLEVBQ1RDLFlBQVksRUFDWkMsSUFBSSxFQUNKQyxXQUFXLEVBQ1hDLGlCQUFpQixFQUNqQkMsY0FBYyxFQUNkQyxnQkFBZ0IsRUFDaEJDLFVBQVUsRUFDVkMsYUFBYSxFQUNkOztJQUNDLE1BQU0sQ0FBQ0Msa0JBQWtCQyxvQkFBb0IsR0FBR2QsK0NBQVFBLENBQUM7SUFDekQsTUFBTSxDQUFDZSxnQkFBZ0JDLGtCQUFrQixHQUFHaEIsK0NBQVFBLENBQUMsQ0FBQztJQUV0RCxzQ0FBc0M7SUFDdENELGdEQUFTQTs0QkFBQztZQUNSLHVEQUF1RDtZQUN2RCxNQUFNa0I7d0RBQXNCLENBQUNDO29CQUMzQixJQUFJZCxXQUFXO3dCQUNiYyxFQUFFQyxjQUFjO29CQUNsQjtnQkFDRjs7WUFFQSwyQ0FBMkM7WUFDM0MsTUFBTUMsU0FBU2xCLFVBQVVtQixPQUFPO1lBQ2hDLElBQUlELFFBQVE7Z0JBQ1ZBLE9BQU9FLGdCQUFnQixDQUFDLGNBQWNMLHFCQUFxQjtvQkFBRU0sU0FBUztnQkFBTTtnQkFDNUVILE9BQU9FLGdCQUFnQixDQUFDLGFBQWFMLHFCQUFxQjtvQkFBRU0sU0FBUztnQkFBTTtZQUM3RTtZQUVBLGdEQUFnRDtZQUNoRDtvQ0FBTztvQkFDTCxJQUFJSCxRQUFRO3dCQUNWQSxPQUFPSSxtQkFBbUIsQ0FBQyxjQUFjUDt3QkFDekNHLE9BQU9JLG1CQUFtQixDQUFDLGFBQWFQO29CQUMxQztnQkFDRjs7UUFDRjsyQkFBRztRQUFDYjtRQUFXRjtLQUFVO0lBRXpCLGdDQUFnQztJQUNoQ0gsZ0RBQVNBOzRCQUFDO1lBQ1IwQixRQUFRQyxHQUFHLENBQUMsNkNBQTZDO2dCQUFFdkI7Z0JBQWFDO1lBQVU7UUFDcEY7MkJBQUc7UUFBQ0Q7UUFBYUM7S0FBVTtJQUUzQixpRUFBaUU7SUFDakVMLGdEQUFTQTs0QkFBQztZQUNSLElBQUlJLGdCQUFnQixTQUFTUSxXQUFXZ0IsTUFBTSxHQUFHLEtBQUtkLGtCQUFrQjtnQkFDdEVlO1lBQ0Y7UUFDRjsyQkFBRztRQUFDakI7UUFBWUU7UUFBa0JWO0tBQVk7SUFFOUMsTUFBTTBCLGdCQUFnQixDQUFDWDtRQUNyQiw2QkFBNkI7UUFDN0IsSUFBSUEsRUFBRVksR0FBRyxLQUFLLFdBQVdaLEVBQUVZLEdBQUcsS0FBSyxLQUFLO1lBQ3RDdEIsa0JBQWtCVTtRQUNwQjtJQUNGO0lBRUEsNkNBQTZDO0lBQzdDLE1BQU1VLHFCQUFxQjtRQUN6QixNQUFNUixTQUFTbEIsVUFBVW1CLE9BQU87UUFDaEMsSUFBSSxDQUFDRCxRQUFRO1FBRWIseUJBQXlCO1FBQ3pCLE1BQU1XLE1BQU1YLE9BQU9ZLFVBQVUsQ0FBQztRQUU5QixnREFBZ0Q7UUFDaEQsTUFBTUMsY0FBYyxJQUFJQztRQUN4QkQsWUFBWUUsR0FBRyxHQUFHZixPQUFPZ0IsU0FBUztRQUVsQ0gsWUFBWUksTUFBTSxHQUFHO1lBQ25CLGVBQWU7WUFDZk4sSUFBSU8sU0FBUyxDQUFDLEdBQUcsR0FBR2xCLE9BQU9tQixLQUFLLEVBQUVuQixPQUFPb0IsTUFBTTtZQUUvQyw0QkFBNEI7WUFDNUJULElBQUlVLFNBQVMsQ0FBQ1IsYUFBYSxHQUFHO1lBRTlCLDBDQUEwQztZQUMxQ1MsaUJBQWlCWDtRQUNuQjtJQUNGO0lBRUEsNkNBQTZDO0lBQzdDLE1BQU1XLG1CQUFtQixDQUFDWDtRQUN4QixJQUFJcEIsV0FBV2dCLE1BQU0sS0FBSyxHQUFHO1FBRTdCLDBDQUEwQztRQUMxQ0ksSUFBSVksU0FBUztRQUNiWixJQUFJYSxXQUFXLEdBQUc7UUFDbEJiLElBQUljLFNBQVMsR0FBRztRQUNoQmQsSUFBSWUsTUFBTSxDQUFDbkMsVUFBVSxDQUFDLEVBQUUsQ0FBQ29DLENBQUMsRUFBRXBDLFVBQVUsQ0FBQyxFQUFFLENBQUNxQyxDQUFDO1FBRTNDLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJdEMsV0FBV2dCLE1BQU0sRUFBRXNCLElBQUs7WUFDMUNsQixJQUFJbUIsTUFBTSxDQUFDdkMsVUFBVSxDQUFDc0MsRUFBRSxDQUFDRixDQUFDLEVBQUVwQyxVQUFVLENBQUNzQyxFQUFFLENBQUNELENBQUM7UUFDN0M7UUFDQWpCLElBQUlvQixNQUFNO1FBRVYsc0JBQXNCO1FBQ3RCeEMsV0FBV3lDLE9BQU8sQ0FBQyxDQUFDQyxPQUFPQztZQUN6QnZCLElBQUl3QixTQUFTLEdBQUdELFVBQVUsS0FBS0EsVUFBVTNDLFdBQVdnQixNQUFNLEdBQUcsSUFDM0QsNkJBQTZCO1lBQy9CSSxJQUFJWSxTQUFTO1lBQ2JaLElBQUl5QixHQUFHLENBQUNILE1BQU1OLENBQUMsRUFBRU0sTUFBTUwsQ0FBQyxFQUFFLEdBQUcsR0FBR1MsS0FBS0MsRUFBRSxHQUFHO1lBQzFDM0IsSUFBSTRCLElBQUk7WUFFUix3Q0FBd0M7WUFDeEM1QixJQUFJd0IsU0FBUyxHQUFHO1lBQ2hCeEIsSUFBSTZCLElBQUksR0FBRztZQUNYN0IsSUFBSThCLFNBQVMsR0FBRztZQUNoQjlCLElBQUkrQixZQUFZLEdBQUc7WUFDbkIvQixJQUFJZ0MsUUFBUSxDQUFDVCxRQUFRLEdBQUdELE1BQU1OLENBQUMsRUFBRU0sTUFBTUwsQ0FBQztRQUMxQztJQUNGO0lBRUEsb0RBQW9EO0lBQ3BELE1BQU1nQixvQkFBb0IsQ0FBQzlDO1FBQ3pCTyxRQUFRQyxHQUFHLENBQUMsNEJBQTRCO1lBQ3RDdUMsV0FBVy9DLEVBQUVnRCxJQUFJO1lBQ2pCL0Q7WUFDQUM7WUFDQStELHdCQUF3QixDQUFDLENBQUN6RDtRQUM1QjtRQUVBLG9FQUFvRTtRQUNwRWUsUUFBUUMsR0FBRyxDQUFDLG9EQUFvRHRCLFdBQVcsaUJBQWlCRDtRQUU1Riw0REFBNEQ7UUFDNUQsSUFBSUEsZ0JBQWdCLFNBQVNZLG1CQUFtQixDQUFDLEdBQUc7WUFDbERDLGtCQUFrQixDQUFDO1lBQ25CO1FBQ0Y7UUFFQVQsWUFBWVc7UUFFWiwwRkFBMEY7UUFDMUYsSUFBSSxDQUFDZixnQkFBZ0IsU0FBU0EsZ0JBQWdCLFFBQU8sS0FBTUMsV0FBVztZQUNwRXFCLFFBQVFDLEdBQUcsQ0FBQyxHQUFlLE9BQVp2QixhQUFZO1lBRTNCLGdEQUFnRDtZQUNoRGlFLFdBQVc7Z0JBQ1QzQyxRQUFRQyxHQUFHLENBQUM7Z0JBQ1osSUFBSSxPQUFPaEIscUJBQXFCLFlBQVk7b0JBQzFDZSxRQUFRQyxHQUFHLENBQUM7b0JBQ1poQjtnQkFDRixPQUFPO29CQUNMZSxRQUFRNEMsS0FBSyxDQUFDLHVDQUF1QzNEO2dCQUN2RDtZQUNGLEdBQUc7UUFDTCxPQUFPO1lBQ0xlLFFBQVFDLEdBQUcsQ0FBQyxxQ0FBcUM7Z0JBQy9DNEMsV0FBV25FLGdCQUFnQjtnQkFDM0JvRSxjQUFjcEUsZ0JBQWdCO2dCQUM5QnFFLFlBQVlwRTtZQUNkO1FBQ0Y7SUFDRjtJQUVBLHNEQUFzRDtJQUN0RCxNQUFNcUUsd0JBQXdCLENBQUN2RDtRQUM3QixJQUFJZixnQkFBZ0IsU0FBUyxDQUFDVSxvQkFBb0JGLFdBQVdnQixNQUFNLEtBQUssR0FBRztZQUN6RSxPQUFPO1FBQ1Q7UUFFQSxNQUFNUCxTQUFTbEIsVUFBVW1CLE9BQU87UUFDaEMsTUFBTSxFQUFFMEIsQ0FBQyxFQUFFQyxDQUFDLEVBQUUsR0FBRzBCLGVBQWV4RCxHQUFHRTtRQUVuQyx5Q0FBeUM7UUFDekMsSUFBSyxJQUFJNkIsSUFBSSxHQUFHQSxJQUFJdEMsV0FBV2dCLE1BQU0sRUFBRXNCLElBQUs7WUFDMUMsTUFBTUksUUFBUTFDLFVBQVUsQ0FBQ3NDLEVBQUU7WUFDM0IsTUFBTTBCLFdBQVdsQixLQUFLbUIsSUFBSSxDQUFDbkIsS0FBS29CLEdBQUcsQ0FBQ3hCLE1BQU1OLENBQUMsR0FBR0EsR0FBRyxLQUFLVSxLQUFLb0IsR0FBRyxDQUFDeEIsTUFBTUwsQ0FBQyxHQUFHQSxHQUFHO1lBRTVFLElBQUkyQixZQUFZLElBQUk7Z0JBQ2xCM0Qsa0JBQWtCaUM7Z0JBQ2xCLE9BQU87WUFDVDtRQUNGO1FBRUEsT0FBTztJQUNUO0lBRUEsc0RBQXNEO0lBQ3RELE1BQU02Qix3QkFBd0IsQ0FBQzVEO1FBQzdCLElBQUlmLGdCQUFnQixTQUFTWSxtQkFBbUIsQ0FBQyxHQUFHO1lBQ2xELE9BQU87UUFDVDtRQUVBLE1BQU1LLFNBQVNsQixVQUFVbUIsT0FBTztRQUNoQyxNQUFNLEVBQUUwQixDQUFDLEVBQUVDLENBQUMsRUFBRSxHQUFHMEIsZUFBZXhELEdBQUdFO1FBRW5DLHlEQUF5RDtRQUN6RCxNQUFNMkQsWUFBWTtlQUFJcEU7U0FBVztRQUNqQ29FLFNBQVMsQ0FBQ2hFLGVBQWUsR0FBRztZQUFFZ0M7WUFBR0M7UUFBRTtRQUNuQ3BDLGNBQWNtRTtRQUVkLE9BQU87SUFDVDtJQUVBLHFDQUFxQztJQUNyQyxNQUFNTCxpQkFBaUIsQ0FBQ3hELEdBQUdFO1FBQ3pCLE1BQU00RCxPQUFPNUQsT0FBTzZELHFCQUFxQjtRQUN6QyxNQUFNQyxTQUFTOUQsT0FBT21CLEtBQUssR0FBR3lDLEtBQUt6QyxLQUFLO1FBQ3hDLE1BQU00QyxTQUFTL0QsT0FBT29CLE1BQU0sR0FBR3dDLEtBQUt4QyxNQUFNO1FBRTFDLElBQUl0QixFQUFFZ0QsSUFBSSxDQUFDa0IsUUFBUSxDQUFDLFVBQVU7WUFDNUIsT0FBTztnQkFDTHJDLEdBQUcsQ0FBQzdCLEVBQUVtRSxPQUFPLENBQUMsRUFBRSxDQUFDQyxPQUFPLEdBQUdOLEtBQUtPLElBQUksSUFBSUw7Z0JBQ3hDbEMsR0FBRyxDQUFDOUIsRUFBRW1FLE9BQU8sQ0FBQyxFQUFFLENBQUNHLE9BQU8sR0FBR1IsS0FBS1MsR0FBRyxJQUFJTjtZQUN6QztRQUNGO1FBRUEsT0FBTztZQUNMcEMsR0FBRyxDQUFDN0IsRUFBRW9FLE9BQU8sR0FBR04sS0FBS08sSUFBSSxJQUFJTDtZQUM3QmxDLEdBQUcsQ0FBQzlCLEVBQUVzRSxPQUFPLEdBQUdSLEtBQUtTLEdBQUcsSUFBSU47UUFDOUI7SUFDRjtJQUVBLHdFQUF3RTtJQUN4RSxNQUFNTyxvQkFBb0IsQ0FBQ3hFO1FBQ3pCLElBQUlmLGdCQUFnQixTQUFTLENBQUNVLG9CQUFvQkYsV0FBV2dCLE1BQU0sR0FBRyxHQUFHO1lBQ3ZFO1FBQ0Y7UUFFQSxNQUFNUCxTQUFTbEIsVUFBVW1CLE9BQU87UUFDaEMsTUFBTSxFQUFFMEIsQ0FBQyxFQUFFQyxDQUFDLEVBQUUsR0FBRzBCLGVBQWV4RCxHQUFHRTtRQUVuQyxrREFBa0Q7UUFDbEQsSUFBSXVFLGtCQUFrQkM7UUFDdEIsSUFBSUMsY0FBYyxDQUFDO1FBRW5CLElBQUssSUFBSTVDLElBQUksR0FBR0EsSUFBSXRDLFdBQVdnQixNQUFNLEdBQUcsR0FBR3NCLElBQUs7WUFDOUMsTUFBTTZDLEtBQUtuRixVQUFVLENBQUNzQyxFQUFFO1lBQ3hCLE1BQU04QyxLQUFLcEYsVUFBVSxDQUFDc0MsSUFBSSxFQUFFO1lBRTVCLGdEQUFnRDtZQUNoRCxNQUFNMEIsV0FBV3FCLHNCQUFzQkYsSUFBSUMsSUFBSTtnQkFBRWhEO2dCQUFHQztZQUFFO1lBRXRELElBQUkyQixXQUFXZ0IsbUJBQW1CaEIsV0FBVyxJQUFJO2dCQUMvQ2dCLGtCQUFrQmhCO2dCQUNsQmtCLGNBQWM1QyxJQUFJO1lBQ3BCO1FBQ0Y7UUFFQSx5REFBeUQ7UUFDekQsSUFBSTRDLGdCQUFnQixDQUFDLEdBQUc7WUFDdEIsTUFBTWQsWUFBWTttQkFBSXBFO2FBQVc7WUFDakNvRSxVQUFVa0IsTUFBTSxDQUFDSixhQUFhLEdBQUc7Z0JBQUU5QztnQkFBR0M7WUFBRTtZQUN4Q3BDLGNBQWNtRTtRQUNoQjtJQUNGO0lBRUEsZ0RBQWdEO0lBQ2hELE1BQU1pQix3QkFBd0IsQ0FBQ0YsSUFBSUMsSUFBSUc7UUFDckMsTUFBTSxFQUFFbkQsR0FBR29ELEVBQUUsRUFBRW5ELEdBQUdvRCxFQUFFLEVBQUUsR0FBR047UUFDekIsTUFBTSxFQUFFL0MsR0FBR3NELEVBQUUsRUFBRXJELEdBQUdzRCxFQUFFLEVBQUUsR0FBR1A7UUFDekIsTUFBTSxFQUFFaEQsQ0FBQyxFQUFFQyxDQUFDLEVBQUUsR0FBR2tEO1FBRWpCLHFDQUFxQztRQUNyQyxNQUFNSyxnQkFBZ0IsQ0FBQ0YsS0FBS0YsRUFBQyxJQUFNRSxDQUFBQSxLQUFLRixFQUFDLElBQUssQ0FBQ0csS0FBS0YsRUFBQyxJQUFNRSxDQUFBQSxLQUFLRixFQUFDO1FBRWpFLHlFQUF5RTtRQUN6RSxJQUFJRyxrQkFBa0IsR0FBRyxPQUFPOUMsS0FBS21CLElBQUksQ0FBQyxDQUFDN0IsSUFBSW9ELEVBQUMsSUFBTXBELENBQUFBLElBQUlvRCxFQUFDLElBQUssQ0FBQ25ELElBQUlvRCxFQUFDLElBQU1wRCxDQUFBQSxJQUFJb0QsRUFBQztRQUVqRixpQ0FBaUM7UUFDakMsTUFBTUksSUFBSS9DLEtBQUtnRCxHQUFHLENBQUMsR0FBR2hELEtBQUtpRCxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMzRCxJQUFJb0QsRUFBQyxJQUFNRSxDQUFBQSxLQUFLRixFQUFDLElBQUssQ0FBQ25ELElBQUlvRCxFQUFDLElBQU1FLENBQUFBLEtBQUtGLEVBQUMsQ0FBQyxJQUFLRztRQUVsRixrREFBa0Q7UUFDbEQsTUFBTUksY0FBY1IsS0FBS0ssSUFBS0gsQ0FBQUEsS0FBS0YsRUFBQztRQUNwQyxNQUFNUyxjQUFjUixLQUFLSSxJQUFLRixDQUFBQSxLQUFLRixFQUFDO1FBRXBDLDJDQUEyQztRQUMzQyxPQUFPM0MsS0FBS21CLElBQUksQ0FBQyxDQUFDN0IsSUFBSTRELFdBQVUsSUFBTTVELENBQUFBLElBQUk0RCxXQUFVLElBQUssQ0FBQzNELElBQUk0RCxXQUFVLElBQU01RCxDQUFBQSxJQUFJNEQsV0FBVTtJQUM5RjtJQUVBLHNDQUFzQztJQUN0QyxNQUFNQyxxQkFBcUIsQ0FBQzNGO1FBQzFCLE1BQU1FLFNBQVNsQixVQUFVbUIsT0FBTztRQUNoQyxNQUFNLEVBQUUwQixDQUFDLEVBQUVDLENBQUMsRUFBRSxHQUFHMEIsZUFBZXhELEdBQUdFO1FBRW5DLDhDQUE4QztRQUM5Q1gsZUFBZVM7UUFFZixzRUFBc0U7UUFDdEUsSUFBSVAsV0FBV2dCLE1BQU0sSUFBSSxHQUFHO1lBQzFCLHNDQUFzQztZQUN0Q2Isb0JBQW9CO1FBQ3RCO0lBQ0Y7SUFFQSxpQ0FBaUM7SUFDakMsTUFBTWdHLHFCQUFxQjtRQUN6QmhHLG9CQUFvQixDQUFDRDtRQUNyQixJQUFJQSxrQkFBa0I7WUFDcEJlO1FBQ0Y7SUFDRjtJQUVBLHVEQUF1RDtJQUN2RCxNQUFNbUYsc0JBQXNCO1FBQzFCLElBQUlwRyxXQUFXZ0IsTUFBTSxHQUFHLEdBQUc7WUFDekIsMENBQTBDO1lBQzFDRixRQUFRQyxHQUFHLENBQUM7WUFDWjtRQUNGO1FBRUEsTUFBTU4sU0FBU2xCLFVBQVVtQixPQUFPO1FBQ2hDLE1BQU1VLE1BQU1YLE9BQU9ZLFVBQVUsQ0FBQztRQUU5QiwrQkFBK0I7UUFDL0JELElBQUlZLFNBQVM7UUFDYlosSUFBSWEsV0FBVyxHQUFHO1FBQ2xCYixJQUFJYyxTQUFTLEdBQUc7UUFDaEJkLElBQUllLE1BQU0sQ0FBQ25DLFVBQVUsQ0FBQyxFQUFFLENBQUNvQyxDQUFDLEVBQUVwQyxVQUFVLENBQUMsRUFBRSxDQUFDcUMsQ0FBQztRQUUzQyxnREFBZ0Q7UUFDaEQsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUl0QyxXQUFXZ0IsTUFBTSxHQUFHLEdBQUdzQixLQUFLLEVBQUc7WUFDakRsQixJQUFJaUYsYUFBYSxDQUNmckcsVUFBVSxDQUFDc0MsSUFBSSxFQUFFLENBQUNGLENBQUMsRUFBRXBDLFVBQVUsQ0FBQ3NDLElBQUksRUFBRSxDQUFDRCxDQUFDLEVBQ3hDckMsVUFBVSxDQUFDc0MsSUFBSSxFQUFFLENBQUNGLENBQUMsRUFBRXBDLFVBQVUsQ0FBQ3NDLElBQUksRUFBRSxDQUFDRCxDQUFDLEVBQ3hDckMsVUFBVSxDQUFDc0MsSUFBSSxFQUFFLENBQUNGLENBQUMsRUFBRXBDLFVBQVUsQ0FBQ3NDLElBQUksRUFBRSxDQUFDRCxDQUFDO1FBRTVDO1FBRUFqQixJQUFJb0IsTUFBTTtRQUVWLHVDQUF1QztRQUN2Q3JDLG9CQUFvQjtRQUNwQkYsY0FBYyxFQUFFO1FBRWhCLHFCQUFxQjtRQUNyQndELFdBQVc7WUFDVCxJQUFJLE9BQU8xRCxxQkFBcUIsWUFBWTtnQkFDMUNBO1lBQ0Y7UUFDRixHQUFHO0lBQ0w7SUFFQSxxQkFDRSw4REFBQ3VHO1FBQUlDLFdBQVU7OzBCQUNiLDhEQUFDQztnQkFBR0QsV0FBVTswQkFBeUI7Ozs7OztZQUV0Qy9HLGdCQUFnQix1QkFDZiw4REFBQzhHO2dCQUFJQyxXQUFVOztrQ0FDYiw4REFBQ0U7d0JBQ0NsRCxNQUFLO3dCQUNMbUQsU0FBU1A7d0JBQ1RJLFdBQVU7a0NBRVRyRyxtQkFBbUIsZ0JBQWdCOzs7Ozs7b0JBR3JDRixXQUFXZ0IsTUFBTSxJQUFJLG1CQUNwQiw4REFBQ3lGO3dCQUNDbEQsTUFBSzt3QkFDTG1ELFNBQVNOO3dCQUNURyxXQUFVO2tDQUNYOzs7Ozs7b0JBS0Z2RyxXQUFXZ0IsTUFBTSxHQUFHLG1CQUNuQiw4REFBQ3lGO3dCQUNDbEQsTUFBSzt3QkFDTG1ELFNBQVMsSUFBTXpHLGNBQWMsRUFBRTt3QkFDL0JzRyxXQUFVO2tDQUNYOzs7Ozs7a0NBS0gsOERBQUNJO3dCQUFLSixXQUFVOzs0QkFDYnZHLFdBQVdnQixNQUFNOzRCQUFDOzRCQUFTaEIsV0FBV2dCLE1BQU0sSUFBSSxJQUFJLFlBQVk7Ozs7Ozs7Ozs7Ozs7MEJBS3ZFLDhEQUFDUDtnQkFDQ21HLEtBQUtySDtnQkFDTHFDLE9BQU87Z0JBQ1BDLFFBQVE7Z0JBQ1JnRixhQUFhLENBQUN0RztvQkFDWk8sUUFBUUMsR0FBRyxDQUFDLHNCQUFzQjt3QkFBRXZCO3dCQUFhQztvQkFBVTtvQkFFM0QsNENBQTRDO29CQUM1QyxJQUFJRCxnQkFBZ0IsT0FBTzt3QkFDekIsd0RBQXdEO3dCQUN4RCxJQUFJLENBQUNzRSxzQkFBc0J2RCxJQUFJOzRCQUM3QiwyREFBMkQ7NEJBQzNEMkYsbUJBQW1CM0Y7d0JBQ3JCO29CQUNGLE9BQU87d0JBQ0wsb0RBQW9EO3dCQUNwRE8sUUFBUUMsR0FBRyxDQUFDO3dCQUNackIsYUFBYWE7b0JBQ2Y7Z0JBQ0Y7Z0JBQ0F1RyxhQUFhLENBQUN2RztvQkFDWix1REFBdUQ7b0JBQ3ZELElBQUlmLGdCQUFnQixTQUFTMkUsc0JBQXNCNUQsSUFBSTt3QkFDckQsMERBQTBEO3dCQUMxRDtvQkFDRjtvQkFFQSx1Q0FBdUM7b0JBQ3ZDWixLQUFLWTtnQkFDUDtnQkFDQXdHLFdBQVcsQ0FBQ3hHO29CQUNWTyxRQUFRQyxHQUFHLENBQUMsNkJBQTZCO3dCQUFFdkI7d0JBQWFDO29CQUFVO29CQUNsRTRELGtCQUFrQjlDO2dCQUNwQjtnQkFDQXlHLGNBQWMsQ0FBQ3pHO29CQUNiTyxRQUFRQyxHQUFHLENBQUMsZ0NBQWdDO3dCQUFFdkI7d0JBQWFDO29CQUFVO29CQUNyRTRELGtCQUFrQjlDO2dCQUNwQjtnQkFDQTBHLGVBQWVsQztnQkFDZjJCLFNBQVM3RztnQkFDVHFILGNBQWN4SDtnQkFDZHlILGFBQWF4SDtnQkFDYnlILFlBQVkvRDtnQkFDWmdFLFdBQVduRztnQkFDWG9HLFVBQVU7Z0JBQ1ZmLFdBQVcsMEZBRVYsT0FEQy9HLGdCQUFnQixRQUFRLHFCQUFxQjtnQkFFL0MrSCxjQUFXOzs7Ozs7Ozs7Ozs7QUFJbkI7R0E5YU1qSTtLQUFBQTtBQWdiTixpRUFBZUEsTUFBTUEsRUFBQyIsInNvdXJjZXMiOlsiL1VzZXJzL3RydWR5cC9EZXNrdG9wL2Rldi1nZW1pbmktMi4wL2NvbXBvbmVudHMvQ2FudmFzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVJlZiwgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcblxuY29uc3QgQ2FudmFzID0gKHtcbiAgY2FudmFzUmVmLFxuICBjdXJyZW50VG9vbCxcbiAgaXNEcmF3aW5nLFxuICBzdGFydERyYXdpbmcsXG4gIGRyYXcsXG4gIHN0b3BEcmF3aW5nLFxuICBoYW5kbGVDYW52YXNDbGljayxcbiAgaGFuZGxlUGVuQ2xpY2ssXG4gIGhhbmRsZUdlbmVyYXRpb24sXG4gIHRlbXBQb2ludHMsXG4gIHNldFRlbXBQb2ludHNcbn0pID0+IHtcbiAgY29uc3QgW3Nob3dCZXppZXJHdWlkZXMsIHNldFNob3dCZXppZXJHdWlkZXNdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbZHJhZ1BvaW50SW5kZXgsIHNldERyYWdQb2ludEluZGV4XSA9IHVzZVN0YXRlKC0xKTtcblxuICAvLyBBZGQgdG91Y2ggZXZlbnQgcHJldmVudGlvbiBmdW5jdGlvblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIEZ1bmN0aW9uIHRvIHByZXZlbnQgZGVmYXVsdCB0b3VjaCBiZWhhdmlvciBvbiBjYW52YXNcbiAgICBjb25zdCBwcmV2ZW50VG91Y2hEZWZhdWx0ID0gKGUpID0+IHtcbiAgICAgIGlmIChpc0RyYXdpbmcpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBBZGQgZXZlbnQgbGlzdGVuZXIgd2hlbiBjb21wb25lbnQgbW91bnRzXG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKGNhbnZhcykge1xuICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBwcmV2ZW50VG91Y2hEZWZhdWx0LCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHByZXZlbnRUb3VjaERlZmF1bHQsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGV2ZW50IGxpc3RlbmVyIHdoZW4gY29tcG9uZW50IHVubW91bnRzXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBwcmV2ZW50VG91Y2hEZWZhdWx0KTtcbiAgICAgICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHByZXZlbnRUb3VjaERlZmF1bHQpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtpc0RyYXdpbmcsIGNhbnZhc1JlZl0pO1xuXG4gIC8vIEFkZCBkZWJ1Z2dpbmcgaW5mbyB0byBjb25zb2xlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ0NhbnZhcyB0b29sIGNoYW5nZWQgb3IgaXNEcmF3aW5nIGNoYW5nZWQ6JywgeyBjdXJyZW50VG9vbCwgaXNEcmF3aW5nIH0pO1xuICB9LCBbY3VycmVudFRvb2wsIGlzRHJhd2luZ10pO1xuXG4gIC8vIFJlZHJhdyBiZXppZXIgZ3VpZGVzIGFuZCBjb250cm9sIHBvaW50cyB3aGVuIHRlbXBQb2ludHMgY2hhbmdlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGN1cnJlbnRUb29sID09PSAncGVuJyAmJiB0ZW1wUG9pbnRzLmxlbmd0aCA+IDAgJiYgc2hvd0Jlemllckd1aWRlcykge1xuICAgICAgcmVkcmF3QmV6aWVyR3VpZGVzKCk7XG4gICAgfVxuICB9LCBbdGVtcFBvaW50cywgc2hvd0Jlemllckd1aWRlcywgY3VycmVudFRvb2xdKTtcblxuICBjb25zdCBoYW5kbGVLZXlEb3duID0gKGUpID0+IHtcbiAgICAvLyBBZGQga2V5Ym9hcmQgYWNjZXNzaWJpbGl0eVxuICAgIGlmIChlLmtleSA9PT0gJ0VudGVyJyB8fCBlLmtleSA9PT0gJyAnKSB7XG4gICAgICBoYW5kbGVDYW52YXNDbGljayhlKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRHJhdyBiZXppZXIgY29udHJvbCBwb2ludHMgYW5kIGd1aWRlIGxpbmVzXG4gIGNvbnN0IHJlZHJhd0Jlemllckd1aWRlcyA9ICgpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuO1xuICAgIFxuICAgIC8vIEdldCB0aGUgY2FudmFzIGNvbnRleHRcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBcbiAgICAvLyBTYXZlIHRoZSBjdXJyZW50IGNhbnZhcyBzdGF0ZSB0byByZWRyYXcgbGF0ZXJcbiAgICBjb25zdCBjYW52YXNJbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgIGNhbnZhc0ltYWdlLnNyYyA9IGNhbnZhcy50b0RhdGFVUkwoKTtcbiAgICBcbiAgICBjYW52YXNJbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAvLyBDbGVhciBjYW52YXNcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgIFxuICAgICAgLy8gUmVkcmF3IHRoZSBjYW52YXMgY29udGVudFxuICAgICAgY3R4LmRyYXdJbWFnZShjYW52YXNJbWFnZSwgMCwgMCk7XG4gICAgICBcbiAgICAgIC8vIERyYXcgdGhlIGNvbnRyb2wgcG9pbnRzIGFuZCBndWlkZSBsaW5lc1xuICAgICAgZHJhd0Jlemllckd1aWRlcyhjdHgpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gRHJhdyBiZXppZXIgY29udHJvbCBwb2ludHMgYW5kIGd1aWRlIGxpbmVzXG4gIGNvbnN0IGRyYXdCZXppZXJHdWlkZXMgPSAoY3R4KSA9PiB7XG4gICAgaWYgKHRlbXBQb2ludHMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgXG4gICAgLy8gRHJhdyBndWlkZSBsaW5lcyBiZXR3ZWVuIGNvbnRyb2wgcG9pbnRzXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZ2JhKDEwMCwgMTAwLCAyNTUsIDAuNSknO1xuICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgIGN0eC5tb3ZlVG8odGVtcFBvaW50c1swXS54LCB0ZW1wUG9pbnRzWzBdLnkpO1xuICAgIFxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGVtcFBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgY3R4LmxpbmVUbyh0ZW1wUG9pbnRzW2ldLngsIHRlbXBQb2ludHNbaV0ueSk7XG4gICAgfVxuICAgIGN0eC5zdHJva2UoKTtcbiAgICBcbiAgICAvLyBEcmF3IGNvbnRyb2wgcG9pbnRzXG4gICAgdGVtcFBvaW50cy5mb3JFYWNoKChwb2ludCwgaW5kZXgpID0+IHtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBpbmRleCA9PT0gMCB8fCBpbmRleCA9PT0gdGVtcFBvaW50cy5sZW5ndGggLSAxID8gXG4gICAgICAgICdyZ2JhKDI1NSwgMTAwLCAxMDAsIDAuOCknIDogJ3JnYmEoMTAwLCAxMDAsIDI1NSwgMC44KSc7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguYXJjKHBvaW50LngsIHBvaW50LnksIDUsIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgICBcbiAgICAgIC8vIEFkZCBpbmRleCBsYWJlbCB0byBlYWNoIGNvbnRyb2wgcG9pbnRcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgY3R4LmZvbnQgPSAnMTBweCBBcmlhbCc7XG4gICAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICBjdHguZmlsbFRleHQoaW5kZXggKyAxLCBwb2ludC54LCBwb2ludC55KTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBDdXN0b20gaGFuZGxlciBmb3Igc3RvcHBpbmcgZHJhd2luZyB3aXRoIHBlbiB0b29sXG4gIGNvbnN0IGhhbmRsZVN0b3BEcmF3aW5nID0gKGUpID0+IHtcbiAgICBjb25zb2xlLmxvZygnaGFuZGxlU3RvcERyYXdpbmcgY2FsbGVkJywgeyBcbiAgICAgIGV2ZW50VHlwZTogZS50eXBlLCBcbiAgICAgIGN1cnJlbnRUb29sLCBcbiAgICAgIGlzRHJhd2luZywgXG4gICAgICBoYW5kbGVHZW5lcmF0aW9uRXhpc3RzOiAhIWhhbmRsZUdlbmVyYXRpb24gXG4gICAgfSk7XG4gICAgXG4gICAgLy8gTG9nIG1vcmUgZGV0YWlscyBhYm91dCB0aGUgaXNEcmF3aW5nIHN0YXRlIGp1c3QgYmVmb3JlIHByb2Nlc3NpbmdcbiAgICBjb25zb2xlLmxvZygnQ1JJVElDQUwgQ0hFQ0sgLSBCZWZvcmUgc3RvcERyYXdpbmc6IGlzRHJhd2luZyA9JywgaXNEcmF3aW5nLCAnY3VycmVudFRvb2wgPScsIGN1cnJlbnRUb29sKTtcbiAgICBcbiAgICAvLyBJZiB3ZSB3ZXJlIGRyYWdnaW5nIGEgYmV6aWVyIGNvbnRyb2wgcG9pbnQsIHN0b3AgZHJhZ2dpbmdcbiAgICBpZiAoY3VycmVudFRvb2wgPT09ICdwZW4nICYmIGRyYWdQb2ludEluZGV4ICE9PSAtMSkge1xuICAgICAgc2V0RHJhZ1BvaW50SW5kZXgoLTEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBzdG9wRHJhd2luZyhlKTtcbiAgICBcbiAgICAvLyBJZiB1c2luZyB0aGUgcGVuIHRvb2wgb3IgcGVuY2lsIHRvb2wgYW5kIHdlJ3ZlIGp1c3QgZmluaXNoZWQgYSBkcmFnLCB0cmlnZ2VyIGdlbmVyYXRpb25cbiAgICBpZiAoKGN1cnJlbnRUb29sID09PSAncGVuJyB8fCBjdXJyZW50VG9vbCA9PT0gJ3BlbmNpbCcpICYmIGlzRHJhd2luZykge1xuICAgICAgY29uc29sZS5sb2coYCR7Y3VycmVudFRvb2x9IHRvb2wgY29uZGl0aW9uIG1ldCwgd2lsbCB0cnkgdG8gdHJpZ2dlciBnZW5lcmF0aW9uYCk7XG4gICAgICBcbiAgICAgIC8vIFNtYWxsIGRlbGF5IHRvIGVuc3VyZSB0aGUgZHJhd2luZyBpcyBjb21wbGV0ZVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdBdHRlbXB0aW5nIHRvIGNhbGwgaGFuZGxlR2VuZXJhdGlvbiBhZnRlciB0aW1lb3V0Jyk7XG4gICAgICAgIGlmICh0eXBlb2YgaGFuZGxlR2VuZXJhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdDYWxsaW5nIGhhbmRsZUdlbmVyYXRpb24gZnVuY3Rpb24nKTtcbiAgICAgICAgICBoYW5kbGVHZW5lcmF0aW9uKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignaGFuZGxlR2VuZXJhdGlvbiBpcyBub3QgYSBmdW5jdGlvbjonLCBoYW5kbGVHZW5lcmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSwgMTAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coJ0dlbmVyYXRpb24gbm90IHRyaWdnZXJlZCBiZWNhdXNlOicsIHsgXG4gICAgICAgIGlzUGVuVG9vbDogY3VycmVudFRvb2wgPT09ICdwZW4nLFxuICAgICAgICBpc1BlbmNpbFRvb2w6IGN1cnJlbnRUb29sID09PSAncGVuY2lsJyxcbiAgICAgICAgd2FzRHJhd2luZzogaXNEcmF3aW5nIFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEhhbmRsZSBtb3VzZSBkb3duIGZvciBiZXppZXIgY29udHJvbCBwb2ludCBkcmFnZ2luZ1xuICBjb25zdCBoYW5kbGVCZXppZXJNb3VzZURvd24gPSAoZSkgPT4ge1xuICAgIGlmIChjdXJyZW50VG9vbCAhPT0gJ3BlbicgfHwgIXNob3dCZXppZXJHdWlkZXMgfHwgdGVtcFBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBnZXRDb29yZGluYXRlcyhlLCBjYW52YXMpO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIHdlIGNsaWNrZWQgb24gYSBjb250cm9sIHBvaW50XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZW1wUG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHRlbXBQb2ludHNbaV07XG4gICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChNYXRoLnBvdyhwb2ludC54IC0geCwgMikgKyBNYXRoLnBvdyhwb2ludC55IC0geSwgMikpO1xuICAgICAgXG4gICAgICBpZiAoZGlzdGFuY2UgPD0gMTApIHsgLy8gSWYgd2l0aGluIDEwcHggcmFkaXVzIG9mIGNvbnRyb2wgcG9pbnRcbiAgICAgICAgc2V0RHJhZ1BvaW50SW5kZXgoaSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIFxuICAvLyBIYW5kbGUgbW91c2UgbW92ZSBmb3IgYmV6aWVyIGNvbnRyb2wgcG9pbnQgZHJhZ2dpbmdcbiAgY29uc3QgaGFuZGxlQmV6aWVyTW91c2VNb3ZlID0gKGUpID0+IHtcbiAgICBpZiAoY3VycmVudFRvb2wgIT09ICdwZW4nIHx8IGRyYWdQb2ludEluZGV4ID09PSAtMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGdldENvb3JkaW5hdGVzKGUsIGNhbnZhcyk7XG4gICAgXG4gICAgLy8gVXBkYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbCBwb2ludCBiZWluZyBkcmFnZ2VkXG4gICAgY29uc3QgbmV3UG9pbnRzID0gWy4uLnRlbXBQb2ludHNdO1xuICAgIG5ld1BvaW50c1tkcmFnUG9pbnRJbmRleF0gPSB7IHgsIHkgfTtcbiAgICBzZXRUZW1wUG9pbnRzKG5ld1BvaW50cyk7XG4gICAgXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8gR2V0IGNvb3JkaW5hdGVzIHJlbGF0aXZlIHRvIGNhbnZhc1xuICBjb25zdCBnZXRDb29yZGluYXRlcyA9IChlLCBjYW52YXMpID0+IHtcbiAgICBjb25zdCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHNjYWxlWCA9IGNhbnZhcy53aWR0aCAvIHJlY3Qud2lkdGg7XG4gICAgY29uc3Qgc2NhbGVZID0gY2FudmFzLmhlaWdodCAvIHJlY3QuaGVpZ2h0O1xuICAgIFxuICAgIGlmIChlLnR5cGUuaW5jbHVkZXMoJ3RvdWNoJykpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IChlLnRvdWNoZXNbMF0uY2xpZW50WCAtIHJlY3QubGVmdCkgKiBzY2FsZVgsXG4gICAgICAgIHk6IChlLnRvdWNoZXNbMF0uY2xpZW50WSAtIHJlY3QudG9wKSAqIHNjYWxlWVxuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IChlLmNsaWVudFggLSByZWN0LmxlZnQpICogc2NhbGVYLFxuICAgICAgeTogKGUuY2xpZW50WSAtIHJlY3QudG9wKSAqIHNjYWxlWVxuICAgIH07XG4gIH07XG5cbiAgLy8gSGFuZGxlIGRvdWJsZWNsaWNrIHRvIGFkZCBhIGNvbnRyb2wgcG9pbnQgYmV0d2VlbiB0d28gZXhpc3RpbmcgcG9pbnRzXG4gIGNvbnN0IGhhbmRsZURvdWJsZUNsaWNrID0gKGUpID0+IHtcbiAgICBpZiAoY3VycmVudFRvb2wgIT09ICdwZW4nIHx8ICFzaG93QmV6aWVyR3VpZGVzIHx8IHRlbXBQb2ludHMubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGdldENvb3JkaW5hdGVzKGUsIGNhbnZhcyk7XG4gICAgXG4gICAgLy8gRmluZCB0aGUgY2xvc2VzdCBsaW5lIHNlZ21lbnQgdG8gYWRkIGEgcG9pbnQgdG9cbiAgICBsZXQgY2xvc2VzdERpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgbGV0IGluc2VydEluZGV4ID0gLTE7XG4gICAgXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZW1wUG9pbnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgY29uc3QgcDEgPSB0ZW1wUG9pbnRzW2ldO1xuICAgICAgY29uc3QgcDIgPSB0ZW1wUG9pbnRzW2kgKyAxXTtcbiAgICAgIFxuICAgICAgLy8gQ2FsY3VsYXRlIGRpc3RhbmNlIGZyb20gcG9pbnQgdG8gbGluZSBzZWdtZW50XG4gICAgICBjb25zdCBkaXN0YW5jZSA9IGRpc3RhbmNlVG9MaW5lU2VnbWVudChwMSwgcDIsIHsgeCwgeSB9KTtcbiAgICAgIFxuICAgICAgaWYgKGRpc3RhbmNlIDwgY2xvc2VzdERpc3RhbmNlICYmIGRpc3RhbmNlIDwgMjApIHsgLy8gV2l0aGluIDIwcHggb2YgbGluZVxuICAgICAgICBjbG9zZXN0RGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgICAgaW5zZXJ0SW5kZXggPSBpICsgMTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gSWYgd2UgZm91bmQgYSBjbG9zZSBsaW5lIHNlZ21lbnQsIGluc2VydCB0aGUgbmV3IHBvaW50XG4gICAgaWYgKGluc2VydEluZGV4ICE9PSAtMSkge1xuICAgICAgY29uc3QgbmV3UG9pbnRzID0gWy4uLnRlbXBQb2ludHNdO1xuICAgICAgbmV3UG9pbnRzLnNwbGljZShpbnNlcnRJbmRleCwgMCwgeyB4LCB5IH0pO1xuICAgICAgc2V0VGVtcFBvaW50cyhuZXdQb2ludHMpO1xuICAgIH1cbiAgfTtcbiAgXG4gIC8vIENhbGN1bGF0ZSBkaXN0YW5jZSBmcm9tIHBvaW50IHRvIGxpbmUgc2VnbWVudFxuICBjb25zdCBkaXN0YW5jZVRvTGluZVNlZ21lbnQgPSAocDEsIHAyLCBwKSA9PiB7XG4gICAgY29uc3QgeyB4OiB4MSwgeTogeTEgfSA9IHAxO1xuICAgIGNvbnN0IHsgeDogeDIsIHk6IHkyIH0gPSBwMjtcbiAgICBjb25zdCB7IHgsIHkgfSA9IHA7XG4gICAgXG4gICAgLy8gTGVuZ3RoIG9mIHRoZSBsaW5lIHNlZ21lbnQgc3F1YXJlZFxuICAgIGNvbnN0IGxlbmd0aFNxdWFyZWQgPSAoeDIgLSB4MSkgKiAoeDIgLSB4MSkgKyAoeTIgLSB5MSkgKiAoeTIgLSB5MSk7XG4gICAgXG4gICAgLy8gSWYgdGhlIGxpbmUgc2VnbWVudCBpcyBqdXN0IGEgcG9pbnQsIHJldHVybiB0aGUgZGlzdGFuY2UgdG8gdGhhdCBwb2ludFxuICAgIGlmIChsZW5ndGhTcXVhcmVkID09PSAwKSByZXR1cm4gTWF0aC5zcXJ0KCh4IC0geDEpICogKHggLSB4MSkgKyAoeSAtIHkxKSAqICh5IC0geTEpKTtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgdGhlIHByb2plY3Rpb24gcmF0aW9cbiAgICBjb25zdCB0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKCh4IC0geDEpICogKHgyIC0geDEpICsgKHkgLSB5MSkgKiAoeTIgLSB5MSkpIC8gbGVuZ3RoU3F1YXJlZCkpO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSB0aGUgY2xvc2VzdCBwb2ludCBvbiB0aGUgbGluZSBzZWdtZW50XG4gICAgY29uc3QgcHJvamVjdGlvblggPSB4MSArIHQgKiAoeDIgLSB4MSk7XG4gICAgY29uc3QgcHJvamVjdGlvblkgPSB5MSArIHQgKiAoeTIgLSB5MSk7XG4gICAgXG4gICAgLy8gUmV0dXJuIHRoZSBkaXN0YW5jZSB0byB0aGUgY2xvc2VzdCBwb2ludFxuICAgIHJldHVybiBNYXRoLnNxcnQoKHggLSBwcm9qZWN0aW9uWCkgKiAoeCAtIHByb2plY3Rpb25YKSArICh5IC0gcHJvamVjdGlvblkpICogKHkgLSBwcm9qZWN0aW9uWSkpO1xuICB9O1xuXG4gIC8vIEhhbmRsZSBjbGlja3MgZm9yIGJlemllciBjdXJ2ZSB0b29sXG4gIGNvbnN0IGhhbmRsZVBlblRvb2xDbGljayA9IChlKSA9PiB7XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBnZXRDb29yZGluYXRlcyhlLCBjYW52YXMpO1xuICAgIFxuICAgIC8vIEFkZCB0aGUgcG9pbnQgdG8gb3VyIGxpc3Qgb2YgY29udHJvbCBwb2ludHNcbiAgICBoYW5kbGVQZW5DbGljayhlKTtcbiAgICBcbiAgICAvLyBBZnRlciBhZGRpbmcgNCBwb2ludHMgKG9yIG1vcmUgZm9yIGNvbXBsZXggYmV6aWVycyksIGRyYXcgdGhlIGN1cnZlXG4gICAgaWYgKHRlbXBQb2ludHMubGVuZ3RoID49IDMpIHtcbiAgICAgIC8vIFNob3cgZ3VpZGUgbGluZXMgYW5kIGNvbnRyb2wgcG9pbnRzXG4gICAgICBzZXRTaG93QmV6aWVyR3VpZGVzKHRydWUpO1xuICAgIH1cbiAgfTtcbiAgXG4gIC8vIFRvZ2dsZSBiZXppZXIgZ3VpZGUgdmlzaWJpbGl0eVxuICBjb25zdCB0b2dnbGVCZXppZXJHdWlkZXMgPSAoKSA9PiB7XG4gICAgc2V0U2hvd0Jlemllckd1aWRlcyghc2hvd0Jlemllckd1aWRlcyk7XG4gICAgaWYgKHNob3dCZXppZXJHdWlkZXMpIHtcbiAgICAgIHJlZHJhd0Jlemllckd1aWRlcygpO1xuICAgIH1cbiAgfTtcblxuICAvLyBEcmF3IHRoZSBmaW5hbCBiZXppZXIgY3VydmUgYW5kIGNsZWFyIGNvbnRyb2wgcG9pbnRzXG4gIGNvbnN0IGZpbmFsaXplQmV6aWVyQ3VydmUgPSAoKSA9PiB7XG4gICAgaWYgKHRlbXBQb2ludHMubGVuZ3RoIDwgNCkge1xuICAgICAgLy8gTmVlZCBhdCBsZWFzdCA0IHBvaW50cyBmb3IgY3ViaWMgYmV6aWVyXG4gICAgICBjb25zb2xlLmxvZygnTmVlZCBhdCBsZWFzdCA0IGNvbnRyb2wgcG9pbnRzIHRvIGRyYXcgYSBjdWJpYyBiZXppZXIgY3VydmUnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgXG4gICAgLy8gRHJhdyB0aGUgYWN0dWFsIGJlemllciBjdXJ2ZVxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAnIzAwMDAwMCc7XG4gICAgY3R4LmxpbmVXaWR0aCA9IDM7XG4gICAgY3R4Lm1vdmVUbyh0ZW1wUG9pbnRzWzBdLngsIHRlbXBQb2ludHNbMF0ueSk7XG4gICAgXG4gICAgLy8gRm9yIGN1YmljIGJlemllciBjdXJ2ZSB3aXRoIG11bHRpcGxlIHNlZ21lbnRzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZW1wUG9pbnRzLmxlbmd0aCAtIDM7IGkgKz0gMykge1xuICAgICAgY3R4LmJlemllckN1cnZlVG8oXG4gICAgICAgIHRlbXBQb2ludHNbaSArIDFdLngsIHRlbXBQb2ludHNbaSArIDFdLnksXG4gICAgICAgIHRlbXBQb2ludHNbaSArIDJdLngsIHRlbXBQb2ludHNbaSArIDJdLnksXG4gICAgICAgIHRlbXBQb2ludHNbaSArIDNdLngsIHRlbXBQb2ludHNbaSArIDNdLnlcbiAgICAgICk7XG4gICAgfVxuICAgIFxuICAgIGN0eC5zdHJva2UoKTtcbiAgICBcbiAgICAvLyBIaWRlIGd1aWRlcyBhbmQgcmVzZXQgY29udHJvbCBwb2ludHNcbiAgICBzZXRTaG93QmV6aWVyR3VpZGVzKGZhbHNlKTtcbiAgICBzZXRUZW1wUG9pbnRzKFtdKTtcbiAgICBcbiAgICAvLyBUcmlnZ2VyIGdlbmVyYXRpb25cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlR2VuZXJhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBoYW5kbGVHZW5lcmF0aW9uKCk7XG4gICAgICB9XG4gICAgfSwgMTAwKTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwicmVsYXRpdmVcIj5cbiAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LWxnIGZvbnQtYm9sZCBtYi0yXCI+RHJhdyBoZXJlOjwvaDI+XG4gICAgICBcbiAgICAgIHtjdXJyZW50VG9vbCA9PT0gJ3BlbicgJiYgKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggbWItMiBnYXAtMlwiPlxuICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgb25DbGljaz17dG9nZ2xlQmV6aWVyR3VpZGVzfVxuICAgICAgICAgICAgY2xhc3NOYW1lPVwicHgtMiBweS0xIGJnLWJsdWUtNTAwIHRleHQtd2hpdGUgcm91bmRlZCB0ZXh0LXNtXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICB7c2hvd0Jlemllckd1aWRlcyA/ICdIaWRlIEd1aWRlcycgOiAnU2hvdyBHdWlkZXMnfVxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgIFxuICAgICAgICAgIHt0ZW1wUG9pbnRzLmxlbmd0aCA+PSA0ICYmIChcbiAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgIG9uQ2xpY2s9e2ZpbmFsaXplQmV6aWVyQ3VydmV9XG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cInB4LTIgcHktMSBiZy1ncmVlbi01MDAgdGV4dC13aGl0ZSByb3VuZGVkIHRleHQtc21cIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICBEcmF3IEN1cnZlXG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICApfVxuICAgICAgICAgIFxuICAgICAgICAgIHt0ZW1wUG9pbnRzLmxlbmd0aCA+IDAgJiYgKFxuICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0VGVtcFBvaW50cyhbXSl9XG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cInB4LTIgcHktMSBiZy1yZWQtNTAwIHRleHQtd2hpdGUgcm91bmRlZCB0ZXh0LXNtXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgQ2xlYXIgUG9pbnRzXG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICApfVxuICAgICAgICAgIFxuICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtc21cIj5cbiAgICAgICAgICAgIHt0ZW1wUG9pbnRzLmxlbmd0aH0gcG9pbnRzIHt0ZW1wUG9pbnRzLmxlbmd0aCA+PSA0ID8gJyhyZWFkeSknIDogJyhuZWVkIDQrKSd9XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG4gICAgICBcbiAgICAgIDxjYW52YXNcbiAgICAgICAgcmVmPXtjYW52YXNSZWZ9XG4gICAgICAgIHdpZHRoPXs5NjB9XG4gICAgICAgIGhlaWdodD17NTQwfVxuICAgICAgICBvbk1vdXNlRG93bj17KGUpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnQ2FudmFzIG9uTW91c2VEb3duJywgeyBjdXJyZW50VG9vbCwgaXNEcmF3aW5nIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEZvciBwZW4gKGJlemllcikgdG9vbCwgaGFuZGxlIGRpZmZlcmVudGx5XG4gICAgICAgICAgaWYgKGN1cnJlbnRUb29sID09PSAncGVuJykge1xuICAgICAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgd2UncmUgaW50ZXJhY3Rpbmcgd2l0aCBhIGNvbnRyb2wgcG9pbnRcbiAgICAgICAgICAgIGlmICghaGFuZGxlQmV6aWVyTW91c2VEb3duKGUpKSB7XG4gICAgICAgICAgICAgIC8vIElmIG5vdCBpbnRlcmFjdGluZyB3aXRoIGV4aXN0aW5nIHBvaW50cywgYWRkIGEgbmV3IHBvaW50XG4gICAgICAgICAgICAgIGhhbmRsZVBlblRvb2xDbGljayhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRm9yIG90aGVyIHRvb2xzLCB1c2UgdGhlIHJlZ3VsYXIgZHJhd2luZyBiZWhhdmlvclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0V4ZWN1dGluZyByZWd1bGFyIHN0YXJ0RHJhd2luZyBoYW5kbGVyJyk7XG4gICAgICAgICAgICBzdGFydERyYXdpbmcoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9fVxuICAgICAgICBvbk1vdXNlTW92ZT17KGUpID0+IHtcbiAgICAgICAgICAvLyBGb3IgcGVuIChiZXppZXIpIHRvb2wsIGhhbmRsZSBjb250cm9sIHBvaW50IGRyYWdnaW5nXG4gICAgICAgICAgaWYgKGN1cnJlbnRUb29sID09PSAncGVuJyAmJiBoYW5kbGVCZXppZXJNb3VzZU1vdmUoZSkpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGhhbmRsZWQgYSBiZXppZXIgY29udHJvbCBwb2ludCBtb3ZlLCByZXR1cm4gZWFybHlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRm9yIG90aGVyIHRvb2xzLCB1c2UgcmVndWxhciBkcmF3aW5nXG4gICAgICAgICAgZHJhdyhlKTtcbiAgICAgICAgfX1cbiAgICAgICAgb25Nb3VzZVVwPXsoZSkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdvbk1vdXNlVXAgZXZlbnQgdHJpZ2dlcmVkJywgeyBjdXJyZW50VG9vbCwgaXNEcmF3aW5nIH0pO1xuICAgICAgICAgIGhhbmRsZVN0b3BEcmF3aW5nKGUpO1xuICAgICAgICB9fVxuICAgICAgICBvbk1vdXNlTGVhdmU9eyhlKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ29uTW91c2VMZWF2ZSBldmVudCB0cmlnZ2VyZWQnLCB7IGN1cnJlbnRUb29sLCBpc0RyYXdpbmcgfSk7XG4gICAgICAgICAgaGFuZGxlU3RvcERyYXdpbmcoZSk7XG4gICAgICAgIH19XG4gICAgICAgIG9uRG91YmxlQ2xpY2s9e2hhbmRsZURvdWJsZUNsaWNrfVxuICAgICAgICBvbkNsaWNrPXtoYW5kbGVDYW52YXNDbGlja31cbiAgICAgICAgb25Ub3VjaFN0YXJ0PXtzdGFydERyYXdpbmd9XG4gICAgICAgIG9uVG91Y2hNb3ZlPXtkcmF3fVxuICAgICAgICBvblRvdWNoRW5kPXtoYW5kbGVTdG9wRHJhd2luZ31cbiAgICAgICAgb25LZXlEb3duPXtoYW5kbGVLZXlEb3dufVxuICAgICAgICB0YWJJbmRleD17MH1cbiAgICAgICAgY2xhc3NOYW1lPXtgYm9yZGVyLTIgYm9yZGVyLWJsYWNrIHctZnVsbCBzbTpoLVs2MHZoXSBoLVszMHZoXSBtaW4taC1bMzIwcHhdIGJnLXdoaXRlLzkwIHRvdWNoLW5vbmUgJHtcbiAgICAgICAgICBjdXJyZW50VG9vbCA9PT0gJ3BlbicgPyAnY3Vyc29yLWNyb3NzaGFpcicgOiAnaG92ZXI6Y3Vyc29yLWNyb3NzaGFpcidcbiAgICAgICAgfWB9XG4gICAgICAgIGFyaWEtbGFiZWw9XCJEcmF3aW5nIGNhbnZhc1wiXG4gICAgICAvPlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQ2FudmFzOyAiXSwibmFtZXMiOlsidXNlUmVmIiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJDYW52YXMiLCJjYW52YXNSZWYiLCJjdXJyZW50VG9vbCIsImlzRHJhd2luZyIsInN0YXJ0RHJhd2luZyIsImRyYXciLCJzdG9wRHJhd2luZyIsImhhbmRsZUNhbnZhc0NsaWNrIiwiaGFuZGxlUGVuQ2xpY2siLCJoYW5kbGVHZW5lcmF0aW9uIiwidGVtcFBvaW50cyIsInNldFRlbXBQb2ludHMiLCJzaG93QmV6aWVyR3VpZGVzIiwic2V0U2hvd0Jlemllckd1aWRlcyIsImRyYWdQb2ludEluZGV4Iiwic2V0RHJhZ1BvaW50SW5kZXgiLCJwcmV2ZW50VG91Y2hEZWZhdWx0IiwiZSIsInByZXZlbnREZWZhdWx0IiwiY2FudmFzIiwiY3VycmVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJwYXNzaXZlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNvbnNvbGUiLCJsb2ciLCJsZW5ndGgiLCJyZWRyYXdCZXppZXJHdWlkZXMiLCJoYW5kbGVLZXlEb3duIiwia2V5IiwiY3R4IiwiZ2V0Q29udGV4dCIsImNhbnZhc0ltYWdlIiwiSW1hZ2UiLCJzcmMiLCJ0b0RhdGFVUkwiLCJvbmxvYWQiLCJjbGVhclJlY3QiLCJ3aWR0aCIsImhlaWdodCIsImRyYXdJbWFnZSIsImRyYXdCZXppZXJHdWlkZXMiLCJiZWdpblBhdGgiLCJzdHJva2VTdHlsZSIsImxpbmVXaWR0aCIsIm1vdmVUbyIsIngiLCJ5IiwiaSIsImxpbmVUbyIsInN0cm9rZSIsImZvckVhY2giLCJwb2ludCIsImluZGV4IiwiZmlsbFN0eWxlIiwiYXJjIiwiTWF0aCIsIlBJIiwiZmlsbCIsImZvbnQiLCJ0ZXh0QWxpZ24iLCJ0ZXh0QmFzZWxpbmUiLCJmaWxsVGV4dCIsImhhbmRsZVN0b3BEcmF3aW5nIiwiZXZlbnRUeXBlIiwidHlwZSIsImhhbmRsZUdlbmVyYXRpb25FeGlzdHMiLCJzZXRUaW1lb3V0IiwiZXJyb3IiLCJpc1BlblRvb2wiLCJpc1BlbmNpbFRvb2wiLCJ3YXNEcmF3aW5nIiwiaGFuZGxlQmV6aWVyTW91c2VEb3duIiwiZ2V0Q29vcmRpbmF0ZXMiLCJkaXN0YW5jZSIsInNxcnQiLCJwb3ciLCJoYW5kbGVCZXppZXJNb3VzZU1vdmUiLCJuZXdQb2ludHMiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwic2NhbGVYIiwic2NhbGVZIiwiaW5jbHVkZXMiLCJ0b3VjaGVzIiwiY2xpZW50WCIsImxlZnQiLCJjbGllbnRZIiwidG9wIiwiaGFuZGxlRG91YmxlQ2xpY2siLCJjbG9zZXN0RGlzdGFuY2UiLCJJbmZpbml0eSIsImluc2VydEluZGV4IiwicDEiLCJwMiIsImRpc3RhbmNlVG9MaW5lU2VnbWVudCIsInNwbGljZSIsInAiLCJ4MSIsInkxIiwieDIiLCJ5MiIsImxlbmd0aFNxdWFyZWQiLCJ0IiwibWF4IiwibWluIiwicHJvamVjdGlvblgiLCJwcm9qZWN0aW9uWSIsImhhbmRsZVBlblRvb2xDbGljayIsInRvZ2dsZUJlemllckd1aWRlcyIsImZpbmFsaXplQmV6aWVyQ3VydmUiLCJiZXppZXJDdXJ2ZVRvIiwiZGl2IiwiY2xhc3NOYW1lIiwiaDIiLCJidXR0b24iLCJvbkNsaWNrIiwic3BhbiIsInJlZiIsIm9uTW91c2VEb3duIiwib25Nb3VzZU1vdmUiLCJvbk1vdXNlVXAiLCJvbk1vdXNlTGVhdmUiLCJvbkRvdWJsZUNsaWNrIiwib25Ub3VjaFN0YXJ0Iiwib25Ub3VjaE1vdmUiLCJvblRvdWNoRW5kIiwib25LZXlEb3duIiwidGFiSW5kZXgiLCJhcmlhLWxhYmVsIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/Canvas.js\n"));

/***/ })

});