"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_components_CanvasContainer_js",{

/***/ "(pages-dir-browser)/./components/Canvas.js":
/*!******************************!*\
  !*** ./components/Canvas.js ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/canvasUtils */ \"(pages-dir-browser)/./components/utils/canvasUtils.js\");\n\nvar _s = $RefreshSig$();\n\n\nconst Canvas = (param)=>{\n    let { canvasRef, currentTool, isDrawing, startDrawing, draw, stopDrawing, handleCanvasClick, handlePenClick, handleGeneration, tempPoints, setTempPoints } = param;\n    _s();\n    const [showBezierGuides, setShowBezierGuides] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [activePoint, setActivePoint] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(-1);\n    const [activeHandle, setActiveHandle] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [symmetric, setSymmetric] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [lastMousePos, setLastMousePos] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        x: 0,\n        y: 0\n    });\n    // Add touch event prevention function\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Canvas.useEffect\": ()=>{\n            // Function to prevent default touch behavior on canvas\n            const preventTouchDefault = {\n                \"Canvas.useEffect.preventTouchDefault\": (e)=>{\n                    if (isDrawing) {\n                        e.preventDefault();\n                    }\n                }\n            }[\"Canvas.useEffect.preventTouchDefault\"];\n            // Add event listener when component mounts\n            const canvas = canvasRef.current;\n            if (canvas) {\n                canvas.addEventListener('touchstart', preventTouchDefault, {\n                    passive: false\n                });\n                canvas.addEventListener('touchmove', preventTouchDefault, {\n                    passive: false\n                });\n            }\n            // Remove event listener when component unmounts\n            return ({\n                \"Canvas.useEffect\": ()=>{\n                    if (canvas) {\n                        canvas.removeEventListener('touchstart', preventTouchDefault);\n                        canvas.removeEventListener('touchmove', preventTouchDefault);\n                    }\n                }\n            })[\"Canvas.useEffect\"];\n        }\n    }[\"Canvas.useEffect\"], [\n        isDrawing,\n        canvasRef\n    ]);\n    // Add debugging info to console\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Canvas.useEffect\": ()=>{\n            console.log('Canvas tool changed or isDrawing changed:', {\n                currentTool,\n                isDrawing\n            });\n        }\n    }[\"Canvas.useEffect\"], [\n        currentTool,\n        isDrawing\n    ]);\n    // Redraw bezier guides and control points when tempPoints change\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Canvas.useEffect\": ()=>{\n            if (currentTool === 'pen' && tempPoints.length > 0 && showBezierGuides) {\n                redrawBezierGuides();\n            }\n        }\n    }[\"Canvas.useEffect\"], [\n        tempPoints,\n        showBezierGuides,\n        currentTool\n    ]);\n    const handleKeyDown = (e)=>{\n        // Add keyboard accessibility\n        if (e.key === 'Enter' || e.key === ' ') {\n            handleCanvasClick(e);\n        }\n        // Toggle symmetric handles with Shift key\n        if (e.key === 'Shift') {\n            setSymmetric(!symmetric);\n        }\n    };\n    // Draw bezier control points and guide lines\n    const redrawBezierGuides = ()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        // Get the canvas context\n        const ctx = canvas.getContext('2d');\n        // Save the current canvas state to redraw later\n        const canvasImage = new Image();\n        canvasImage.src = canvas.toDataURL();\n        canvasImage.onload = ()=>{\n            // Clear canvas\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            // Redraw the canvas content\n            ctx.drawImage(canvasImage, 0, 0);\n            // Draw the control points and guide lines\n            (0,_utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.drawBezierGuides)(ctx, tempPoints);\n        };\n    };\n    // Custom handler for stopping drawing with pen tool\n    const handleStopDrawing = (e)=>{\n        console.log('handleStopDrawing called', {\n            eventType: e === null || e === void 0 ? void 0 : e.type,\n            currentTool,\n            isDrawing,\n            activePoint,\n            activeHandle\n        });\n        // If we're using the pen tool with active point or handle\n        if (currentTool === 'pen') {\n            // If we were dragging a handle, just release it\n            if (activeHandle) {\n                setActiveHandle(null);\n                return;\n            }\n            // If we were dragging an anchor point, just release it\n            if (activePoint !== -1) {\n                setActivePoint(-1);\n                return;\n            }\n        }\n        stopDrawing(e);\n        // If using the pencil tool and we've just finished a drag, trigger generation\n        if (currentTool === 'pencil' && isDrawing) {\n            console.log(\"\".concat(currentTool, \" tool condition met, will try to trigger generation\"));\n            // Small delay to ensure the drawing is complete\n            setTimeout(()=>{\n                console.log('Attempting to call handleGeneration after timeout');\n                if (typeof handleGeneration === 'function') {\n                    console.log('Calling handleGeneration function');\n                    handleGeneration();\n                } else {\n                    console.error('handleGeneration is not a function:', handleGeneration);\n                }\n            }, 100);\n        } else {\n            console.log('Generation not triggered because:', {\n                isPenTool: currentTool === 'pen',\n                isPencilTool: currentTool === 'pencil',\n                wasDrawing: isDrawing\n            });\n        }\n    };\n    // Check if we clicked on an existing point or handle\n    const checkForPointOrHandle = (e)=>{\n        if (currentTool !== 'pen' || !showBezierGuides || tempPoints.length === 0) {\n            return false;\n        }\n        const canvas = canvasRef.current;\n        const { x, y } = (0,_utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.getCoordinates)(e, canvas);\n        setLastMousePos({\n            x,\n            y\n        });\n        // Check if we clicked on a handle\n        for(let i = 0; i < tempPoints.length; i++){\n            const point = tempPoints[i];\n            // Check for handleIn\n            if ((0,_utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.isNearHandle)(point, 'handleIn', x, y)) {\n                setActivePoint(i);\n                setActiveHandle('handleIn');\n                return true;\n            }\n            // Check for handleOut\n            if ((0,_utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.isNearHandle)(point, 'handleOut', x, y)) {\n                setActivePoint(i);\n                setActiveHandle('handleOut');\n                return true;\n            }\n            // Check for the anchor point itself\n            const distance = Math.sqrt((point.x - x) ** 2 + (point.y - y) ** 2);\n            if (distance <= 10) {\n                setActivePoint(i);\n                setActiveHandle(null);\n                return true;\n            }\n        }\n        return false;\n    };\n    // Handle mouse move for bezier control point or handle dragging\n    const handleBezierMouseMove = (e)=>{\n        if (currentTool !== 'pen') {\n            return false;\n        }\n        const canvas = canvasRef.current;\n        const { x, y } = (0,_utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.getCoordinates)(e, canvas);\n        const dx = x - lastMousePos.x;\n        const dy = y - lastMousePos.y;\n        // If we're dragging a handle\n        if (activePoint !== -1 && activeHandle) {\n            const newPoints = [\n                ...tempPoints\n            ];\n            (0,_utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.updateHandle)(newPoints[activePoint], activeHandle, dx, dy, symmetric);\n            setTempPoints(newPoints);\n            setLastMousePos({\n                x,\n                y\n            });\n            return true;\n        }\n        // If we're dragging an anchor point\n        if (activePoint !== -1) {\n            const newPoints = [\n                ...tempPoints\n            ];\n            newPoints[activePoint].x += dx;\n            newPoints[activePoint].y += dy;\n            // If this point has handles, move them with the point\n            if (newPoints[activePoint].handleIn) {\n            // No need to change the handle's offset, just move with the point\n            }\n            if (newPoints[activePoint].handleOut) {\n            // No need to change the handle's offset, just move with the point\n            }\n            setTempPoints(newPoints);\n            setLastMousePos({\n                x,\n                y\n            });\n            return true;\n        }\n        return false;\n    };\n    // Handle clicks for bezier curve tool\n    const handlePenToolClick = (e)=>{\n        const canvas = canvasRef.current;\n        const { x, y } = (0,_utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.getCoordinates)(e, canvas);\n        // Add a new point\n        if (tempPoints.length === 0) {\n            // First point has no handles initially\n            const newPoint = {\n                x,\n                y,\n                handleIn: null,\n                handleOut: null\n            };\n            setTempPoints([\n                newPoint\n            ]);\n        } else {\n            // Create a new point with handles relative to the last point\n            const newPoint = (0,_utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.createAnchorPoint)(x, y, tempPoints[tempPoints.length - 1]);\n            setTempPoints([\n                ...tempPoints,\n                newPoint\n            ]);\n        }\n        // Always show guides when adding points\n        setShowBezierGuides(true);\n    };\n    // Toggle bezier guide visibility\n    const toggleBezierGuides = ()=>{\n        setShowBezierGuides(!showBezierGuides);\n        if (showBezierGuides) {\n            redrawBezierGuides();\n        }\n    };\n    // Draw the final bezier curve and clear control points\n    const finalizeBezierCurve = ()=>{\n        if (tempPoints.length < 2) {\n            // Need at least 2 points for a path\n            console.log('Need at least 2 control points to draw a path');\n            return;\n        }\n        const canvas = canvasRef.current;\n        // Draw the actual bezier curve\n        (0,_utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.drawBezierCurve)(canvas, tempPoints);\n        // Hide guides and reset control points\n        setShowBezierGuides(false);\n        setTempPoints([]);\n        // Trigger generation\n        setTimeout(()=>{\n            if (typeof handleGeneration === 'function') {\n                handleGeneration();\n            }\n        }, 100);\n    };\n    // Add control point to segment\n    const addControlPoint = (e)=>{\n        if (currentTool !== 'pen' || tempPoints.length < 2) return;\n        const canvas = canvasRef.current;\n        const { x, y } = (0,_utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.getCoordinates)(e, canvas);\n        // Find the closest segment to add a point to\n        let closestDistance = Number.POSITIVE_INFINITY;\n        let insertIndex = -1;\n        for(let i = 0; i < tempPoints.length - 1; i++){\n            const p1 = tempPoints[i];\n            const p2 = tempPoints[i + 1];\n            // Calculate distance from click to line between points\n            // This is a simplified distance calculation for demo purposes\n            const lineLength = Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);\n            if (lineLength === 0) continue;\n            // Project point onto line\n            const t = ((x - p1.x) * (p2.x - p1.x) + (y - p1.y) * (p2.y - p1.y)) / (lineLength * lineLength);\n            // If projection is outside the line segment, skip\n            if (t < 0 || t > 1) continue;\n            // Calculate closest point on line\n            const closestX = p1.x + t * (p2.x - p1.x);\n            const closestY = p1.y + t * (p2.y - p1.y);\n            // Calculate distance to closest point\n            const distance = Math.sqrt((x - closestX) ** 2 + (y - closestY) ** 2);\n            if (distance < closestDistance && distance < 20) {\n                closestDistance = distance;\n                insertIndex = i + 1;\n            }\n        }\n        if (insertIndex > 0) {\n            // Create a new array with the new point inserted\n            const newPoints = [\n                ...tempPoints\n            ];\n            const prevPoint = newPoints[insertIndex - 1];\n            const nextPoint = newPoints[insertIndex];\n            // Create a new point at the click position with automatically calculated handles\n            const newPoint = {\n                x,\n                y,\n                // Calculate handles based on the positions of adjacent points\n                handleIn: {\n                    x: (prevPoint.x - x) * 0.25,\n                    y: (prevPoint.y - y) * 0.25\n                },\n                handleOut: {\n                    x: (nextPoint.x - x) * 0.25,\n                    y: (nextPoint.y - y) * 0.25\n                }\n            };\n            // Insert the new point\n            newPoints.splice(insertIndex, 0, newPoint);\n            setTempPoints(newPoints);\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"relative\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                className: \"text-lg font-bold mb-2\",\n                children: \"Draw here:\"\n            }, void 0, false, {\n                fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                lineNumber: 357,\n                columnNumber: 7\n            }, undefined),\n            currentTool === 'pen' && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex flex-wrap mb-2 gap-2\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        type: \"button\",\n                        onClick: toggleBezierGuides,\n                        className: \"px-2 py-1 bg-blue-500 text-white rounded text-sm\",\n                        children: showBezierGuides ? 'Hide Guides' : 'Show Guides'\n                    }, void 0, false, {\n                        fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                        lineNumber: 361,\n                        columnNumber: 11\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        type: \"button\",\n                        onClick: ()=>setSymmetric(!symmetric),\n                        className: \"px-2 py-1 \".concat(symmetric ? 'bg-green-500' : 'bg-gray-500', \" text-white rounded text-sm\"),\n                        children: symmetric ? 'Symmetric Handles' : 'Free Handles'\n                    }, void 0, false, {\n                        fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                        lineNumber: 369,\n                        columnNumber: 11\n                    }, undefined),\n                    tempPoints.length >= 2 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        type: \"button\",\n                        onClick: finalizeBezierCurve,\n                        className: \"px-2 py-1 bg-green-500 text-white rounded text-sm\",\n                        children: \"Draw Path\"\n                    }, void 0, false, {\n                        fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                        lineNumber: 378,\n                        columnNumber: 13\n                    }, undefined),\n                    tempPoints.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        type: \"button\",\n                        onClick: ()=>setTempPoints([]),\n                        className: \"px-2 py-1 bg-red-500 text-white rounded text-sm\",\n                        children: \"Clear Points\"\n                    }, void 0, false, {\n                        fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                        lineNumber: 388,\n                        columnNumber: 13\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"text-sm ml-2\",\n                        children: [\n                            tempPoints.length,\n                            \" point\",\n                            tempPoints.length !== 1 ? 's' : '',\n                            tempPoints.length >= 2 ? ' (ready)' : ' (need 2+)'\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                        lineNumber: 397,\n                        columnNumber: 11\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"w-full text-xs text-gray-600 mt-1\",\n                        children: \"Tip: Click to add points, click + drag handles to adjust curves, double-click on segments to add points\"\n                    }, void 0, false, {\n                        fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                        lineNumber: 402,\n                        columnNumber: 11\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                lineNumber: 360,\n                columnNumber: 9\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n                ref: canvasRef,\n                width: 960,\n                height: 540,\n                onMouseDown: (e)=>{\n                    console.log('Canvas onMouseDown', {\n                        currentTool,\n                        isDrawing\n                    });\n                    // For pen (bezier) tool, handle differently\n                    if (currentTool === 'pen') {\n                        // Check if we clicked on an existing point or handle\n                        if (!checkForPointOrHandle(e)) {\n                            // If not interacting with existing points/handles, add a new point\n                            handlePenToolClick(e);\n                        }\n                    } else {\n                        // For other tools, use the regular drawing behavior\n                        console.log('Executing regular startDrawing handler');\n                        startDrawing(e);\n                    }\n                },\n                onMouseMove: (e)=>{\n                    // For pen (bezier) tool, handle control point/handle dragging\n                    if (currentTool === 'pen' && handleBezierMouseMove(e)) {\n                        // If we handled a bezier element move, return early\n                        return;\n                    }\n                    // For other tools, use regular drawing\n                    draw(e);\n                },\n                onMouseUp: (e)=>{\n                    console.log('onMouseUp event triggered', {\n                        currentTool,\n                        isDrawing\n                    });\n                    handleStopDrawing(e);\n                },\n                onMouseLeave: (e)=>{\n                    console.log('onMouseLeave event triggered', {\n                        currentTool,\n                        isDrawing\n                    });\n                    handleStopDrawing(e);\n                },\n                onDoubleClick: (e)=>{\n                    if (currentTool === 'pen') {\n                        addControlPoint(e);\n                    } else {\n                        handleCanvasClick(e);\n                    }\n                },\n                onClick: handleCanvasClick,\n                onTouchStart: startDrawing,\n                onTouchMove: draw,\n                onTouchEnd: handleStopDrawing,\n                onKeyDown: handleKeyDown,\n                tabIndex: 0,\n                className: \"border-2 border-black w-full sm:h-[60vh] h-[30vh] min-h-[320px] bg-white/90 touch-none \".concat(currentTool === 'pen' ? 'cursor-crosshair' : 'hover:cursor-crosshair'),\n                \"aria-label\": \"Drawing canvas\"\n            }, void 0, false, {\n                fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                lineNumber: 408,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n        lineNumber: 356,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Canvas, \"f3p8T1PEfCpop1IrJ8IZQ/CsHFY=\");\n_c = Canvas;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Canvas);\nvar _c;\n$RefreshReg$(_c, \"Canvas\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvQ2FudmFzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQW9EO0FBUXZCO0FBRTdCLE1BQU1TLFNBQVM7UUFBQyxFQUNkQyxTQUFTLEVBQ1RDLFdBQVcsRUFDWEMsU0FBUyxFQUNUQyxZQUFZLEVBQ1pDLElBQUksRUFDSkMsV0FBVyxFQUNYQyxpQkFBaUIsRUFDakJDLGNBQWMsRUFDZEMsZ0JBQWdCLEVBQ2hCQyxVQUFVLEVBQ1ZDLGFBQWEsRUFDZDs7SUFDQyxNQUFNLENBQUNDLGtCQUFrQkMsb0JBQW9CLEdBQUdwQiwrQ0FBUUEsQ0FBQztJQUN6RCxNQUFNLENBQUNxQixhQUFhQyxlQUFlLEdBQUd0QiwrQ0FBUUEsQ0FBQyxDQUFDO0lBQ2hELE1BQU0sQ0FBQ3VCLGNBQWNDLGdCQUFnQixHQUFHeEIsK0NBQVFBLENBQUM7SUFDakQsTUFBTSxDQUFDeUIsV0FBV0MsYUFBYSxHQUFHMUIsK0NBQVFBLENBQUM7SUFDM0MsTUFBTSxDQUFDMkIsY0FBY0MsZ0JBQWdCLEdBQUc1QiwrQ0FBUUEsQ0FBQztRQUFFNkIsR0FBRztRQUFHQyxHQUFHO0lBQUU7SUFFOUQsc0NBQXNDO0lBQ3RDL0IsZ0RBQVNBOzRCQUFDO1lBQ1IsdURBQXVEO1lBQ3ZELE1BQU1nQzt3REFBc0IsQ0FBQ0M7b0JBQzNCLElBQUl0QixXQUFXO3dCQUNic0IsRUFBRUMsY0FBYztvQkFDbEI7Z0JBQ0Y7O1lBRUEsMkNBQTJDO1lBQzNDLE1BQU1DLFNBQVMxQixVQUFVMkIsT0FBTztZQUNoQyxJQUFJRCxRQUFRO2dCQUNWQSxPQUFPRSxnQkFBZ0IsQ0FBQyxjQUFjTCxxQkFBcUI7b0JBQUVNLFNBQVM7Z0JBQU07Z0JBQzVFSCxPQUFPRSxnQkFBZ0IsQ0FBQyxhQUFhTCxxQkFBcUI7b0JBQUVNLFNBQVM7Z0JBQU07WUFDN0U7WUFFQSxnREFBZ0Q7WUFDaEQ7b0NBQU87b0JBQ0wsSUFBSUgsUUFBUTt3QkFDVkEsT0FBT0ksbUJBQW1CLENB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O3dCQUN6QnVFLGdCQUFnQmhEO29CQUNsQixPQUFPO3dCQUNMbEIsa0JBQWtCa0I7b0JBQ3BCO2dCQUNGO2dCQUNBa0UsU0FBU3BGO2dCQUNUNEYsY0FBYy9GO2dCQUNkZ0csYUFBYS9GO2dCQUNiZ0csWUFBWXBEO2dCQUNacUQsV0FBV2xFO2dCQUNYbUUsVUFBVTtnQkFDVmYsV0FBVywwRkFFVixPQURDdEYsZ0JBQWdCLFFBQVEscUJBQXFCO2dCQUUvQ3NHLGNBQVc7Ozs7Ozs7Ozs7OztBQUluQjtHQXZjTXhHO0tBQUFBO0FBeWNOLGlFQUFlQSxNQUFNQSxFQUFDIiwic291cmNlcyI6WyIvVXNlcnMvdHJ1ZHlwL0Rlc2t0b3AvZGV2LWdlbWluaS0yLjAvY29tcG9uZW50cy9DYW52YXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlUmVmLCB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgXG4gIGdldENvb3JkaW5hdGVzLCBcbiAgZHJhd0JlemllckN1cnZlLCBcbiAgZHJhd0Jlemllckd1aWRlcywgXG4gIGNyZWF0ZUFuY2hvclBvaW50LFxuICBpc05lYXJIYW5kbGUsXG4gIHVwZGF0ZUhhbmRsZVxufSBmcm9tICcuL3V0aWxzL2NhbnZhc1V0aWxzJztcblxuY29uc3QgQ2FudmFzID0gKHtcbiAgY2FudmFzUmVmLFxuICBjdXJyZW50VG9vbCxcbiAgaXNEcmF3aW5nLFxuICBzdGFydERyYXdpbmcsXG4gIGRyYXcsXG4gIHN0b3BEcmF3aW5nLFxuICBoYW5kbGVDYW52YXNDbGljayxcbiAgaGFuZGxlUGVuQ2xpY2ssXG4gIGhhbmRsZUdlbmVyYXRpb24sXG4gIHRlbXBQb2ludHMsXG4gIHNldFRlbXBQb2ludHNcbn0pID0+IHtcbiAgY29uc3QgW3Nob3dCZXppZXJHdWlkZXMsIHNldFNob3dCZXppZXJHdWlkZXNdID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFthY3RpdmVQb2ludCwgc2V0QWN0aXZlUG9pbnRdID0gdXNlU3RhdGUoLTEpO1xuICBjb25zdCBbYWN0aXZlSGFuZGxlLCBzZXRBY3RpdmVIYW5kbGVdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtzeW1tZXRyaWMsIHNldFN5bW1ldHJpY10gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgY29uc3QgW2xhc3RNb3VzZVBvcywgc2V0TGFzdE1vdXNlUG9zXSA9IHVzZVN0YXRlKHsgeDogMCwgeTogMCB9KTtcblxuICAvLyBBZGQgdG91Y2ggZXZlbnQgcHJldmVudGlvbiBmdW5jdGlvblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIEZ1bmN0aW9uIHRvIHByZXZlbnQgZGVmYXVsdCB0b3VjaCBiZWhhdmlvciBvbiBjYW52YXNcbiAgICBjb25zdCBwcmV2ZW50VG91Y2hEZWZhdWx0ID0gKGUpID0+IHtcbiAgICAgIGlmIChpc0RyYXdpbmcpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBBZGQgZXZlbnQgbGlzdGVuZXIgd2hlbiBjb21wb25lbnQgbW91bnRzXG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKGNhbnZhcykge1xuICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBwcmV2ZW50VG91Y2hEZWZhdWx0LCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHByZXZlbnRUb3VjaERlZmF1bHQsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGV2ZW50IGxpc3RlbmVyIHdoZW4gY29tcG9uZW50IHVubW91bnRzXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBwcmV2ZW50VG91Y2hEZWZhdWx0KTtcbiAgICAgICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHByZXZlbnRUb3VjaERlZmF1bHQpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtpc0RyYXdpbmcsIGNhbnZhc1JlZl0pO1xuXG4gIC8vIEFkZCBkZWJ1Z2dpbmcgaW5mbyB0byBjb25zb2xlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ0NhbnZhcyB0b29sIGNoYW5nZWQgb3IgaXNEcmF3aW5nIGNoYW5nZWQ6JywgeyBjdXJyZW50VG9vbCwgaXNEcmF3aW5nIH0pO1xuICB9LCBbY3VycmVudFRvb2wsIGlzRHJhd2luZ10pO1xuXG4gIC8vIFJlZHJhdyBiZXppZXIgZ3VpZGVzIGFuZCBjb250cm9sIHBvaW50cyB3aGVuIHRlbXBQb2ludHMgY2hhbmdlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGN1cnJlbnRUb29sID09PSAncGVuJyAmJiB0ZW1wUG9pbnRzLmxlbmd0aCA+IDAgJiYgc2hvd0Jlemllckd1aWRlcykge1xuICAgICAgcmVkcmF3QmV6aWVyR3VpZGVzKCk7XG4gICAgfVxuICB9LCBbdGVtcFBvaW50cywgc2hvd0Jlemllckd1aWRlcywgY3VycmVudFRvb2xdKTtcblxuICBjb25zdCBoYW5kbGVLZXlEb3duID0gKGUpID0+IHtcbiAgICAvLyBBZGQga2V5Ym9hcmQgYWNjZXNzaWJpbGl0eVxuICAgIGlmIChlLmtleSA9PT0gJ0VudGVyJyB8fCBlLmtleSA9PT0gJyAnKSB7XG4gICAgICBoYW5kbGVDYW52YXNDbGljayhlKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVG9nZ2xlIHN5bW1ldHJpYyBoYW5kbGVzIHdpdGggU2hpZnQga2V5XG4gICAgaWYgKGUua2V5ID09PSAnU2hpZnQnKSB7XG4gICAgICBzZXRTeW1tZXRyaWMoIXN5bW1ldHJpYyk7XG4gICAgfVxuICB9O1xuXG4gIC8vIERyYXcgYmV6aWVyIGNvbnRyb2wgcG9pbnRzIGFuZCBndWlkZSBsaW5lc1xuICBjb25zdCByZWRyYXdCZXppZXJHdWlkZXMgPSAoKSA9PiB7XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFjYW52YXMpIHJldHVybjtcbiAgICBcbiAgICAvLyBHZXQgdGhlIGNhbnZhcyBjb250ZXh0XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgXG4gICAgLy8gU2F2ZSB0aGUgY3VycmVudCBjYW52YXMgc3RhdGUgdG8gcmVkcmF3IGxhdGVyXG4gICAgY29uc3QgY2FudmFzSW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICBjYW52YXNJbWFnZS5zcmMgPSBjYW52YXMudG9EYXRhVVJMKCk7XG4gICAgXG4gICAgY2FudmFzSW1hZ2Uub25sb2FkID0gKCkgPT4ge1xuICAgICAgLy8gQ2xlYXIgY2FudmFzXG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICBcbiAgICAgIC8vIFJlZHJhdyB0aGUgY2FudmFzIGNvbnRlbnRcbiAgICAgIGN0eC5kcmF3SW1hZ2UoY2FudmFzSW1hZ2UsIDAsIDApO1xuICAgICAgXG4gICAgICAvLyBEcmF3IHRoZSBjb250cm9sIHBvaW50cyBhbmQgZ3VpZGUgbGluZXNcbiAgICAgIGRyYXdCZXppZXJHdWlkZXMoY3R4LCB0ZW1wUG9pbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEN1c3RvbSBoYW5kbGVyIGZvciBzdG9wcGluZyBkcmF3aW5nIHdpdGggcGVuIHRvb2xcbiAgY29uc3QgaGFuZGxlU3RvcERyYXdpbmcgPSAoZSkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdoYW5kbGVTdG9wRHJhd2luZyBjYWxsZWQnLCB7IFxuICAgICAgZXZlbnRUeXBlOiBlPy50eXBlLCBcbiAgICAgIGN1cnJlbnRUb29sLCBcbiAgICAgIGlzRHJhd2luZywgXG4gICAgICBhY3RpdmVQb2ludCwgXG4gICAgICBhY3RpdmVIYW5kbGVcbiAgICB9KTtcbiAgICBcbiAgICAvLyBJZiB3ZSdyZSB1c2luZyB0aGUgcGVuIHRvb2wgd2l0aCBhY3RpdmUgcG9pbnQgb3IgaGFuZGxlXG4gICAgaWYgKGN1cnJlbnRUb29sID09PSAncGVuJykge1xuICAgICAgLy8gSWYgd2Ugd2VyZSBkcmFnZ2luZyBhIGhhbmRsZSwganVzdCByZWxlYXNlIGl0XG4gICAgICBpZiAoYWN0aXZlSGFuZGxlKSB7XG4gICAgICAgIHNldEFjdGl2ZUhhbmRsZShudWxsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBJZiB3ZSB3ZXJlIGRyYWdnaW5nIGFuIGFuY2hvciBwb2ludCwganVzdCByZWxlYXNlIGl0XG4gICAgICBpZiAoYWN0aXZlUG9pbnQgIT09IC0xKSB7XG4gICAgICAgIHNldEFjdGl2ZVBvaW50KC0xKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBzdG9wRHJhd2luZyhlKTtcbiAgICBcbiAgICAvLyBJZiB1c2luZyB0aGUgcGVuY2lsIHRvb2wgYW5kIHdlJ3ZlIGp1c3QgZmluaXNoZWQgYSBkcmFnLCB0cmlnZ2VyIGdlbmVyYXRpb25cbiAgICBpZiAoY3VycmVudFRvb2wgPT09ICdwZW5jaWwnICYmIGlzRHJhd2luZykge1xuICAgICAgY29uc29sZS5sb2coYCR7Y3VycmVudFRvb2x9IHRvb2wgY29uZGl0aW9uIG1ldCwgd2lsbCB0cnkgdG8gdHJpZ2dlciBnZW5lcmF0aW9uYCk7XG4gICAgICBcbiAgICAgIC8vIFNtYWxsIGRlbGF5IHRvIGVuc3VyZSB0aGUgZHJhd2luZyBpcyBjb21wbGV0ZVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdBdHRlbXB0aW5nIHRvIGNhbGwgaGFuZGxlR2VuZXJhdGlvbiBhZnRlciB0aW1lb3V0Jyk7XG4gICAgICAgIGlmICh0eXBlb2YgaGFuZGxlR2VuZXJhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdDYWxsaW5nIGhhbmRsZUdlbmVyYXRpb24gZnVuY3Rpb24nKTtcbiAgICAgICAgICBoYW5kbGVHZW5lcmF0aW9uKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignaGFuZGxlR2VuZXJhdGlvbiBpcyBub3QgYSBmdW5jdGlvbjonLCBoYW5kbGVHZW5lcmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSwgMTAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coJ0dlbmVyYXRpb24gbm90IHRyaWdnZXJlZCBiZWNhdXNlOicsIHsgXG4gICAgICAgIGlzUGVuVG9vbDogY3VycmVudFRvb2wgPT09ICdwZW4nLFxuICAgICAgICBpc1BlbmNpbFRvb2w6IGN1cnJlbnRUb29sID09PSAncGVuY2lsJyxcbiAgICAgICAgd2FzRHJhd2luZzogaXNEcmF3aW5nIFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIENoZWNrIGlmIHdlIGNsaWNrZWQgb24gYW4gZXhpc3RpbmcgcG9pbnQgb3IgaGFuZGxlXG4gIGNvbnN0IGNoZWNrRm9yUG9pbnRPckhhbmRsZSA9IChlKSA9PiB7XG4gICAgaWYgKGN1cnJlbnRUb29sICE9PSAncGVuJyB8fCAhc2hvd0Jlemllckd1aWRlcyB8fCB0ZW1wUG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGdldENvb3JkaW5hdGVzKGUsIGNhbnZhcyk7XG4gICAgc2V0TGFzdE1vdXNlUG9zKHsgeCwgeSB9KTtcbiAgICBcbiAgICAvLyBDaGVjayBpZiB3ZSBjbGlja2VkIG9uIGEgaGFuZGxlXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZW1wUG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHRlbXBQb2ludHNbaV07XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciBoYW5kbGVJblxuICAgICAgaWYgKGlzTmVhckhhbmRsZShwb2ludCwgJ2hhbmRsZUluJywgeCwgeSkpIHtcbiAgICAgICAgc2V0QWN0aXZlUG9pbnQoaSk7XG4gICAgICAgIHNldEFjdGl2ZUhhbmRsZSgnaGFuZGxlSW4nKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciBoYW5kbGVPdXRcbiAgICAgIGlmIChpc05lYXJIYW5kbGUocG9pbnQsICdoYW5kbGVPdXQnLCB4LCB5KSkge1xuICAgICAgICBzZXRBY3RpdmVQb2ludChpKTtcbiAgICAgICAgc2V0QWN0aXZlSGFuZGxlKCdoYW5kbGVPdXQnKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciB0aGUgYW5jaG9yIHBvaW50IGl0c2VsZlxuICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoKHBvaW50LnggLSB4KSAqKiAyICsgKHBvaW50LnkgLSB5KSAqKiAyKTtcbiAgICAgIGlmIChkaXN0YW5jZSA8PSAxMCkge1xuICAgICAgICBzZXRBY3RpdmVQb2ludChpKTtcbiAgICAgICAgc2V0QWN0aXZlSGFuZGxlKG51bGwpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBcbiAgLy8gSGFuZGxlIG1vdXNlIG1vdmUgZm9yIGJlemllciBjb250cm9sIHBvaW50IG9yIGhhbmRsZSBkcmFnZ2luZ1xuICBjb25zdCBoYW5kbGVCZXppZXJNb3VzZU1vdmUgPSAoZSkgPT4ge1xuICAgIGlmIChjdXJyZW50VG9vbCAhPT0gJ3BlbicpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBnZXRDb29yZGluYXRlcyhlLCBjYW52YXMpO1xuICAgIGNvbnN0IGR4ID0geCAtIGxhc3RNb3VzZVBvcy54O1xuICAgIGNvbnN0IGR5ID0geSAtIGxhc3RNb3VzZVBvcy55O1xuICAgIFxuICAgIC8vIElmIHdlJ3JlIGRyYWdnaW5nIGEgaGFuZGxlXG4gICAgaWYgKGFjdGl2ZVBvaW50ICE9PSAtMSAmJiBhY3RpdmVIYW5kbGUpIHtcbiAgICAgIGNvbnN0IG5ld1BvaW50cyA9IFsuLi50ZW1wUG9pbnRzXTtcbiAgICAgIHVwZGF0ZUhhbmRsZShuZXdQb2ludHNbYWN0aXZlUG9pbnRdLCBhY3RpdmVIYW5kbGUsIGR4LCBkeSwgc3ltbWV0cmljKTtcbiAgICAgIHNldFRlbXBQb2ludHMobmV3UG9pbnRzKTtcbiAgICAgIHNldExhc3RNb3VzZVBvcyh7IHgsIHkgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgLy8gSWYgd2UncmUgZHJhZ2dpbmcgYW4gYW5jaG9yIHBvaW50XG4gICAgaWYgKGFjdGl2ZVBvaW50ICE9PSAtMSkge1xuICAgICAgY29uc3QgbmV3UG9pbnRzID0gWy4uLnRlbXBQb2ludHNdO1xuICAgICAgbmV3UG9pbnRzW2FjdGl2ZVBvaW50XS54ICs9IGR4O1xuICAgICAgbmV3UG9pbnRzW2FjdGl2ZVBvaW50XS55ICs9IGR5O1xuICAgICAgXG4gICAgICAvLyBJZiB0aGlzIHBvaW50IGhhcyBoYW5kbGVzLCBtb3ZlIHRoZW0gd2l0aCB0aGUgcG9pbnRcbiAgICAgIGlmIChuZXdQb2ludHNbYWN0aXZlUG9pbnRdLmhhbmRsZUluKSB7XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gY2hhbmdlIHRoZSBoYW5kbGUncyBvZmZzZXQsIGp1c3QgbW92ZSB3aXRoIHRoZSBwb2ludFxuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAobmV3UG9pbnRzW2FjdGl2ZVBvaW50XS5oYW5kbGVPdXQpIHtcbiAgICAgICAgLy8gTm8gbmVlZCB0byBjaGFuZ2UgdGhlIGhhbmRsZSdzIG9mZnNldCwganVzdCBtb3ZlIHdpdGggdGhlIHBvaW50XG4gICAgICB9XG4gICAgICBcbiAgICAgIHNldFRlbXBQb2ludHMobmV3UG9pbnRzKTtcbiAgICAgIHNldExhc3RNb3VzZVBvcyh7IHgsIHkgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8vIEhhbmRsZSBjbGlja3MgZm9yIGJlemllciBjdXJ2ZSB0b29sXG4gIGNvbnN0IGhhbmRsZVBlblRvb2xDbGljayA9IChlKSA9PiB7XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBnZXRDb29yZGluYXRlcyhlLCBjYW52YXMpO1xuICAgIFxuICAgIC8vIEFkZCBhIG5ldyBwb2ludFxuICAgIGlmICh0ZW1wUG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gRmlyc3QgcG9pbnQgaGFzIG5vIGhhbmRsZXMgaW5pdGlhbGx5XG4gICAgICBjb25zdCBuZXdQb2ludCA9IHsgeCwgeSwgaGFuZGxlSW46IG51bGwsIGhhbmRsZU91dDogbnVsbCB9O1xuICAgICAgc2V0VGVtcFBvaW50cyhbbmV3UG9pbnRdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ3JlYXRlIGEgbmV3IHBvaW50IHdpdGggaGFuZGxlcyByZWxhdGl2ZSB0byB0aGUgbGFzdCBwb2ludFxuICAgICAgY29uc3QgbmV3UG9pbnQgPSBjcmVhdGVBbmNob3JQb2ludCh4LCB5LCB0ZW1wUG9pbnRzW3RlbXBQb2ludHMubGVuZ3RoIC0gMV0pO1xuICAgICAgc2V0VGVtcFBvaW50cyhbLi4udGVtcFBvaW50cywgbmV3UG9pbnRdKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQWx3YXlzIHNob3cgZ3VpZGVzIHdoZW4gYWRkaW5nIHBvaW50c1xuICAgIHNldFNob3dCZXppZXJHdWlkZXModHJ1ZSk7XG4gIH07XG4gIFxuICAvLyBUb2dnbGUgYmV6aWVyIGd1aWRlIHZpc2liaWxpdHlcbiAgY29uc3QgdG9nZ2xlQmV6aWVyR3VpZGVzID0gKCkgPT4ge1xuICAgIHNldFNob3dCZXppZXJHdWlkZXMoIXNob3dCZXppZXJHdWlkZXMpO1xuICAgIGlmIChzaG93QmV6aWVyR3VpZGVzKSB7XG4gICAgICByZWRyYXdCZXppZXJHdWlkZXMoKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRHJhdyB0aGUgZmluYWwgYmV6aWVyIGN1cnZlIGFuZCBjbGVhciBjb250cm9sIHBvaW50c1xuICBjb25zdCBmaW5hbGl6ZUJlemllckN1cnZlID0gKCkgPT4ge1xuICAgIGlmICh0ZW1wUG9pbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIC8vIE5lZWQgYXQgbGVhc3QgMiBwb2ludHMgZm9yIGEgcGF0aFxuICAgICAgY29uc29sZS5sb2coJ05lZWQgYXQgbGVhc3QgMiBjb250cm9sIHBvaW50cyB0byBkcmF3IGEgcGF0aCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBcbiAgICAvLyBEcmF3IHRoZSBhY3R1YWwgYmV6aWVyIGN1cnZlXG4gICAgZHJhd0JlemllckN1cnZlKGNhbnZhcywgdGVtcFBvaW50cyk7XG4gICAgXG4gICAgLy8gSGlkZSBndWlkZXMgYW5kIHJlc2V0IGNvbnRyb2wgcG9pbnRzXG4gICAgc2V0U2hvd0Jlemllckd1aWRlcyhmYWxzZSk7XG4gICAgc2V0VGVtcFBvaW50cyhbXSk7XG4gICAgXG4gICAgLy8gVHJpZ2dlciBnZW5lcmF0aW9uXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGhhbmRsZUdlbmVyYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaGFuZGxlR2VuZXJhdGlvbigpO1xuICAgICAgfVxuICAgIH0sIDEwMCk7XG4gIH07XG5cbiAgLy8gQWRkIGNvbnRyb2wgcG9pbnQgdG8gc2VnbWVudFxuICBjb25zdCBhZGRDb250cm9sUG9pbnQgPSAoZSkgPT4ge1xuICAgIGlmIChjdXJyZW50VG9vbCAhPT0gJ3BlbicgfHwgdGVtcFBvaW50cy5sZW5ndGggPCAyKSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBnZXRDb29yZGluYXRlcyhlLCBjYW52YXMpO1xuICAgIFxuICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3Qgc2VnbWVudCB0byBhZGQgYSBwb2ludCB0b1xuICAgIGxldCBjbG9zZXN0RGlzdGFuY2UgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IGluc2VydEluZGV4ID0gLTE7XG4gICAgXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZW1wUG9pbnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgY29uc3QgcDEgPSB0ZW1wUG9pbnRzW2ldO1xuICAgICAgY29uc3QgcDIgPSB0ZW1wUG9pbnRzW2kgKyAxXTtcbiAgICAgIFxuICAgICAgLy8gQ2FsY3VsYXRlIGRpc3RhbmNlIGZyb20gY2xpY2sgdG8gbGluZSBiZXR3ZWVuIHBvaW50c1xuICAgICAgLy8gVGhpcyBpcyBhIHNpbXBsaWZpZWQgZGlzdGFuY2UgY2FsY3VsYXRpb24gZm9yIGRlbW8gcHVycG9zZXNcbiAgICAgIGNvbnN0IGxpbmVMZW5ndGggPSBNYXRoLnNxcnQoKHAyLnggLSBwMS54KSAqKiAyICsgKHAyLnkgLSBwMS55KSAqKiAyKTtcbiAgICAgIGlmIChsaW5lTGVuZ3RoID09PSAwKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgLy8gUHJvamVjdCBwb2ludCBvbnRvIGxpbmVcbiAgICAgIGNvbnN0IHQgPSAoKHggLSBwMS54KSAqIChwMi54IC0gcDEueCkgKyAoeSAtIHAxLnkpICogKHAyLnkgLSBwMS55KSkgLyAobGluZUxlbmd0aCAqIGxpbmVMZW5ndGgpO1xuICAgICAgXG4gICAgICAvLyBJZiBwcm9qZWN0aW9uIGlzIG91dHNpZGUgdGhlIGxpbmUgc2VnbWVudCwgc2tpcFxuICAgICAgaWYgKHQgPCAwIHx8IHQgPiAxKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgLy8gQ2FsY3VsYXRlIGNsb3Nlc3QgcG9pbnQgb24gbGluZVxuICAgICAgY29uc3QgY2xvc2VzdFggPSBwMS54ICsgdCAqIChwMi54IC0gcDEueCk7XG4gICAgICBjb25zdCBjbG9zZXN0WSA9IHAxLnkgKyB0ICogKHAyLnkgLSBwMS55KTtcbiAgICAgIFxuICAgICAgLy8gQ2FsY3VsYXRlIGRpc3RhbmNlIHRvIGNsb3Nlc3QgcG9pbnRcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KCh4IC0gY2xvc2VzdFgpICoqIDIgKyAoeSAtIGNsb3Nlc3RZKSAqKiAyKTtcbiAgICAgIFxuICAgICAgaWYgKGRpc3RhbmNlIDwgY2xvc2VzdERpc3RhbmNlICYmIGRpc3RhbmNlIDwgMjApIHtcbiAgICAgICAgY2xvc2VzdERpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICAgIGluc2VydEluZGV4ID0gaSArIDE7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmIChpbnNlcnRJbmRleCA+IDApIHtcbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBhcnJheSB3aXRoIHRoZSBuZXcgcG9pbnQgaW5zZXJ0ZWRcbiAgICAgIGNvbnN0IG5ld1BvaW50cyA9IFsuLi50ZW1wUG9pbnRzXTtcbiAgICAgIGNvbnN0IHByZXZQb2ludCA9IG5ld1BvaW50c1tpbnNlcnRJbmRleCAtIDFdO1xuICAgICAgY29uc3QgbmV4dFBvaW50ID0gbmV3UG9pbnRzW2luc2VydEluZGV4XTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGEgbmV3IHBvaW50IGF0IHRoZSBjbGljayBwb3NpdGlvbiB3aXRoIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlZCBoYW5kbGVzXG4gICAgICBjb25zdCBuZXdQb2ludCA9IHsgXG4gICAgICAgIHgsIFxuICAgICAgICB5LFxuICAgICAgICAvLyBDYWxjdWxhdGUgaGFuZGxlcyBiYXNlZCBvbiB0aGUgcG9zaXRpb25zIG9mIGFkamFjZW50IHBvaW50c1xuICAgICAgICBoYW5kbGVJbjogeyBcbiAgICAgICAgICB4OiAocHJldlBvaW50LnggLSB4KSAqIDAuMjUsIFxuICAgICAgICAgIHk6IChwcmV2UG9pbnQueSAtIHkpICogMC4yNSBcbiAgICAgICAgfSxcbiAgICAgICAgaGFuZGxlT3V0OiB7IFxuICAgICAgICAgIHg6IChuZXh0UG9pbnQueCAtIHgpICogMC4yNSwgXG4gICAgICAgICAgeTogKG5leHRQb2ludC55IC0geSkgKiAwLjI1IFxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBJbnNlcnQgdGhlIG5ldyBwb2ludFxuICAgICAgbmV3UG9pbnRzLnNwbGljZShpbnNlcnRJbmRleCwgMCwgbmV3UG9pbnQpO1xuICAgICAgc2V0VGVtcFBvaW50cyhuZXdQb2ludHMpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwicmVsYXRpdmVcIj5cbiAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LWxnIGZvbnQtYm9sZCBtYi0yXCI+RHJhdyBoZXJlOjwvaDI+XG4gICAgICBcbiAgICAgIHtjdXJyZW50VG9vbCA9PT0gJ3BlbicgJiYgKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC13cmFwIG1iLTIgZ2FwLTJcIj5cbiAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIG9uQ2xpY2s9e3RvZ2dsZUJlemllckd1aWRlc31cbiAgICAgICAgICAgIGNsYXNzTmFtZT1cInB4LTIgcHktMSBiZy1ibHVlLTUwMCB0ZXh0LXdoaXRlIHJvdW5kZWQgdGV4dC1zbVwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAge3Nob3dCZXppZXJHdWlkZXMgPyAnSGlkZSBHdWlkZXMnIDogJ1Nob3cgR3VpZGVzJ31cbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICBcbiAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldFN5bW1ldHJpYyghc3ltbWV0cmljKX1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17YHB4LTIgcHktMSAke3N5bW1ldHJpYyA/ICdiZy1ncmVlbi01MDAnIDogJ2JnLWdyYXktNTAwJ30gdGV4dC13aGl0ZSByb3VuZGVkIHRleHQtc21gfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtzeW1tZXRyaWMgPyAnU3ltbWV0cmljIEhhbmRsZXMnIDogJ0ZyZWUgSGFuZGxlcyd9XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgXG4gICAgICAgICAge3RlbXBQb2ludHMubGVuZ3RoID49IDIgJiYgKFxuICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgb25DbGljaz17ZmluYWxpemVCZXppZXJDdXJ2ZX1cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwicHgtMiBweS0xIGJnLWdyZWVuLTUwMCB0ZXh0LXdoaXRlIHJvdW5kZWQgdGV4dC1zbVwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIERyYXcgUGF0aFxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgKX1cbiAgICAgICAgICBcbiAgICAgICAgICB7dGVtcFBvaW50cy5sZW5ndGggPiAwICYmIChcbiAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldFRlbXBQb2ludHMoW10pfVxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJweC0yIHB5LTEgYmctcmVkLTUwMCB0ZXh0LXdoaXRlIHJvdW5kZWQgdGV4dC1zbVwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIENsZWFyIFBvaW50c1xuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgKX1cbiAgICAgICAgICBcbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXNtIG1sLTJcIj5cbiAgICAgICAgICAgIHt0ZW1wUG9pbnRzLmxlbmd0aH0gcG9pbnR7dGVtcFBvaW50cy5sZW5ndGggIT09IDEgPyAncycgOiAnJ30gXG4gICAgICAgICAgICB7dGVtcFBvaW50cy5sZW5ndGggPj0gMiA/ICcgKHJlYWR5KScgOiAnIChuZWVkIDIrKSd9XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgIFxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIHRleHQteHMgdGV4dC1ncmF5LTYwMCBtdC0xXCI+XG4gICAgICAgICAgICBUaXA6IENsaWNrIHRvIGFkZCBwb2ludHMsIGNsaWNrICsgZHJhZyBoYW5kbGVzIHRvIGFkanVzdCBjdXJ2ZXMsIGRvdWJsZS1jbGljayBvbiBzZWdtZW50cyB0byBhZGQgcG9pbnRzXG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cbiAgICAgIFxuICAgICAgPGNhbnZhc1xuICAgICAgICByZWY9e2NhbnZhc1JlZn1cbiAgICAgICAgd2lkdGg9ezk2MH1cbiAgICAgICAgaGVpZ2h0PXs1NDB9XG4gICAgICAgIG9uTW91c2VEb3duPXsoZSkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdDYW52YXMgb25Nb3VzZURvd24nLCB7IGN1cnJlbnRUb29sLCBpc0RyYXdpbmcgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRm9yIHBlbiAoYmV6aWVyKSB0b29sLCBoYW5kbGUgZGlmZmVyZW50bHlcbiAgICAgICAgICBpZiAoY3VycmVudFRvb2wgPT09ICdwZW4nKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBjbGlja2VkIG9uIGFuIGV4aXN0aW5nIHBvaW50IG9yIGhhbmRsZVxuICAgICAgICAgICAgaWYgKCFjaGVja0ZvclBvaW50T3JIYW5kbGUoZSkpIHtcbiAgICAgICAgICAgICAgLy8gSWYgbm90IGludGVyYWN0aW5nIHdpdGggZXhpc3RpbmcgcG9pbnRzL2hhbmRsZXMsIGFkZCBhIG5ldyBwb2ludFxuICAgICAgICAgICAgICBoYW5kbGVQZW5Ub29sQ2xpY2soZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZvciBvdGhlciB0b29scywgdXNlIHRoZSByZWd1bGFyIGRyYXdpbmcgYmVoYXZpb3JcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFeGVjdXRpbmcgcmVndWxhciBzdGFydERyYXdpbmcgaGFuZGxlcicpO1xuICAgICAgICAgICAgc3RhcnREcmF3aW5nKGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfX1cbiAgICAgICAgb25Nb3VzZU1vdmU9eyhlKSA9PiB7XG4gICAgICAgICAgLy8gRm9yIHBlbiAoYmV6aWVyKSB0b29sLCBoYW5kbGUgY29udHJvbCBwb2ludC9oYW5kbGUgZHJhZ2dpbmdcbiAgICAgICAgICBpZiAoY3VycmVudFRvb2wgPT09ICdwZW4nICYmIGhhbmRsZUJlemllck1vdXNlTW92ZShlKSkge1xuICAgICAgICAgICAgLy8gSWYgd2UgaGFuZGxlZCBhIGJlemllciBlbGVtZW50IG1vdmUsIHJldHVybiBlYXJseVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBGb3Igb3RoZXIgdG9vbHMsIHVzZSByZWd1bGFyIGRyYXdpbmdcbiAgICAgICAgICBkcmF3KGUpO1xuICAgICAgICB9fVxuICAgICAgICBvbk1vdXNlVXA9eyhlKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ29uTW91c2VVcCBldmVudCB0cmlnZ2VyZWQnLCB7IGN1cnJlbnRUb29sLCBpc0RyYXdpbmcgfSk7XG4gICAgICAgICAgaGFuZGxlU3RvcERyYXdpbmcoZSk7XG4gICAgICAgIH19XG4gICAgICAgIG9uTW91c2VMZWF2ZT17KGUpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnb25Nb3VzZUxlYXZlIGV2ZW50IHRyaWdnZXJlZCcsIHsgY3VycmVudFRvb2wsIGlzRHJhd2luZyB9KTtcbiAgICAgICAgICBoYW5kbGVTdG9wRHJhd2luZyhlKTtcbiAgICAgICAgfX1cbiAgICAgICAgb25Eb3VibGVDbGljaz17KGUpID0+IHtcbiAgICAgICAgICBpZiAoY3VycmVudFRvb2wgPT09ICdwZW4nKSB7XG4gICAgICAgICAgICBhZGRDb250cm9sUG9pbnQoZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZUNhbnZhc0NsaWNrKGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfX1cbiAgICAgICAgb25DbGljaz17aGFuZGxlQ2FudmFzQ2xpY2t9XG4gICAgICAgIG9uVG91Y2hTdGFydD17c3RhcnREcmF3aW5nfVxuICAgICAgICBvblRvdWNoTW92ZT17ZHJhd31cbiAgICAgICAgb25Ub3VjaEVuZD17aGFuZGxlU3RvcERyYXdpbmd9XG4gICAgICAgIG9uS2V5RG93bj17aGFuZGxlS2V5RG93bn1cbiAgICAgICAgdGFiSW5kZXg9ezB9XG4gICAgICAgIGNsYXNzTmFtZT17YGJvcmRlci0yIGJvcmRlci1ibGFjayB3LWZ1bGwgc206aC1bNjB2aF0gaC1bMzB2aF0gbWluLWgtWzMyMHB4XSBiZy13aGl0ZS85MCB0b3VjaC1ub25lICR7XG4gICAgICAgICAgY3VycmVudFRvb2wgPT09ICdwZW4nID8gJ2N1cnNvci1jcm9zc2hhaXInIDogJ2hvdmVyOmN1cnNvci1jcm9zc2hhaXInXG4gICAgICAgIH1gfVxuICAgICAgICBhcmlhLWxhYmVsPVwiRHJhd2luZyBjYW52YXNcIlxuICAgICAgLz5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IENhbnZhczsgIl0sIm5hbWVzIjpbInVzZVJlZiIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwiZ2V0Q29vcmRpbmF0ZXMiLCJkcmF3QmV6aWVyQ3VydmUiLCJkcmF3QmV6aWVyR3VpZGVzIiwiY3JlYXRlQW5jaG9yUG9pbnQiLCJpc05lYXJIYW5kbGUiLCJ1cGRhdGVIYW5kbGUiLCJDYW52YXMiLCJjYW52YXNSZWYiLCJjdXJyZW50VG9vbCIsImlzRHJhd2luZyIsInN0YXJ0RHJhd2luZyIsImRyYXciLCJzdG9wRHJhd2luZyIsImhhbmRsZUNhbnZhc0NsaWNrIiwiaGFuZGxlUGVuQ2xpY2siLCJoYW5kbGVHZW5lcmF0aW9uIiwidGVtcFBvaW50cyIsInNldFRlbXBQb2ludHMiLCJzaG93QmV6aWVyR3VpZGVzIiwic2V0U2hvd0Jlemllckd1aWRlcyIsImFjdGl2ZVBvaW50Iiwic2V0QWN0aXZlUG9pbnQiLCJhY3RpdmVIYW5kbGUiLCJzZXRBY3RpdmVIYW5kbGUiLCJzeW1tZXRyaWMiLCJzZXRTeW1tZXRyaWMiLCJsYXN0TW91c2VQb3MiLCJzZXRMYXN0TW91c2VQb3MiLCJ4IiwieSIsInByZXZlbnRUb3VjaERlZmF1bHQiLCJlIiwicHJldmVudERlZmF1bHQiLCJjYW52YXMiLCJjdXJyZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsInBhc3NpdmUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY29uc29sZSIsImxvZyIsImxlbmd0aCIsInJlZHJhd0Jlemllckd1aWRlcyIsImhhbmRsZUtleURvd24iLCJrZXkiLCJjdHgiLCJnZXRDb250ZXh0IiwiY2FudmFzSW1hZ2UiLCJJbWFnZSIsInNyYyIsInRvRGF0YVVSTCIsIm9ubG9hZCIsImNsZWFyUmVjdCIsIndpZHRoIiwiaGVpZ2h0IiwiZHJhd0ltYWdlIiwiaGFuZGxlU3RvcERyYXdpbmciLCJldmVudFR5cGUiLCJ0eXBlIiwic2V0VGltZW91dCIsImVycm9yIiwiaXNQZW5Ub29sIiwiaXNQZW5jaWxUb29sIiwid2FzRHJhd2luZyIsImNoZWNrRm9yUG9pbnRPckhhbmRsZSIsImkiLCJwb2ludCIsImRpc3RhbmNlIiwiTWF0aCIsInNxcnQiLCJoYW5kbGVCZXppZXJNb3VzZU1vdmUiLCJkeCIsImR5IiwibmV3UG9pbnRzIiwiaGFuZGxlSW4iLCJoYW5kbGVPdXQiLCJoYW5kbGVQZW5Ub29sQ2xpY2siLCJuZXdQb2ludCIsInRvZ2dsZUJlemllckd1aWRlcyIsImZpbmFsaXplQmV6aWVyQ3VydmUiLCJhZGRDb250cm9sUG9pbnQiLCJjbG9zZXN0RGlzdGFuY2UiLCJOdW1iZXIiLCJQT1NJVElWRV9JTkZJTklUWSIsImluc2VydEluZGV4IiwicDEiLCJwMiIsImxpbmVMZW5ndGgiLCJ0IiwiY2xvc2VzdFgiLCJjbG9zZXN0WSIsInByZXZQb2ludCIsIm5leHRQb2ludCIsInNwbGljZSIsImRpdiIsImNsYXNzTmFtZSIsImgyIiwiYnV0dG9uIiwib25DbGljayIsInNwYW4iLCJyZWYiLCJvbk1vdXNlRG93biIsIm9uTW91c2VNb3ZlIiwib25Nb3VzZVVwIiwib25Nb3VzZUxlYXZlIiwib25Eb3VibGVDbGljayIsIm9uVG91Y2hTdGFydCIsIm9uVG91Y2hNb3ZlIiwib25Ub3VjaEVuZCIsIm9uS2V5RG93biIsInRhYkluZGV4IiwiYXJpYS1sYWJlbCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/Canvas.js\n"));

/***/ })

});