"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_components_CanvasContainer_js",{

/***/ "(pages-dir-browser)/./components/Canvas.js":
/*!******************************!*\
  !*** ./components/Canvas.js ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/canvasUtils */ \"(pages-dir-browser)/./components/utils/canvasUtils.js\");\n\nvar _s = $RefreshSig$();\n\n\nconst Canvas = (param)=>{\n    let { canvasRef, currentTool, isDrawing, startDrawing, draw, stopDrawing, handleCanvasClick, handlePenClick, handleGeneration, tempPoints, setTempPoints } = param;\n    _s();\n    const [showBezierGuides, setShowBezierGuides] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [activePoint, setActivePoint] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(-1);\n    const [activeHandle, setActiveHandle] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [symmetric, setSymmetric] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [lastMousePos, setLastMousePos] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        x: 0,\n        y: 0\n    });\n    const [hasDrawing, setHasDrawing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [strokeCount, setStrokeCount] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    // Add touch event prevention function\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Canvas.useEffect\": ()=>{\n            // Function to prevent default touch behavior on canvas\n            const preventTouchDefault = {\n                \"Canvas.useEffect.preventTouchDefault\": (e)=>{\n                    if (isDrawing) {\n                        e.preventDefault();\n                    }\n                }\n            }[\"Canvas.useEffect.preventTouchDefault\"];\n            // Add event listener when component mounts\n            const canvas = canvasRef.current;\n            if (canvas) {\n                canvas.addEventListener('touchstart', preventTouchDefault, {\n                    passive: false\n                });\n                canvas.addEventListener('touchmove', preventTouchDefault, {\n                    passive: false\n                });\n            }\n            // Remove event listener when component unmounts\n            return ({\n                \"Canvas.useEffect\": ()=>{\n                    if (canvas) {\n                        canvas.removeEventListener('touchstart', preventTouchDefault);\n                        canvas.removeEventListener('touchmove', preventTouchDefault);\n                    }\n                }\n            })[\"Canvas.useEffect\"];\n        }\n    }[\"Canvas.useEffect\"], [\n        isDrawing,\n        canvasRef\n    ]);\n    // Add debugging info to console\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Canvas.useEffect\": ()=>{\n            console.log('Canvas tool changed or isDrawing changed:', {\n                currentTool,\n                isDrawing\n            });\n        }\n    }[\"Canvas.useEffect\"], [\n        currentTool,\n        isDrawing\n    ]);\n    // Redraw bezier guides and control points when tempPoints change\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Canvas.useEffect\": ()=>{\n            if (currentTool === 'pen' && tempPoints.length > 0 && showBezierGuides) {\n                redrawBezierGuides();\n            }\n        }\n    }[\"Canvas.useEffect\"], [\n        tempPoints,\n        showBezierGuides,\n        currentTool\n    ]);\n    // Add useEffect to check if canvas has content\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Canvas.useEffect\": ()=>{\n            const canvas = canvasRef.current;\n            if (!canvas) return;\n            const ctx = canvas.getContext('2d');\n            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n            // Check if canvas has any non-white pixels (i.e., has a drawing)\n            const hasNonWhitePixels = Array.from(imageData.data).some({\n                \"Canvas.useEffect.hasNonWhitePixels\": (pixel, index)=>{\n                    // Check only RGB values (skip alpha)\n                    return index % 4 !== 3 && pixel !== 255;\n                }\n            }[\"Canvas.useEffect.hasNonWhitePixels\"]);\n            setHasDrawing(hasNonWhitePixels);\n        }\n    }[\"Canvas.useEffect\"], [\n        isDrawing,\n        canvasRef\n    ]);\n    const handleKeyDown = (e)=>{\n        // Add keyboard accessibility\n        if (e.key === 'Enter' || e.key === ' ') {\n            handleCanvasClick(e);\n        }\n        // Toggle symmetric handles with Shift key\n        if (e.key === 'Shift') {\n            setSymmetric(!symmetric);\n        }\n    };\n    // Draw bezier control points and guide lines\n    const redrawBezierGuides = ()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        // Get the canvas context\n        const ctx = canvas.getContext('2d');\n        // Save the current canvas state to redraw later\n        const canvasImage = new Image();\n        canvasImage.src = canvas.toDataURL();\n        canvasImage.onload = ()=>{\n            // Clear canvas\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            // Redraw the canvas content\n            ctx.drawImage(canvasImage, 0, 0);\n            // Draw the control points and guide lines\n            (0,_utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.drawBezierGuides)(ctx, tempPoints);\n        };\n    };\n    // Custom handler for stopping drawing with pen tool\n    const handleStopDrawing = (e)=>{\n        console.log('handleStopDrawing called', {\n            eventType: e === null || e === void 0 ? void 0 : e.type,\n            currentTool,\n            isDrawing,\n            activePoint,\n            activeHandle\n        });\n        // If we're using the pen tool with active point or handle\n        if (currentTool === 'pen') {\n            // If we were dragging a handle, just release it\n            if (activeHandle) {\n                setActiveHandle(null);\n                return;\n            }\n            // If we were dragging an anchor point, just release it\n            if (activePoint !== -1) {\n                setActivePoint(-1);\n                return;\n            }\n        }\n        stopDrawing(e);\n        // If using the pencil tool and we've just finished a drag, trigger generation\n        if (currentTool === 'pencil' && isDrawing) {\n            console.log(\"\".concat(currentTool, \" tool condition met, will try to trigger generation\"));\n            // Small delay to ensure the drawing is complete\n            setTimeout(()=>{\n                console.log('Attempting to call handleGeneration after timeout');\n                if (typeof handleGeneration === 'function') {\n                    console.log('Calling handleGeneration function');\n                    handleGeneration();\n                } else {\n                    console.error('handleGeneration is not a function:', handleGeneration);\n                }\n            }, 100);\n        } else {\n            console.log('Generation not triggered because:', {\n                isPenTool: currentTool === 'pen',\n                isPencilTool: currentTool === 'pencil',\n                wasDrawing: isDrawing\n            });\n        }\n    };\n    // Check if we clicked on an existing point or handle\n    const checkForPointOrHandle = (e)=>{\n        if (currentTool !== 'pen' || !showBezierGuides || tempPoints.length === 0) {\n            return false;\n        }\n        const canvas = canvasRef.current;\n        const { x, y } = (0,_utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.getCoordinates)(e, canvas);\n        setLastMousePos({\n            x,\n            y\n        });\n        // Check if we clicked on a handle\n        for(let i = 0; i < tempPoints.length; i++){\n            const point = tempPoints[i];\n            // Check for handleIn\n            if ((0,_utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.isNearHandle)(point, 'handleIn', x, y)) {\n                setActivePoint(i);\n                setActiveHandle('handleIn');\n                return true;\n            }\n            // Check for handleOut\n            if ((0,_utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.isNearHandle)(point, 'handleOut', x, y)) {\n                setActivePoint(i);\n                setActiveHandle('handleOut');\n                return true;\n            }\n            // Check for the anchor point itself\n            const distance = Math.sqrt((point.x - x) ** 2 + (point.y - y) ** 2);\n            if (distance <= 10) {\n                setActivePoint(i);\n                setActiveHandle(null);\n                return true;\n            }\n        }\n        return false;\n    };\n    // Handle mouse move for bezier control point or handle dragging\n    const handleBezierMouseMove = (e)=>{\n        if (currentTool !== 'pen') {\n            return false;\n        }\n        const canvas = canvasRef.current;\n        const { x, y } = (0,_utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.getCoordinates)(e, canvas);\n        const dx = x - lastMousePos.x;\n        const dy = y - lastMousePos.y;\n        // If we're dragging a handle\n        if (activePoint !== -1 && activeHandle) {\n            const newPoints = [\n                ...tempPoints\n            ];\n            (0,_utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.updateHandle)(newPoints[activePoint], activeHandle, dx, dy, symmetric);\n            setTempPoints(newPoints);\n            setLastMousePos({\n                x,\n                y\n            });\n            return true;\n        }\n        // If we're dragging an anchor point\n        if (activePoint !== -1) {\n            const newPoints = [\n                ...tempPoints\n            ];\n            newPoints[activePoint].x += dx;\n            newPoints[activePoint].y += dy;\n            // If this point has handles, move them with the point\n            if (newPoints[activePoint].handleIn) {\n            // No need to change the handle's offset, just move with the point\n            }\n            if (newPoints[activePoint].handleOut) {\n            // No need to change the handle's offset, just move with the point\n            }\n            setTempPoints(newPoints);\n            setLastMousePos({\n                x,\n                y\n            });\n            return true;\n        }\n        return false;\n    };\n    // Handle clicks for bezier curve tool\n    const handlePenToolClick = (e)=>{\n        const canvas = canvasRef.current;\n        const { x, y } = (0,_utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.getCoordinates)(e, canvas);\n        // Add a new point\n        if (tempPoints.length === 0) {\n            // First point has no handles initially\n            const newPoint = {\n                x,\n                y,\n                handleIn: null,\n                handleOut: null\n            };\n            setTempPoints([\n                newPoint\n            ]);\n        } else {\n            // Create a new point with handles relative to the last point\n            const newPoint = (0,_utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.createAnchorPoint)(x, y, tempPoints[tempPoints.length - 1]);\n            setTempPoints([\n                ...tempPoints,\n                newPoint\n            ]);\n        }\n        // Always show guides when adding points\n        setShowBezierGuides(true);\n    };\n    // Toggle bezier guide visibility\n    const toggleBezierGuides = ()=>{\n        setShowBezierGuides(!showBezierGuides);\n        if (showBezierGuides) {\n            redrawBezierGuides();\n        }\n    };\n    // Draw the final bezier curve and clear control points\n    const finalizeBezierCurve = ()=>{\n        if (tempPoints.length < 2) {\n            // Need at least 2 points for a path\n            console.log('Need at least 2 control points to draw a path');\n            return;\n        }\n        const canvas = canvasRef.current;\n        // Draw the actual bezier curve\n        (0,_utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.drawBezierCurve)(canvas, tempPoints);\n        // Hide guides and reset control points\n        setShowBezierGuides(false);\n        setTempPoints([]);\n        // Trigger generation\n        setTimeout(()=>{\n            if (typeof handleGeneration === 'function') {\n                handleGeneration();\n            }\n        }, 100);\n    };\n    // Add control point to segment\n    const addControlPoint = (e)=>{\n        if (currentTool !== 'pen' || tempPoints.length < 2) return;\n        const canvas = canvasRef.current;\n        const { x, y } = (0,_utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.getCoordinates)(e, canvas);\n        // Find the closest segment to add a point to\n        let closestDistance = Number.POSITIVE_INFINITY;\n        let insertIndex = -1;\n        for(let i = 0; i < tempPoints.length - 1; i++){\n            const p1 = tempPoints[i];\n            const p2 = tempPoints[i + 1];\n            // Calculate distance from click to line between points\n            // This is a simplified distance calculation for demo purposes\n            const lineLength = Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);\n            if (lineLength === 0) continue;\n            // Project point onto line\n            const t = ((x - p1.x) * (p2.x - p1.x) + (y - p1.y) * (p2.y - p1.y)) / (lineLength * lineLength);\n            // If projection is outside the line segment, skip\n            if (t < 0 || t > 1) continue;\n            // Calculate closest point on line\n            const closestX = p1.x + t * (p2.x - p1.x);\n            const closestY = p1.y + t * (p2.y - p1.y);\n            // Calculate distance to closest point\n            const distance = Math.sqrt((x - closestX) ** 2 + (y - closestY) ** 2);\n            if (distance < closestDistance && distance < 20) {\n                closestDistance = distance;\n                insertIndex = i + 1;\n            }\n        }\n        if (insertIndex > 0) {\n            // Create a new array with the new point inserted\n            const newPoints = [\n                ...tempPoints\n            ];\n            const prevPoint = newPoints[insertIndex - 1];\n            const nextPoint = newPoints[insertIndex];\n            // Create a new point at the click position with automatically calculated handles\n            const newPoint = {\n                x,\n                y,\n                // Calculate handles based on the positions of adjacent points\n                handleIn: {\n                    x: (prevPoint.x - x) * 0.25,\n                    y: (prevPoint.y - y) * 0.25\n                },\n                handleOut: {\n                    x: (nextPoint.x - x) * 0.25,\n                    y: (nextPoint.y - y) * 0.25\n                }\n            };\n            // Insert the new point\n            newPoints.splice(insertIndex, 0, newPoint);\n            setTempPoints(newPoints);\n        }\n    };\n    // Wrap the original startDrawing function to handle empty canvas\n    const handleStartDrawing = (e)=>{\n        // Call the original startDrawing function\n        startDrawing(e);\n        setHasDrawing(true);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"relative\",\n        children: [\n            currentTool === 'pen' && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex flex-wrap mb-2 gap-2\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        type: \"button\",\n                        onClick: toggleBezierGuides,\n                        className: \"px-2 py-1 bg-blue-500 text-white rounded text-sm\",\n                        children: showBezierGuides ? 'Hide Guides' : 'Show Guides'\n                    }, void 0, false, {\n                        fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                        lineNumber: 385,\n                        columnNumber: 11\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        type: \"button\",\n                        onClick: ()=>setSymmetric(!symmetric),\n                        className: \"px-2 py-1 \".concat(symmetric ? 'bg-green-500' : 'bg-gray-500', \" text-white rounded text-sm\"),\n                        children: symmetric ? 'Symmetric Handles' : 'Free Handles'\n                    }, void 0, false, {\n                        fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                        lineNumber: 393,\n                        columnNumber: 11\n                    }, undefined),\n                    tempPoints.length >= 2 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        type: \"button\",\n                        onClick: finalizeBezierCurve,\n                        className: \"px-2 py-1 bg-green-500 text-white rounded text-sm\",\n                        children: \"Draw Path\"\n                    }, void 0, false, {\n                        fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                        lineNumber: 402,\n                        columnNumber: 13\n                    }, undefined),\n                    tempPoints.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        type: \"button\",\n                        onClick: ()=>setTempPoints([]),\n                        className: \"px-2 py-1 bg-red-500 text-white rounded text-sm\",\n                        children: \"Clear Points\"\n                    }, void 0, false, {\n                        fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                        lineNumber: 412,\n                        columnNumber: 13\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"text-sm ml-2\",\n                        children: [\n                            tempPoints.length,\n                            \" point\",\n                            tempPoints.length !== 1 ? 's' : '',\n                            tempPoints.length >= 2 ? ' (ready)' : ' (need 2+)'\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                        lineNumber: 421,\n                        columnNumber: 11\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"w-full text-xs text-gray-600 mt-1\",\n                        children: \"Tip: Click to add points, click + drag handles to adjust curves, double-click on segments to add points\"\n                    }, void 0, false, {\n                        fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                        lineNumber: 426,\n                        columnNumber: 11\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                lineNumber: 384,\n                columnNumber: 9\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"relative\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n                        ref: canvasRef,\n                        width: 960,\n                        height: 540,\n                        onMouseDown: (e)=>{\n                            console.log('Canvas onMouseDown', {\n                                currentTool,\n                                isDrawing\n                            });\n                            // For pen (bezier) tool, handle differently\n                            if (currentTool === 'pen') {\n                                // Check if we clicked on an existing point or handle\n                                if (!checkForPointOrHandle(e)) {\n                                    // If not interacting with existing points/handles, add a new point\n                                    handlePenToolClick(e);\n                                }\n                            } else {\n                                // For other tools, use the regular drawing behavior\n                                console.log('Executing regular startDrawing handler');\n                                handleStartDrawing(e);\n                            }\n                        },\n                        onMouseMove: (e)=>{\n                            // For pen (bezier) tool, handle control point/handle dragging\n                            if (currentTool === 'pen' && handleBezierMouseMove(e)) {\n                                // If we handled a bezier element move, return early\n                                return;\n                            }\n                            // For other tools, use regular drawing\n                            draw(e);\n                        },\n                        onMouseUp: (e)=>{\n                            console.log('onMouseUp event triggered', {\n                                currentTool,\n                                isDrawing\n                            });\n                            handleStopDrawing(e);\n                        },\n                        onMouseLeave: (e)=>{\n                            console.log('onMouseLeave event triggered', {\n                                currentTool,\n                                isDrawing\n                            });\n                            handleStopDrawing(e);\n                        },\n                        onDoubleClick: (e)=>{\n                            if (currentTool === 'pen') {\n                                addControlPoint(e);\n                            } else {\n                                handleCanvasClick(e);\n                            }\n                        },\n                        onClick: handleCanvasClick,\n                        onTouchStart: handleStartDrawing,\n                        onTouchMove: draw,\n                        onTouchEnd: handleStopDrawing,\n                        onKeyDown: handleKeyDown,\n                        tabIndex: 0,\n                        className: \"border-2 border-black w-full sm:h-[60vh] h-[30vh] min-h-[320px] bg-white/90 touch-none \".concat(currentTool === 'pen' ? 'cursor-crosshair' : 'hover:cursor-crosshair'),\n                        \"aria-label\": \"Drawing canvas\"\n                    }, void 0, false, {\n                        fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                        lineNumber: 433,\n                        columnNumber: 9\n                    }, undefined),\n                    !hasDrawing && !isDrawing && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"absolute inset-0 flex items-center justify-center pointer-events-none\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            className: \"text-gray-400 text-xl font-medium\",\n                            children: \"Draw here\"\n                        }, void 0, false, {\n                            fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                            lineNumber: 493,\n                            columnNumber: 13\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                        lineNumber: 492,\n                        columnNumber: 11\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                lineNumber: 432,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n        lineNumber: 382,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Canvas, \"FE+guw1aGCajRuwpOxHqFERoNxg=\");\n_c = Canvas;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Canvas);\nvar _c;\n$RefreshReg$(_c, \"Canvas\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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aUVBQWVBLE1BQU1BLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy90cnVkeXAvRGVza3RvcC9kZXYtZ2VtaW5pLTIuMC9jb21wb25lbnRzL0NhbnZhcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VSZWYsIHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBcbiAgZ2V0Q29vcmRpbmF0ZXMsIFxuICBkcmF3QmV6aWVyQ3VydmUsIFxuICBkcmF3QmV6aWVyR3VpZGVzLCBcbiAgY3JlYXRlQW5jaG9yUG9pbnQsXG4gIGlzTmVhckhhbmRsZSxcbiAgdXBkYXRlSGFuZGxlXG59IGZyb20gJy4vdXRpbHMvY2FudmFzVXRpbHMnO1xuXG5jb25zdCBDYW52YXMgPSAoe1xuICBjYW52YXNSZWYsXG4gIGN1cnJlbnRUb29sLFxuICBpc0RyYXdpbmcsXG4gIHN0YXJ0RHJhd2luZyxcbiAgZHJhdyxcbiAgc3RvcERyYXdpbmcsXG4gIGhhbmRsZUNhbnZhc0NsaWNrLFxuICBoYW5kbGVQZW5DbGljayxcbiAgaGFuZGxlR2VuZXJhdGlvbixcbiAgdGVtcFBvaW50cyxcbiAgc2V0VGVtcFBvaW50c1xufSkgPT4ge1xuICBjb25zdCBbc2hvd0Jlemllckd1aWRlcywgc2V0U2hvd0Jlemllckd1aWRlc10gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgY29uc3QgW2FjdGl2ZVBvaW50LCBzZXRBY3RpdmVQb2ludF0gPSB1c2VTdGF0ZSgtMSk7XG4gIGNvbnN0IFthY3RpdmVIYW5kbGUsIHNldEFjdGl2ZUhhbmRsZV0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW3N5bW1ldHJpYywgc2V0U3ltbWV0cmljXSA9IHVzZVN0YXRlKHRydWUpO1xuICBjb25zdCBbbGFzdE1vdXNlUG9zLCBzZXRMYXN0TW91c2VQb3NdID0gdXNlU3RhdGUoeyB4OiAwLCB5OiAwIH0pO1xuICBjb25zdCBbaGFzRHJhd2luZywgc2V0SGFzRHJhd2luZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtzdHJva2VDb3VudCwgc2V0U3Ryb2tlQ291bnRdID0gdXNlU3RhdGUoMCk7XG5cbiAgLy8gQWRkIHRvdWNoIGV2ZW50IHByZXZlbnRpb24gZnVuY3Rpb25cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBGdW5jdGlvbiB0byBwcmV2ZW50IGRlZmF1bHQgdG91Y2ggYmVoYXZpb3Igb24gY2FudmFzXG4gICAgY29uc3QgcHJldmVudFRvdWNoRGVmYXVsdCA9IChlKSA9PiB7XG4gICAgICBpZiAoaXNEcmF3aW5nKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gQWRkIGV2ZW50IGxpc3RlbmVyIHdoZW4gY29tcG9uZW50IG1vdW50c1xuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGlmIChjYW52YXMpIHtcbiAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgcHJldmVudFRvdWNoRGVmYXVsdCwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBwcmV2ZW50VG91Y2hEZWZhdWx0LCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBldmVudCBsaXN0ZW5lciB3aGVuIGNvbXBvbmVudCB1bm1vdW50c1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgcHJldmVudFRvdWNoRGVmYXVsdCk7XG4gICAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBwcmV2ZW50VG91Y2hEZWZhdWx0KTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbaXNEcmF3aW5nLCBjYW52YXNSZWZdKTtcblxuICAvLyBBZGQgZGVidWdnaW5nIGluZm8gdG8gY29uc29sZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdDYW52YXMgdG9vbCBjaGFuZ2VkIG9yIGlzRHJhd2luZyBjaGFuZ2VkOicsIHsgY3VycmVudFRvb2wsIGlzRHJhd2luZyB9KTtcbiAgfSwgW2N1cnJlbnRUb29sLCBpc0RyYXdpbmddKTtcblxuICAvLyBSZWRyYXcgYmV6aWVyIGd1aWRlcyBhbmQgY29udHJvbCBwb2ludHMgd2hlbiB0ZW1wUG9pbnRzIGNoYW5nZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChjdXJyZW50VG9vbCA9PT0gJ3BlbicgJiYgdGVtcFBvaW50cy5sZW5ndGggPiAwICYmIHNob3dCZXppZXJHdWlkZXMpIHtcbiAgICAgIHJlZHJhd0Jlemllckd1aWRlcygpO1xuICAgIH1cbiAgfSwgW3RlbXBQb2ludHMsIHNob3dCZXppZXJHdWlkZXMsIGN1cnJlbnRUb29sXSk7XG5cbiAgLy8gQWRkIHVzZUVmZmVjdCB0byBjaGVjayBpZiBjYW52YXMgaGFzIGNvbnRlbnRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGNvbnN0IGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBcbiAgICAvLyBDaGVjayBpZiBjYW52YXMgaGFzIGFueSBub24td2hpdGUgcGl4ZWxzIChpLmUuLCBoYXMgYSBkcmF3aW5nKVxuICAgIGNvbnN0IGhhc05vbldoaXRlUGl4ZWxzID0gQXJyYXkuZnJvbShpbWFnZURhdGEuZGF0YSkuc29tZSgocGl4ZWwsIGluZGV4KSA9PiB7XG4gICAgICAvLyBDaGVjayBvbmx5IFJHQiB2YWx1ZXMgKHNraXAgYWxwaGEpXG4gICAgICByZXR1cm4gaW5kZXggJSA0ICE9PSAzICYmIHBpeGVsICE9PSAyNTU7XG4gICAgfSk7XG4gICAgXG4gICAgc2V0SGFzRHJhd2luZyhoYXNOb25XaGl0ZVBpeGVscyk7XG4gIH0sIFtpc0RyYXdpbmcsIGNhbnZhc1JlZl0pO1xuXG4gIGNvbnN0IGhhbmRsZUtleURvd24gPSAoZSkgPT4ge1xuICAgIC8vIEFkZCBrZXlib2FyZCBhY2Nlc3NpYmlsaXR5XG4gICAgaWYgKGUua2V5ID09PSAnRW50ZXInIHx8IGUua2V5ID09PSAnICcpIHtcbiAgICAgIGhhbmRsZUNhbnZhc0NsaWNrKGUpO1xuICAgIH1cbiAgICBcbiAgICAvLyBUb2dnbGUgc3ltbWV0cmljIGhhbmRsZXMgd2l0aCBTaGlmdCBrZXlcbiAgICBpZiAoZS5rZXkgPT09ICdTaGlmdCcpIHtcbiAgICAgIHNldFN5bW1ldHJpYyghc3ltbWV0cmljKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRHJhdyBiZXppZXIgY29udHJvbCBwb2ludHMgYW5kIGd1aWRlIGxpbmVzXG4gIGNvbnN0IHJlZHJhd0Jlemllckd1aWRlcyA9ICgpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuO1xuICAgIFxuICAgIC8vIEdldCB0aGUgY2FudmFzIGNvbnRleHRcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBcbiAgICAvLyBTYXZlIHRoZSBjdXJyZW50IGNhbnZhcyBzdGF0ZSB0byByZWRyYXcgbGF0ZXJcbiAgICBjb25zdCBjYW52YXNJbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgIGNhbnZhc0ltYWdlLnNyYyA9IGNhbnZhcy50b0RhdGFVUkwoKTtcbiAgICBcbiAgICBjYW52YXNJbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAvLyBDbGVhciBjYW52YXNcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgIFxuICAgICAgLy8gUmVkcmF3IHRoZSBjYW52YXMgY29udGVudFxuICAgICAgY3R4LmRyYXdJbWFnZShjYW52YXNJbWFnZSwgMCwgMCk7XG4gICAgICBcbiAgICAgIC8vIERyYXcgdGhlIGNvbnRyb2wgcG9pbnRzIGFuZCBndWlkZSBsaW5lc1xuICAgICAgZHJhd0Jlemllckd1aWRlcyhjdHgsIHRlbXBQb2ludHMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQ3VzdG9tIGhhbmRsZXIgZm9yIHN0b3BwaW5nIGRyYXdpbmcgd2l0aCBwZW4gdG9vbFxuICBjb25zdCBoYW5kbGVTdG9wRHJhd2luZyA9IChlKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ2hhbmRsZVN0b3BEcmF3aW5nIGNhbGxlZCcsIHsgXG4gICAgICBldmVudFR5cGU6IGU/LnR5cGUsIFxuICAgICAgY3VycmVudFRvb2wsIFxuICAgICAgaXNEcmF3aW5nLCBcbiAgICAgIGFjdGl2ZVBvaW50LCBcbiAgICAgIGFjdGl2ZUhhbmRsZVxuICAgIH0pO1xuICAgIFxuICAgIC8vIElmIHdlJ3JlIHVzaW5nIHRoZSBwZW4gdG9vbCB3aXRoIGFjdGl2ZSBwb2ludCBvciBoYW5kbGVcbiAgICBpZiAoY3VycmVudFRvb2wgPT09ICdwZW4nKSB7XG4gICAgICAvLyBJZiB3ZSB3ZXJlIGRyYWdnaW5nIGEgaGFuZGxlLCBqdXN0IHJlbGVhc2UgaXRcbiAgICAgIGlmIChhY3RpdmVIYW5kbGUpIHtcbiAgICAgICAgc2V0QWN0aXZlSGFuZGxlKG51bGwpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIElmIHdlIHdlcmUgZHJhZ2dpbmcgYW4gYW5jaG9yIHBvaW50LCBqdXN0IHJlbGVhc2UgaXRcbiAgICAgIGlmIChhY3RpdmVQb2ludCAhPT0gLTEpIHtcbiAgICAgICAgc2V0QWN0aXZlUG9pbnQoLTEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHN0b3BEcmF3aW5nKGUpO1xuICAgIFxuICAgIC8vIElmIHVzaW5nIHRoZSBwZW5jaWwgdG9vbCBhbmQgd2UndmUganVzdCBmaW5pc2hlZCBhIGRyYWcsIHRyaWdnZXIgZ2VuZXJhdGlvblxuICAgIGlmIChjdXJyZW50VG9vbCA9PT0gJ3BlbmNpbCcgJiYgaXNEcmF3aW5nKSB7XG4gICAgICBjb25zb2xlLmxvZyhgJHtjdXJyZW50VG9vbH0gdG9vbCBjb25kaXRpb24gbWV0LCB3aWxsIHRyeSB0byB0cmlnZ2VyIGdlbmVyYXRpb25gKTtcbiAgICAgIFxuICAgICAgLy8gU21hbGwgZGVsYXkgdG8gZW5zdXJlIHRoZSBkcmF3aW5nIGlzIGNvbXBsZXRlXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ0F0dGVtcHRpbmcgdG8gY2FsbCBoYW5kbGVHZW5lcmF0aW9uIGFmdGVyIHRpbWVvdXQnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVHZW5lcmF0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ0NhbGxpbmcgaGFuZGxlR2VuZXJhdGlvbiBmdW5jdGlvbicpO1xuICAgICAgICAgIGhhbmRsZUdlbmVyYXRpb24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdoYW5kbGVHZW5lcmF0aW9uIGlzIG5vdCBhIGZ1bmN0aW9uOicsIGhhbmRsZUdlbmVyYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9LCAxMDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZygnR2VuZXJhdGlvbiBub3QgdHJpZ2dlcmVkIGJlY2F1c2U6JywgeyBcbiAgICAgICAgaXNQZW5Ub29sOiBjdXJyZW50VG9vbCA9PT0gJ3BlbicsXG4gICAgICAgIGlzUGVuY2lsVG9vbDogY3VycmVudFRvb2wgPT09ICdwZW5jaWwnLFxuICAgICAgICB3YXNEcmF3aW5nOiBpc0RyYXdpbmcgXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQ2hlY2sgaWYgd2UgY2xpY2tlZCBvbiBhbiBleGlzdGluZyBwb2ludCBvciBoYW5kbGVcbiAgY29uc3QgY2hlY2tGb3JQb2ludE9ySGFuZGxlID0gKGUpID0+IHtcbiAgICBpZiAoY3VycmVudFRvb2wgIT09ICdwZW4nIHx8ICFzaG93QmV6aWVyR3VpZGVzIHx8IHRlbXBQb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0Q29vcmRpbmF0ZXMoZSwgY2FudmFzKTtcbiAgICBzZXRMYXN0TW91c2VQb3MoeyB4LCB5IH0pO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIHdlIGNsaWNrZWQgb24gYSBoYW5kbGVcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRlbXBQb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gdGVtcFBvaW50c1tpXTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIGhhbmRsZUluXG4gICAgICBpZiAoaXNOZWFySGFuZGxlKHBvaW50LCAnaGFuZGxlSW4nLCB4LCB5KSkge1xuICAgICAgICBzZXRBY3RpdmVQb2ludChpKTtcbiAgICAgICAgc2V0QWN0aXZlSGFuZGxlKCdoYW5kbGVJbicpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIGhhbmRsZU91dFxuICAgICAgaWYgKGlzTmVhckhhbmRsZShwb2ludCwgJ2hhbmRsZU91dCcsIHgsIHkpKSB7XG4gICAgICAgIHNldEFjdGl2ZVBvaW50KGkpO1xuICAgICAgICBzZXRBY3RpdmVIYW5kbGUoJ2hhbmRsZU91dCcpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIHRoZSBhbmNob3IgcG9pbnQgaXRzZWxmXG4gICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydCgocG9pbnQueCAtIHgpICoqIDIgKyAocG9pbnQueSAtIHkpICoqIDIpO1xuICAgICAgaWYgKGRpc3RhbmNlIDw9IDEwKSB7XG4gICAgICAgIHNldEFjdGl2ZVBvaW50KGkpO1xuICAgICAgICBzZXRBY3RpdmVIYW5kbGUobnVsbCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIFxuICAvLyBIYW5kbGUgbW91c2UgbW92ZSBmb3IgYmV6aWVyIGNvbnRyb2wgcG9pbnQgb3IgaGFuZGxlIGRyYWdnaW5nXG4gIGNvbnN0IGhhbmRsZUJlemllck1vdXNlTW92ZSA9IChlKSA9PiB7XG4gICAgaWYgKGN1cnJlbnRUb29sICE9PSAncGVuJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGdldENvb3JkaW5hdGVzKGUsIGNhbnZhcyk7XG4gICAgY29uc3QgZHggPSB4IC0gbGFzdE1vdXNlUG9zLng7XG4gICAgY29uc3QgZHkgPSB5IC0gbGFzdE1vdXNlUG9zLnk7XG4gICAgXG4gICAgLy8gSWYgd2UncmUgZHJhZ2dpbmcgYSBoYW5kbGVcbiAgICBpZiAoYWN0aXZlUG9pbnQgIT09IC0xICYmIGFjdGl2ZUhhbmRsZSkge1xuICAgICAgY29uc3QgbmV3UG9pbnRzID0gWy4uLnRlbXBQb2ludHNdO1xuICAgICAgdXBkYXRlSGFuZGxlKG5ld1BvaW50c1thY3RpdmVQb2ludF0sIGFjdGl2ZUhhbmRsZSwgZHgsIGR5LCBzeW1tZXRyaWMpO1xuICAgICAgc2V0VGVtcFBvaW50cyhuZXdQb2ludHMpO1xuICAgICAgc2V0TGFzdE1vdXNlUG9zKHsgeCwgeSB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICAvLyBJZiB3ZSdyZSBkcmFnZ2luZyBhbiBhbmNob3IgcG9pbnRcbiAgICBpZiAoYWN0aXZlUG9pbnQgIT09IC0xKSB7XG4gICAgICBjb25zdCBuZXdQb2ludHMgPSBbLi4udGVtcFBvaW50c107XG4gICAgICBuZXdQb2ludHNbYWN0aXZlUG9pbnRdLnggKz0gZHg7XG4gICAgICBuZXdQb2ludHNbYWN0aXZlUG9pbnRdLnkgKz0gZHk7XG4gICAgICBcbiAgICAgIC8vIElmIHRoaXMgcG9pbnQgaGFzIGhhbmRsZXMsIG1vdmUgdGhlbSB3aXRoIHRoZSBwb2ludFxuICAgICAgaWYgKG5ld1BvaW50c1thY3RpdmVQb2ludF0uaGFuZGxlSW4pIHtcbiAgICAgICAgLy8gTm8gbmVlZCB0byBjaGFuZ2UgdGhlIGhhbmRsZSdzIG9mZnNldCwganVzdCBtb3ZlIHdpdGggdGhlIHBvaW50XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChuZXdQb2ludHNbYWN0aXZlUG9pbnRdLmhhbmRsZU91dCkge1xuICAgICAgICAvLyBObyBuZWVkIHRvIGNoYW5nZSB0aGUgaGFuZGxlJ3Mgb2Zmc2V0LCBqdXN0IG1vdmUgd2l0aCB0aGUgcG9pbnRcbiAgICAgIH1cbiAgICAgIFxuICAgICAgc2V0VGVtcFBvaW50cyhuZXdQb2ludHMpO1xuICAgICAgc2V0TGFzdE1vdXNlUG9zKHsgeCwgeSB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLy8gSGFuZGxlIGNsaWNrcyBmb3IgYmV6aWVyIGN1cnZlIHRvb2xcbiAgY29uc3QgaGFuZGxlUGVuVG9vbENsaWNrID0gKGUpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGdldENvb3JkaW5hdGVzKGUsIGNhbnZhcyk7XG4gICAgXG4gICAgLy8gQWRkIGEgbmV3IHBvaW50XG4gICAgaWYgKHRlbXBQb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBGaXJzdCBwb2ludCBoYXMgbm8gaGFuZGxlcyBpbml0aWFsbHlcbiAgICAgIGNvbnN0IG5ld1BvaW50ID0geyB4LCB5LCBoYW5kbGVJbjogbnVsbCwgaGFuZGxlT3V0OiBudWxsIH07XG4gICAgICBzZXRUZW1wUG9pbnRzKFtuZXdQb2ludF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDcmVhdGUgYSBuZXcgcG9pbnQgd2l0aCBoYW5kbGVzIHJlbGF0aXZlIHRvIHRoZSBsYXN0IHBvaW50XG4gICAgICBjb25zdCBuZXdQb2ludCA9IGNyZWF0ZUFuY2hvclBvaW50KHgsIHksIHRlbXBQb2ludHNbdGVtcFBvaW50cy5sZW5ndGggLSAxXSk7XG4gICAgICBzZXRUZW1wUG9pbnRzKFsuLi50ZW1wUG9pbnRzLCBuZXdQb2ludF0pO1xuICAgIH1cbiAgICBcbiAgICAvLyBBbHdheXMgc2hvdyBndWlkZXMgd2hlbiBhZGRpbmcgcG9pbnRzXG4gICAgc2V0U2hvd0Jlemllckd1aWRlcyh0cnVlKTtcbiAgfTtcbiAgXG4gIC8vIFRvZ2dsZSBiZXppZXIgZ3VpZGUgdmlzaWJpbGl0eVxuICBjb25zdCB0b2dnbGVCZXppZXJHdWlkZXMgPSAoKSA9PiB7XG4gICAgc2V0U2hvd0Jlemllckd1aWRlcyghc2hvd0Jlemllckd1aWRlcyk7XG4gICAgaWYgKHNob3dCZXppZXJHdWlkZXMpIHtcbiAgICAgIHJlZHJhd0Jlemllckd1aWRlcygpO1xuICAgIH1cbiAgfTtcblxuICAvLyBEcmF3IHRoZSBmaW5hbCBiZXppZXIgY3VydmUgYW5kIGNsZWFyIGNvbnRyb2wgcG9pbnRzXG4gIGNvbnN0IGZpbmFsaXplQmV6aWVyQ3VydmUgPSAoKSA9PiB7XG4gICAgaWYgKHRlbXBQb2ludHMubGVuZ3RoIDwgMikge1xuICAgICAgLy8gTmVlZCBhdCBsZWFzdCAyIHBvaW50cyBmb3IgYSBwYXRoXG4gICAgICBjb25zb2xlLmxvZygnTmVlZCBhdCBsZWFzdCAyIGNvbnRyb2wgcG9pbnRzIHRvIGRyYXcgYSBwYXRoJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgIFxuICAgIC8vIERyYXcgdGhlIGFjdHVhbCBiZXppZXIgY3VydmVcbiAgICBkcmF3QmV6aWVyQ3VydmUoY2FudmFzLCB0ZW1wUG9pbnRzKTtcbiAgICBcbiAgICAvLyBIaWRlIGd1aWRlcyBhbmQgcmVzZXQgY29udHJvbCBwb2ludHNcbiAgICBzZXRTaG93QmV6aWVyR3VpZGVzKGZhbHNlKTtcbiAgICBzZXRUZW1wUG9pbnRzKFtdKTtcbiAgICBcbiAgICAvLyBUcmlnZ2VyIGdlbmVyYXRpb25cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlR2VuZXJhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBoYW5kbGVHZW5lcmF0aW9uKCk7XG4gICAgICB9XG4gICAgfSwgMTAwKTtcbiAgfTtcblxuICAvLyBBZGQgY29udHJvbCBwb2ludCB0byBzZWdtZW50XG4gIGNvbnN0IGFkZENvbnRyb2xQb2ludCA9IChlKSA9PiB7XG4gICAgaWYgKGN1cnJlbnRUb29sICE9PSAncGVuJyB8fCB0ZW1wUG9pbnRzLmxlbmd0aCA8IDIpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGdldENvb3JkaW5hdGVzKGUsIGNhbnZhcyk7XG4gICAgXG4gICAgLy8gRmluZCB0aGUgY2xvc2VzdCBzZWdtZW50IHRvIGFkZCBhIHBvaW50IHRvXG4gICAgbGV0IGNsb3Nlc3REaXN0YW5jZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgaW5zZXJ0SW5kZXggPSAtMTtcbiAgICBcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRlbXBQb2ludHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICBjb25zdCBwMSA9IHRlbXBQb2ludHNbaV07XG4gICAgICBjb25zdCBwMiA9IHRlbXBQb2ludHNbaSArIDFdO1xuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgZGlzdGFuY2UgZnJvbSBjbGljayB0byBsaW5lIGJldHdlZW4gcG9pbnRzXG4gICAgICAvLyBUaGlzIGlzIGEgc2ltcGxpZmllZCBkaXN0YW5jZSBjYWxjdWxhdGlvbiBmb3IgZGVtbyBwdXJwb3Nlc1xuICAgICAgY29uc3QgbGluZUxlbmd0aCA9IE1hdGguc3FydCgocDIueCAtIHAxLngpICoqIDIgKyAocDIueSAtIHAxLnkpICoqIDIpO1xuICAgICAgaWYgKGxpbmVMZW5ndGggPT09IDApIGNvbnRpbnVlO1xuICAgICAgXG4gICAgICAvLyBQcm9qZWN0IHBvaW50IG9udG8gbGluZVxuICAgICAgY29uc3QgdCA9ICgoeCAtIHAxLngpICogKHAyLnggLSBwMS54KSArICh5IC0gcDEueSkgKiAocDIueSAtIHAxLnkpKSAvIChsaW5lTGVuZ3RoICogbGluZUxlbmd0aCk7XG4gICAgICBcbiAgICAgIC8vIElmIHByb2plY3Rpb24gaXMgb3V0c2lkZSB0aGUgbGluZSBzZWdtZW50LCBza2lwXG4gICAgICBpZiAodCA8IDAgfHwgdCA+IDEpIGNvbnRpbnVlO1xuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgY2xvc2VzdCBwb2ludCBvbiBsaW5lXG4gICAgICBjb25zdCBjbG9zZXN0WCA9IHAxLnggKyB0ICogKHAyLnggLSBwMS54KTtcbiAgICAgIGNvbnN0IGNsb3Nlc3RZID0gcDEueSArIHQgKiAocDIueSAtIHAxLnkpO1xuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgZGlzdGFuY2UgdG8gY2xvc2VzdCBwb2ludFxuICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoKHggLSBjbG9zZXN0WCkgKiogMiArICh5IC0gY2xvc2VzdFkpICoqIDIpO1xuICAgICAgXG4gICAgICBpZiAoZGlzdGFuY2UgPCBjbG9zZXN0RGlzdGFuY2UgJiYgZGlzdGFuY2UgPCAyMCkge1xuICAgICAgICBjbG9zZXN0RGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgICAgaW5zZXJ0SW5kZXggPSBpICsgMTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYgKGluc2VydEluZGV4ID4gMCkge1xuICAgICAgLy8gQ3JlYXRlIGEgbmV3IGFycmF5IHdpdGggdGhlIG5ldyBwb2ludCBpbnNlcnRlZFxuICAgICAgY29uc3QgbmV3UG9pbnRzID0gWy4uLnRlbXBQb2ludHNdO1xuICAgICAgY29uc3QgcHJldlBvaW50ID0gbmV3UG9pbnRzW2luc2VydEluZGV4IC0gMV07XG4gICAgICBjb25zdCBuZXh0UG9pbnQgPSBuZXdQb2ludHNbaW5zZXJ0SW5kZXhdO1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgYSBuZXcgcG9pbnQgYXQgdGhlIGNsaWNrIHBvc2l0aW9uIHdpdGggYXV0b21hdGljYWxseSBjYWxjdWxhdGVkIGhhbmRsZXNcbiAgICAgIGNvbnN0IG5ld1BvaW50ID0geyBcbiAgICAgICAgeCwgXG4gICAgICAgIHksXG4gICAgICAgIC8vIENhbGN1bGF0ZSBoYW5kbGVzIGJhc2VkIG9uIHRoZSBwb3NpdGlvbnMgb2YgYWRqYWNlbnQgcG9pbnRzXG4gICAgICAgIGhhbmRsZUluOiB7IFxuICAgICAgICAgIHg6IChwcmV2UG9pbnQueCAtIHgpICogMC4yNSwgXG4gICAgICAgICAgeTogKHByZXZQb2ludC55IC0geSkgKiAwLjI1IFxuICAgICAgICB9LFxuICAgICAgICBoYW5kbGVPdXQ6IHsgXG4gICAgICAgICAgeDogKG5leHRQb2ludC54IC0geCkgKiAwLjI1LCBcbiAgICAgICAgICB5OiAobmV4dFBvaW50LnkgLSB5KSAqIDAuMjUgXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIEluc2VydCB0aGUgbmV3IHBvaW50XG4gICAgICBuZXdQb2ludHMuc3BsaWNlKGluc2VydEluZGV4LCAwLCBuZXdQb2ludCk7XG4gICAgICBzZXRUZW1wUG9pbnRzKG5ld1BvaW50cyk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFdyYXAgdGhlIG9yaWdpbmFsIHN0YXJ0RHJhd2luZyBmdW5jdGlvbiB0byBoYW5kbGUgZW1wdHkgY2FudmFzXG4gIGNvbnN0IGhhbmRsZVN0YXJ0RHJhd2luZyA9IChlKSA9PiB7XG4gICAgLy8gQ2FsbCB0aGUgb3JpZ2luYWwgc3RhcnREcmF3aW5nIGZ1bmN0aW9uXG4gICAgc3RhcnREcmF3aW5nKGUpO1xuICAgIHNldEhhc0RyYXdpbmcodHJ1ZSk7XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInJlbGF0aXZlXCI+XG4gICAgICB7Y3VycmVudFRvb2wgPT09ICdwZW4nICYmIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtd3JhcCBtYi0yIGdhcC0yXCI+XG4gICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBvbkNsaWNrPXt0b2dnbGVCZXppZXJHdWlkZXN9XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJweC0yIHB5LTEgYmctYmx1ZS01MDAgdGV4dC13aGl0ZSByb3VuZGVkIHRleHQtc21cIlxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtzaG93QmV6aWVyR3VpZGVzID8gJ0hpZGUgR3VpZGVzJyA6ICdTaG93IEd1aWRlcyd9XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgXG4gICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRTeW1tZXRyaWMoIXN5bW1ldHJpYyl9XG4gICAgICAgICAgICBjbGFzc05hbWU9e2BweC0yIHB5LTEgJHtzeW1tZXRyaWMgPyAnYmctZ3JlZW4tNTAwJyA6ICdiZy1ncmF5LTUwMCd9IHRleHQtd2hpdGUgcm91bmRlZCB0ZXh0LXNtYH1cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7c3ltbWV0cmljID8gJ1N5bW1ldHJpYyBIYW5kbGVzJyA6ICdGcmVlIEhhbmRsZXMnfVxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgIFxuICAgICAgICAgIHt0ZW1wUG9pbnRzLmxlbmd0aCA+PSAyICYmIChcbiAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgIG9uQ2xpY2s9e2ZpbmFsaXplQmV6aWVyQ3VydmV9XG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cInB4LTIgcHktMSBiZy1ncmVlbi01MDAgdGV4dC13aGl0ZSByb3VuZGVkIHRleHQtc21cIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICBEcmF3IFBhdGhcbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICl9XG4gICAgICAgICAgXG4gICAgICAgICAge3RlbXBQb2ludHMubGVuZ3RoID4gMCAmJiAoXG4gICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRUZW1wUG9pbnRzKFtdKX1cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwicHgtMiBweS0xIGJnLXJlZC01MDAgdGV4dC13aGl0ZSByb3VuZGVkIHRleHQtc21cIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICBDbGVhciBQb2ludHNcbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICl9XG4gICAgICAgICAgXG4gICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC1zbSBtbC0yXCI+XG4gICAgICAgICAgICB7dGVtcFBvaW50cy5sZW5ndGh9IHBvaW50e3RlbXBQb2ludHMubGVuZ3RoICE9PSAxID8gJ3MnIDogJyd9IFxuICAgICAgICAgICAge3RlbXBQb2ludHMubGVuZ3RoID49IDIgPyAnIChyZWFkeSknIDogJyAobmVlZCAyKyknfVxuICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICBcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCB0ZXh0LXhzIHRleHQtZ3JheS02MDAgbXQtMVwiPlxuICAgICAgICAgICAgVGlwOiBDbGljayB0byBhZGQgcG9pbnRzLCBjbGljayArIGRyYWcgaGFuZGxlcyB0byBhZGp1c3QgY3VydmVzLCBkb3VibGUtY2xpY2sgb24gc2VnbWVudHMgdG8gYWRkIHBvaW50c1xuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG4gICAgICBcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwicmVsYXRpdmVcIj5cbiAgICAgICAgPGNhbnZhc1xuICAgICAgICAgIHJlZj17Y2FudmFzUmVmfVxuICAgICAgICAgIHdpZHRoPXs5NjB9XG4gICAgICAgICAgaGVpZ2h0PXs1NDB9XG4gICAgICAgICAgb25Nb3VzZURvd249eyhlKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQ2FudmFzIG9uTW91c2VEb3duJywgeyBjdXJyZW50VG9vbCwgaXNEcmF3aW5nIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBGb3IgcGVuIChiZXppZXIpIHRvb2wsIGhhbmRsZSBkaWZmZXJlbnRseVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRUb29sID09PSAncGVuJykge1xuICAgICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBjbGlja2VkIG9uIGFuIGV4aXN0aW5nIHBvaW50IG9yIGhhbmRsZVxuICAgICAgICAgICAgICBpZiAoIWNoZWNrRm9yUG9pbnRPckhhbmRsZShlKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIG5vdCBpbnRlcmFjdGluZyB3aXRoIGV4aXN0aW5nIHBvaW50cy9oYW5kbGVzLCBhZGQgYSBuZXcgcG9pbnRcbiAgICAgICAgICAgICAgICBoYW5kbGVQZW5Ub29sQ2xpY2soZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEZvciBvdGhlciB0b29scywgdXNlIHRoZSByZWd1bGFyIGRyYXdpbmcgYmVoYXZpb3JcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0V4ZWN1dGluZyByZWd1bGFyIHN0YXJ0RHJhd2luZyBoYW5kbGVyJyk7XG4gICAgICAgICAgICAgIGhhbmRsZVN0YXJ0RHJhd2luZyhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9fVxuICAgICAgICAgIG9uTW91c2VNb3ZlPXsoZSkgPT4ge1xuICAgICAgICAgICAgLy8gRm9yIHBlbiAoYmV6aWVyKSB0b29sLCBoYW5kbGUgY29udHJvbCBwb2ludC9oYW5kbGUgZHJhZ2dpbmdcbiAgICAgICAgICAgIGlmIChjdXJyZW50VG9vbCA9PT0gJ3BlbicgJiYgaGFuZGxlQmV6aWVyTW91c2VNb3ZlKGUpKSB7XG4gICAgICAgICAgICAgIC8vIElmIHdlIGhhbmRsZWQgYSBiZXppZXIgZWxlbWVudCBtb3ZlLCByZXR1cm4gZWFybHlcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBGb3Igb3RoZXIgdG9vbHMsIHVzZSByZWd1bGFyIGRyYXdpbmdcbiAgICAgICAgICAgIGRyYXcoZSk7XG4gICAgICAgICAgfX1cbiAgICAgICAgICBvbk1vdXNlVXA9eyhlKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnb25Nb3VzZVVwIGV2ZW50IHRyaWdnZXJlZCcsIHsgY3VycmVudFRvb2wsIGlzRHJhd2luZyB9KTtcbiAgICAgICAgICAgIGhhbmRsZVN0b3BEcmF3aW5nKGUpO1xuICAgICAgICAgIH19XG4gICAgICAgICAgb25Nb3VzZUxlYXZlPXsoZSkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ29uTW91c2VMZWF2ZSBldmVudCB0cmlnZ2VyZWQnLCB7IGN1cnJlbnRUb29sLCBpc0RyYXdpbmcgfSk7XG4gICAgICAgICAgICBoYW5kbGVTdG9wRHJhd2luZyhlKTtcbiAgICAgICAgICB9fVxuICAgICAgICAgIG9uRG91YmxlQ2xpY2s9eyhlKSA9PiB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFRvb2wgPT09ICdwZW4nKSB7XG4gICAgICAgICAgICAgIGFkZENvbnRyb2xQb2ludChlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGhhbmRsZUNhbnZhc0NsaWNrKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH19XG4gICAgICAgICAgb25DbGljaz17aGFuZGxlQ2FudmFzQ2xpY2t9XG4gICAgICAgICAgb25Ub3VjaFN0YXJ0PXtoYW5kbGVTdGFydERyYXdpbmd9XG4gICAgICAgICAgb25Ub3VjaE1vdmU9e2RyYXd9XG4gICAgICAgICAgb25Ub3VjaEVuZD17aGFuZGxlU3RvcERyYXdpbmd9XG4gICAgICAgICAgb25LZXlEb3duPXtoYW5kbGVLZXlEb3dufVxuICAgICAgICAgIHRhYkluZGV4PXswfVxuICAgICAgICAgIGNsYXNzTmFtZT17YGJvcmRlci0yIGJvcmRlci1ibGFjayB3LWZ1bGwgc206aC1bNjB2aF0gaC1bMzB2aF0gbWluLWgtWzMyMHB4XSBiZy13aGl0ZS85MCB0b3VjaC1ub25lICR7XG4gICAgICAgICAgICBjdXJyZW50VG9vbCA9PT0gJ3BlbicgPyAnY3Vyc29yLWNyb3NzaGFpcicgOiAnaG92ZXI6Y3Vyc29yLWNyb3NzaGFpcidcbiAgICAgICAgICB9YH1cbiAgICAgICAgICBhcmlhLWxhYmVsPVwiRHJhd2luZyBjYW52YXNcIlxuICAgICAgICAvPlxuICAgICAgICBcbiAgICAgICAgey8qIFBsYWNlaG9sZGVyIG92ZXJsYXkgKi99XG4gICAgICAgIHshaGFzRHJhd2luZyAmJiAhaXNEcmF3aW5nICYmIChcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFic29sdXRlIGluc2V0LTAgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgcG9pbnRlci1ldmVudHMtbm9uZVwiPlxuICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1ncmF5LTQwMCB0ZXh0LXhsIGZvbnQtbWVkaXVtXCI+RHJhdyBoZXJlPC9wPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApfVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBDYW52YXM7ICJdLCJuYW1lcyI6WyJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsImdldENvb3JkaW5hdGVzIiwiZHJhd0JlemllckN1cnZlIiwiZHJhd0Jlemllckd1aWRlcyIsImNyZWF0ZUFuY2hvclBvaW50IiwiaXNOZWFySGFuZGxlIiwidXBkYXRlSGFuZGxlIiwiQ2FudmFzIiwiY2FudmFzUmVmIiwiY3VycmVudFRvb2wiLCJpc0RyYXdpbmciLCJzdGFydERyYXdpbmciLCJkcmF3Iiwic3RvcERyYXdpbmciLCJoYW5kbGVDYW52YXNDbGljayIsImhhbmRsZVBlbkNsaWNrIiwiaGFuZGxlR2VuZXJhdGlvbiIsInRlbXBQb2ludHMiLCJzZXRUZW1wUG9pbnRzIiwic2hvd0Jlemllckd1aWRlcyIsInNldFNob3dCZXppZXJHdWlkZXMiLCJhY3RpdmVQb2ludCIsInNldEFjdGl2ZVBvaW50IiwiYWN0aXZlSGFuZGxlIiwic2V0QWN0aXZlSGFuZGxlIiwic3ltbWV0cmljIiwic2V0U3ltbWV0cmljIiwibGFzdE1vdXNlUG9zIiwic2V0TGFzdE1vdXNlUG9zIiwieCIsInkiLCJoYXNEcmF3aW5nIiwic2V0SGFzRHJhd2luZyIsInN0cm9rZUNvdW50Iiwic2V0U3Ryb2tlQ291bnQiLCJwcmV2ZW50VG91Y2hEZWZhdWx0IiwiZSIsInByZXZlbnREZWZhdWx0IiwiY2FudmFzIiwiY3VycmVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJwYXNzaXZlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNvbnNvbGUiLCJsb2ciLCJsZW5ndGgiLCJyZWRyYXdCZXppZXJHdWlkZXMiLCJjdHgiLCJnZXRDb250ZXh0IiwiaW1hZ2VEYXRhIiwiZ2V0SW1hZ2VEYXRhIiwid2lkdGgiLCJoZWlnaHQiLCJoYXNOb25XaGl0ZVBpeGVscyIsIkFycmF5IiwiZnJvbSIsImRhdGEiLCJzb21lIiwicGl4ZWwiLCJpbmRleCIsImhhbmRsZUtleURvd24iLCJrZXkiLCJjYW52YXNJbWFnZSIsIkltYWdlIiwic3JjIiwidG9EYXRhVVJMIiwib25sb2FkIiwiY2xlYXJSZWN0IiwiZHJhd0ltYWdlIiwiaGFuZGxlU3RvcERyYXdpbmciLCJldmVudFR5cGUiLCJ0eXBlIiwic2V0VGltZW91dCIsImVycm9yIiwiaXNQZW5Ub29sIiwiaXNQZW5jaWxUb29sIiwid2FzRHJhd2luZyIsImNoZWNrRm9yUG9pbnRPckhhbmRsZSIsImkiLCJwb2ludCIsImRpc3RhbmNlIiwiTWF0aCIsInNxcnQiLCJoYW5kbGVCZXppZXJNb3VzZU1vdmUiLCJkeCIsImR5IiwibmV3UG9pbnRzIiwiaGFuZGxlSW4iLCJoYW5kbGVPdXQiLCJoYW5kbGVQZW5Ub29sQ2xpY2siLCJuZXdQb2ludCIsInRvZ2dsZUJlemllckd1aWRlcyIsImZpbmFsaXplQmV6aWVyQ3VydmUiLCJhZGRDb250cm9sUG9pbnQiLCJjbG9zZXN0RGlzdGFuY2UiLCJOdW1iZXIiLCJQT1NJVElWRV9JTkZJTklUWSIsImluc2VydEluZGV4IiwicDEiLCJwMiIsImxpbmVMZW5ndGgiLCJ0IiwiY2xvc2VzdFgiLCJjbG9zZXN0WSIsInByZXZQb2ludCIsIm5leHRQb2ludCIsInNwbGljZSIsImhhbmRsZVN0YXJ0RHJhd2luZyIsImRpdiIsImNsYXNzTmFtZSIsImJ1dHRvbiIsIm9uQ2xpY2siLCJzcGFuIiwicmVmIiwib25Nb3VzZURvd24iLCJvbk1vdXNlTW92ZSIsIm9uTW91c2VVcCIsIm9uTW91c2VMZWF2ZSIsIm9uRG91YmxlQ2xpY2siLCJvblRvdWNoU3RhcnQiLCJvblRvdWNoTW92ZSIsIm9uVG91Y2hFbmQiLCJvbktleURvd24iLCJ0YWJJbmRleCIsImFyaWEtbGFiZWwiLCJwIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/Canvas.js\n"));

/***/ })

});