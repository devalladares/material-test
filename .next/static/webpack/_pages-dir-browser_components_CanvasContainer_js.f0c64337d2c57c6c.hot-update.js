"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_components_CanvasContainer_js",{

/***/ "(pages-dir-browser)/./components/Canvas.js":
/*!******************************!*\
  !*** ./components/Canvas.js ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/canvasUtils */ \"(pages-dir-browser)/./components/utils/canvasUtils.js\");\n\nvar _s = $RefreshSig$();\n\n\nconst Canvas = (param)=>{\n    let { canvasRef, currentTool, isDrawing, startDrawing, draw, stopDrawing, handleCanvasClick, handlePenClick, handleGeneration, tempPoints, setTempPoints } = param;\n    _s();\n    const [showBezierGuides, setShowBezierGuides] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [activePoint, setActivePoint] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(-1);\n    const [activeHandle, setActiveHandle] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [symmetric, setSymmetric] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [lastMousePos, setLastMousePos] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        x: 0,\n        y: 0\n    });\n    const [hasDrawing, setHasDrawing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Add touch event prevention function\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Canvas.useEffect\": ()=>{\n            // Function to prevent default touch behavior on canvas\n            const preventTouchDefault = {\n                \"Canvas.useEffect.preventTouchDefault\": (e)=>{\n                    if (isDrawing) {\n                        e.preventDefault();\n                    }\n                }\n            }[\"Canvas.useEffect.preventTouchDefault\"];\n            // Add event listener when component mounts\n            const canvas = canvasRef.current;\n            if (canvas) {\n                canvas.addEventListener('touchstart', preventTouchDefault, {\n                    passive: false\n                });\n                canvas.addEventListener('touchmove', preventTouchDefault, {\n                    passive: false\n                });\n            }\n            // Remove event listener when component unmounts\n            return ({\n                \"Canvas.useEffect\": ()=>{\n                    if (canvas) {\n                        canvas.removeEventListener('touchstart', preventTouchDefault);\n                        canvas.removeEventListener('touchmove', preventTouchDefault);\n                    }\n                }\n            })[\"Canvas.useEffect\"];\n        }\n    }[\"Canvas.useEffect\"], [\n        isDrawing,\n        canvasRef\n    ]);\n    // Add debugging info to console\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Canvas.useEffect\": ()=>{\n            console.log('Canvas tool changed or isDrawing changed:', {\n                currentTool,\n                isDrawing\n            });\n        }\n    }[\"Canvas.useEffect\"], [\n        currentTool,\n        isDrawing\n    ]);\n    // Redraw bezier guides and control points when tempPoints change\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Canvas.useEffect\": ()=>{\n            if (currentTool === 'pen' && tempPoints.length > 0 && showBezierGuides) {\n                redrawBezierGuides();\n            }\n        }\n    }[\"Canvas.useEffect\"], [\n        tempPoints,\n        showBezierGuides,\n        currentTool\n    ]);\n    // Add useEffect to draw placeholder text on empty canvas\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Canvas.useEffect\": ()=>{\n            const canvas = canvasRef.current;\n            if (!canvas) return;\n            const ctx = canvas.getContext('2d');\n            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n            // Check if canvas has any non-white pixels (i.e., has a drawing)\n            const hasNonWhitePixels = Array.from(imageData.data).some({\n                \"Canvas.useEffect.hasNonWhitePixels\": (pixel, index)=>{\n                    // Check only RGB values (skip alpha)\n                    return index % 4 !== 3 && pixel !== 255;\n                }\n            }[\"Canvas.useEffect.hasNonWhitePixels\"]);\n            setHasDrawing(hasNonWhitePixels);\n            // If canvas is empty, draw placeholder text\n            if (!hasNonWhitePixels && !isDrawing) {\n                ctx.fillStyle = '#999999';\n                ctx.font = '20px Arial';\n                ctx.textAlign = 'center';\n                ctx.fillText('Draw here', canvas.width / 2, canvas.height / 2);\n            }\n        }\n    }[\"Canvas.useEffect\"], [\n        isDrawing,\n        canvasRef\n    ]);\n    const handleKeyDown = (e)=>{\n        // Add keyboard accessibility\n        if (e.key === 'Enter' || e.key === ' ') {\n            handleCanvasClick(e);\n        }\n        // Toggle symmetric handles with Shift key\n        if (e.key === 'Shift') {\n            setSymmetric(!symmetric);\n        }\n    };\n    // Draw bezier control points and guide lines\n    const redrawBezierGuides = ()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        // Get the canvas context\n        const ctx = canvas.getContext('2d');\n        // Save the current canvas state to redraw later\n        const canvasImage = new Image();\n        canvasImage.src = canvas.toDataURL();\n        canvasImage.onload = ()=>{\n            // Clear canvas\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            // Redraw the canvas content\n            ctx.drawImage(canvasImage, 0, 0);\n            // Draw the control points and guide lines\n            (0,_utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.drawBezierGuides)(ctx, tempPoints);\n        };\n    };\n    // Custom handler for stopping drawing with pen tool\n    const handleStopDrawing = (e)=>{\n        console.log('handleStopDrawing called', {\n            eventType: e === null || e === void 0 ? void 0 : e.type,\n            currentTool,\n            isDrawing,\n            activePoint,\n            activeHandle\n        });\n        // If we're using the pen tool with active point or handle\n        if (currentTool === 'pen') {\n            // If we were dragging a handle, just release it\n            if (activeHandle) {\n                setActiveHandle(null);\n                return;\n            }\n            // If we were dragging an anchor point, just release it\n            if (activePoint !== -1) {\n                setActivePoint(-1);\n                return;\n            }\n        }\n        stopDrawing(e);\n        // If using the pencil tool and we've just finished a drag, trigger generation\n        if (currentTool === 'pencil' && isDrawing) {\n            console.log(\"\".concat(currentTool, \" tool condition met, will try to trigger generation\"));\n            // Small delay to ensure the drawing is complete\n            setTimeout(()=>{\n                console.log('Attempting to call handleGeneration after timeout');\n                if (typeof handleGeneration === 'function') {\n                    console.log('Calling handleGeneration function');\n                    handleGeneration();\n                } else {\n                    console.error('handleGeneration is not a function:', handleGeneration);\n                }\n            }, 100);\n        } else {\n            console.log('Generation not triggered because:', {\n                isPenTool: currentTool === 'pen',\n                isPencilTool: currentTool === 'pencil',\n                wasDrawing: isDrawing\n            });\n        }\n    };\n    // Check if we clicked on an existing point or handle\n    const checkForPointOrHandle = (e)=>{\n        if (currentTool !== 'pen' || !showBezierGuides || tempPoints.length === 0) {\n            return false;\n        }\n        const canvas = canvasRef.current;\n        const { x, y } = (0,_utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.getCoordinates)(e, canvas);\n        setLastMousePos({\n            x,\n            y\n        });\n        // Check if we clicked on a handle\n        for(let i = 0; i < tempPoints.length; i++){\n            const point = tempPoints[i];\n            // Check for handleIn\n            if ((0,_utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.isNearHandle)(point, 'handleIn', x, y)) {\n                setActivePoint(i);\n                setActiveHandle('handleIn');\n                return true;\n            }\n            // Check for handleOut\n            if ((0,_utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.isNearHandle)(point, 'handleOut', x, y)) {\n                setActivePoint(i);\n                setActiveHandle('handleOut');\n                return true;\n            }\n            // Check for the anchor point itself\n            const distance = Math.sqrt((point.x - x) ** 2 + (point.y - y) ** 2);\n            if (distance <= 10) {\n                setActivePoint(i);\n                setActiveHandle(null);\n                return true;\n            }\n        }\n        return false;\n    };\n    // Handle mouse move for bezier control point or handle dragging\n    const handleBezierMouseMove = (e)=>{\n        if (currentTool !== 'pen') {\n            return false;\n        }\n        const canvas = canvasRef.current;\n        const { x, y } = (0,_utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.getCoordinates)(e, canvas);\n        const dx = x - lastMousePos.x;\n        const dy = y - lastMousePos.y;\n        // If we're dragging a handle\n        if (activePoint !== -1 && activeHandle) {\n            const newPoints = [\n                ...tempPoints\n            ];\n            (0,_utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.updateHandle)(newPoints[activePoint], activeHandle, dx, dy, symmetric);\n            setTempPoints(newPoints);\n            setLastMousePos({\n                x,\n                y\n            });\n            return true;\n        }\n        // If we're dragging an anchor point\n        if (activePoint !== -1) {\n            const newPoints = [\n                ...tempPoints\n            ];\n            newPoints[activePoint].x += dx;\n            newPoints[activePoint].y += dy;\n            // If this point has handles, move them with the point\n            if (newPoints[activePoint].handleIn) {\n            // No need to change the handle's offset, just move with the point\n            }\n            if (newPoints[activePoint].handleOut) {\n            // No need to change the handle's offset, just move with the point\n            }\n            setTempPoints(newPoints);\n            setLastMousePos({\n                x,\n                y\n            });\n            return true;\n        }\n        return false;\n    };\n    // Handle clicks for bezier curve tool\n    const handlePenToolClick = (e)=>{\n        const canvas = canvasRef.current;\n        const { x, y } = (0,_utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.getCoordinates)(e, canvas);\n        // Add a new point\n        if (tempPoints.length === 0) {\n            // First point has no handles initially\n            const newPoint = {\n                x,\n                y,\n                handleIn: null,\n                handleOut: null\n            };\n            setTempPoints([\n                newPoint\n            ]);\n        } else {\n            // Create a new point with handles relative to the last point\n            const newPoint = (0,_utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.createAnchorPoint)(x, y, tempPoints[tempPoints.length - 1]);\n            setTempPoints([\n                ...tempPoints,\n                newPoint\n            ]);\n        }\n        // Always show guides when adding points\n        setShowBezierGuides(true);\n    };\n    // Toggle bezier guide visibility\n    const toggleBezierGuides = ()=>{\n        setShowBezierGuides(!showBezierGuides);\n        if (showBezierGuides) {\n            redrawBezierGuides();\n        }\n    };\n    // Draw the final bezier curve and clear control points\n    const finalizeBezierCurve = ()=>{\n        if (tempPoints.length < 2) {\n            // Need at least 2 points for a path\n            console.log('Need at least 2 control points to draw a path');\n            return;\n        }\n        const canvas = canvasRef.current;\n        // Draw the actual bezier curve\n        (0,_utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.drawBezierCurve)(canvas, tempPoints);\n        // Hide guides and reset control points\n        setShowBezierGuides(false);\n        setTempPoints([]);\n        // Trigger generation\n        setTimeout(()=>{\n            if (typeof handleGeneration === 'function') {\n                handleGeneration();\n            }\n        }, 100);\n    };\n    // Add control point to segment\n    const addControlPoint = (e)=>{\n        if (currentTool !== 'pen' || tempPoints.length < 2) return;\n        const canvas = canvasRef.current;\n        const { x, y } = (0,_utils_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.getCoordinates)(e, canvas);\n        // Find the closest segment to add a point to\n        let closestDistance = Number.POSITIVE_INFINITY;\n        let insertIndex = -1;\n        for(let i = 0; i < tempPoints.length - 1; i++){\n            const p1 = tempPoints[i];\n            const p2 = tempPoints[i + 1];\n            // Calculate distance from click to line between points\n            // This is a simplified distance calculation for demo purposes\n            const lineLength = Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);\n            if (lineLength === 0) continue;\n            // Project point onto line\n            const t = ((x - p1.x) * (p2.x - p1.x) + (y - p1.y) * (p2.y - p1.y)) / (lineLength * lineLength);\n            // If projection is outside the line segment, skip\n            if (t < 0 || t > 1) continue;\n            // Calculate closest point on line\n            const closestX = p1.x + t * (p2.x - p1.x);\n            const closestY = p1.y + t * (p2.y - p1.y);\n            // Calculate distance to closest point\n            const distance = Math.sqrt((x - closestX) ** 2 + (y - closestY) ** 2);\n            if (distance < closestDistance && distance < 20) {\n                closestDistance = distance;\n                insertIndex = i + 1;\n            }\n        }\n        if (insertIndex > 0) {\n            // Create a new array with the new point inserted\n            const newPoints = [\n                ...tempPoints\n            ];\n            const prevPoint = newPoints[insertIndex - 1];\n            const nextPoint = newPoints[insertIndex];\n            // Create a new point at the click position with automatically calculated handles\n            const newPoint = {\n                x,\n                y,\n                // Calculate handles based on the positions of adjacent points\n                handleIn: {\n                    x: (prevPoint.x - x) * 0.25,\n                    y: (prevPoint.y - y) * 0.25\n                },\n                handleOut: {\n                    x: (nextPoint.x - x) * 0.25,\n                    y: (nextPoint.y - y) * 0.25\n                }\n            };\n            // Insert the new point\n            newPoints.splice(insertIndex, 0, newPoint);\n            setTempPoints(newPoints);\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"relative\",\n        children: [\n            currentTool === 'pen' && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex flex-wrap mb-2 gap-2\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        type: \"button\",\n                        onClick: toggleBezierGuides,\n                        className: \"px-2 py-1 bg-blue-500 text-white rounded text-sm\",\n                        children: showBezierGuides ? 'Hide Guides' : 'Show Guides'\n                    }, void 0, false, {\n                        fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                        lineNumber: 385,\n                        columnNumber: 11\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        type: \"button\",\n                        onClick: ()=>setSymmetric(!symmetric),\n                        className: \"px-2 py-1 \".concat(symmetric ? 'bg-green-500' : 'bg-gray-500', \" text-white rounded text-sm\"),\n                        children: symmetric ? 'Symmetric Handles' : 'Free Handles'\n                    }, void 0, false, {\n                        fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                        lineNumber: 393,\n                        columnNumber: 11\n                    }, undefined),\n                    tempPoints.length >= 2 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        type: \"button\",\n                        onClick: finalizeBezierCurve,\n                        className: \"px-2 py-1 bg-green-500 text-white rounded text-sm\",\n                        children: \"Draw Path\"\n                    }, void 0, false, {\n                        fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                        lineNumber: 402,\n                        columnNumber: 13\n                    }, undefined),\n                    tempPoints.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        type: \"button\",\n                        onClick: ()=>setTempPoints([]),\n                        className: \"px-2 py-1 bg-red-500 text-white rounded text-sm\",\n                        children: \"Clear Points\"\n                    }, void 0, false, {\n                        fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                        lineNumber: 412,\n                        columnNumber: 13\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"text-sm ml-2\",\n                        children: [\n                            tempPoints.length,\n                            \" point\",\n                            tempPoints.length !== 1 ? 's' : '',\n                            tempPoints.length >= 2 ? ' (ready)' : ' (need 2+)'\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                        lineNumber: 421,\n                        columnNumber: 11\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"w-full text-xs text-gray-600 mt-1\",\n                        children: \"Tip: Click to add points, click + drag handles to adjust curves, double-click on segments to add points\"\n                    }, void 0, false, {\n                        fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                        lineNumber: 426,\n                        columnNumber: 11\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                lineNumber: 384,\n                columnNumber: 9\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n                ref: canvasRef,\n                width: 960,\n                height: 540,\n                onMouseDown: (e)=>{\n                    console.log('Canvas onMouseDown', {\n                        currentTool,\n                        isDrawing\n                    });\n                    // For pen (bezier) tool, handle differently\n                    if (currentTool === 'pen') {\n                        // Check if we clicked on an existing point or handle\n                        if (!checkForPointOrHandle(e)) {\n                            // If not interacting with existing points/handles, add a new point\n                            handlePenToolClick(e);\n                        }\n                    } else {\n                        // For other tools, use the regular drawing behavior\n                        console.log('Executing regular startDrawing handler');\n                        startDrawing(e);\n                    }\n                },\n                onMouseMove: (e)=>{\n                    // For pen (bezier) tool, handle control point/handle dragging\n                    if (currentTool === 'pen' && handleBezierMouseMove(e)) {\n                        // If we handled a bezier element move, return early\n                        return;\n                    }\n                    // For other tools, use regular drawing\n                    draw(e);\n                },\n                onMouseUp: (e)=>{\n                    console.log('onMouseUp event triggered', {\n                        currentTool,\n                        isDrawing\n                    });\n                    handleStopDrawing(e);\n                },\n                onMouseLeave: (e)=>{\n                    console.log('onMouseLeave event triggered', {\n                        currentTool,\n                        isDrawing\n                    });\n                    handleStopDrawing(e);\n                },\n                onDoubleClick: (e)=>{\n                    if (currentTool === 'pen') {\n                        addControlPoint(e);\n                    } else {\n                        handleCanvasClick(e);\n                    }\n                },\n                onClick: handleCanvasClick,\n                onTouchStart: startDrawing,\n                onTouchMove: draw,\n                onTouchEnd: handleStopDrawing,\n                onKeyDown: handleKeyDown,\n                tabIndex: 0,\n                className: \"border-2 border-black w-full sm:h-[60vh] h-[30vh] min-h-[320px] bg-white/90 touch-none \".concat(currentTool === 'pen' ? 'cursor-crosshair' : 'hover:cursor-crosshair'),\n                \"aria-label\": \"Drawing canvas\"\n            }, void 0, false, {\n                fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n                lineNumber: 432,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/trudyp/Desktop/dev-gemini-2.0/components/Canvas.js\",\n        lineNumber: 382,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Canvas, \"C+J9xmlujxtWg8dJUknHevjLFt0=\");\n_c = Canvas;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Canvas);\nvar _c;\n$RefreshReg$(_c, \"Canvas\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Mi4wL2NvbXBvbmVudHMvQ2FudmFzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVJlZiwgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFxuICBnZXRDb29yZGluYXRlcywgXG4gIGRyYXdCZXppZXJDdXJ2ZSwgXG4gIGRyYXdCZXppZXJHdWlkZXMsIFxuICBjcmVhdGVBbmNob3JQb2ludCxcbiAgaXNOZWFySGFuZGxlLFxuICB1cGRhdGVIYW5kbGVcbn0gZnJvbSAnLi91dGlscy9jYW52YXNVdGlscyc7XG5cbmNvbnN0IENhbnZhcyA9ICh7XG4gIGNhbnZhc1JlZixcbiAgY3VycmVudFRvb2wsXG4gIGlzRHJhd2luZyxcbiAgc3RhcnREcmF3aW5nLFxuICBkcmF3LFxuICBzdG9wRHJhd2luZyxcbiAgaGFuZGxlQ2FudmFzQ2xpY2ssXG4gIGhhbmRsZVBlbkNsaWNrLFxuICBoYW5kbGVHZW5lcmF0aW9uLFxuICB0ZW1wUG9pbnRzLFxuICBzZXRUZW1wUG9pbnRzXG59KSA9PiB7XG4gIGNvbnN0IFtzaG93QmV6aWVyR3VpZGVzLCBzZXRTaG93QmV6aWVyR3VpZGVzXSA9IHVzZVN0YXRlKHRydWUpO1xuICBjb25zdCBbYWN0aXZlUG9pbnQsIHNldEFjdGl2ZVBvaW50XSA9IHVzZVN0YXRlKC0xKTtcbiAgY29uc3QgW2FjdGl2ZUhhbmRsZSwgc2V0QWN0aXZlSGFuZGxlXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbc3ltbWV0cmljLCBzZXRTeW1tZXRyaWNdID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtsYXN0TW91c2VQb3MsIHNldExhc3RNb3VzZVBvc10gPSB1c2VTdGF0ZSh7IHg6IDAsIHk6IDAgfSk7XG4gIGNvbnN0IFtoYXNEcmF3aW5nLCBzZXRIYXNEcmF3aW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICAvLyBBZGQgdG91Y2ggZXZlbnQgcHJldmVudGlvbiBmdW5jdGlvblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIEZ1bmN0aW9uIHRvIHByZXZlbnQgZGVmYXVsdCB0b3VjaCBiZWhhdmlvciBvbiBjYW52YXNcbiAgICBjb25zdCBwcmV2ZW50VG91Y2hEZWZhdWx0ID0gKGUpID0+IHtcbiAgICAgIGlmIChpc0RyYXdpbmcpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBBZGQgZXZlbnQgbGlzdGVuZXIgd2hlbiBjb21wb25lbnQgbW91bnRzXG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKGNhbnZhcykge1xuICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBwcmV2ZW50VG91Y2hEZWZhdWx0LCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHByZXZlbnRUb3VjaERlZmF1bHQsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGV2ZW50IGxpc3RlbmVyIHdoZW4gY29tcG9uZW50IHVubW91bnRzXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBwcmV2ZW50VG91Y2hEZWZhdWx0KTtcbiAgICAgICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHByZXZlbnRUb3VjaERlZmF1bHQpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtpc0RyYXdpbmcsIGNhbnZhc1JlZl0pO1xuXG4gIC8vIEFkZCBkZWJ1Z2dpbmcgaW5mbyB0byBjb25zb2xlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ0NhbnZhcyB0b29sIGNoYW5nZWQgb3IgaXNEcmF3aW5nIGNoYW5nZWQ6JywgeyBjdXJyZW50VG9vbCwgaXNEcmF3aW5nIH0pO1xuICB9LCBbY3VycmVudFRvb2wsIGlzRHJhd2luZ10pO1xuXG4gIC8vIFJlZHJhdyBiZXppZXIgZ3VpZGVzIGFuZCBjb250cm9sIHBvaW50cyB3aGVuIHRlbXBQb2ludHMgY2hhbmdlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGN1cnJlbnRUb29sID09PSAncGVuJyAmJiB0ZW1wUG9pbnRzLmxlbmd0aCA+IDAgJiYgc2hvd0Jlemllckd1aWRlcykge1xuICAgICAgcmVkcmF3QmV6aWVyR3VpZGVzKCk7XG4gICAgfVxuICB9LCBbdGVtcFBvaW50cywgc2hvd0Jlemllckd1aWRlcywgY3VycmVudFRvb2xdKTtcblxuICAvLyBBZGQgdXNlRWZmZWN0IHRvIGRyYXcgcGxhY2Vob2xkZXIgdGV4dCBvbiBlbXB0eSBjYW52YXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGNvbnN0IGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBcbiAgICAvLyBDaGVjayBpZiBjYW52YXMgaGFzIGFueSBub24td2hpdGUgcGl4ZWxzIChpLmUuLCBoYXMgYSBkcmF3aW5nKVxuICAgIGNvbnN0IGhhc05vbldoaXRlUGl4ZWxzID0gQXJyYXkuZnJvbShpbWFnZURhdGEuZGF0YSkuc29tZSgocGl4ZWwsIGluZGV4KSA9PiB7XG4gICAgICAvLyBDaGVjayBvbmx5IFJHQiB2YWx1ZXMgKHNraXAgYWxwaGEpXG4gICAgICByZXR1cm4gaW5kZXggJSA0ICE9PSAzICYmIHBpeGVsICE9PSAyNTU7XG4gICAgfSk7XG4gICAgXG4gICAgc2V0SGFzRHJhd2luZyhoYXNOb25XaGl0ZVBpeGVscyk7XG4gICAgXG4gICAgLy8gSWYgY2FudmFzIGlzIGVtcHR5LCBkcmF3IHBsYWNlaG9sZGVyIHRleHRcbiAgICBpZiAoIWhhc05vbldoaXRlUGl4ZWxzICYmICFpc0RyYXdpbmcpIHtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAnIzk5OTk5OSc7XG4gICAgICBjdHguZm9udCA9ICcyMHB4IEFyaWFsJztcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgIGN0eC5maWxsVGV4dCgnRHJhdyBoZXJlJywgY2FudmFzLndpZHRoIC8gMiwgY2FudmFzLmhlaWdodCAvIDIpO1xuICAgIH1cbiAgfSwgW2lzRHJhd2luZywgY2FudmFzUmVmXSk7XG5cbiAgY29uc3QgaGFuZGxlS2V5RG93biA9IChlKSA9PiB7XG4gICAgLy8gQWRkIGtleWJvYXJkIGFjY2Vzc2liaWxpdHlcbiAgICBpZiAoZS5rZXkgPT09ICdFbnRlcicgfHwgZS5rZXkgPT09ICcgJykge1xuICAgICAgaGFuZGxlQ2FudmFzQ2xpY2soZSk7XG4gICAgfVxuICAgIFxuICAgIC8vIFRvZ2dsZSBzeW1tZXRyaWMgaGFuZGxlcyB3aXRoIFNoaWZ0IGtleVxuICAgIGlmIChlLmtleSA9PT0gJ1NoaWZ0Jykge1xuICAgICAgc2V0U3ltbWV0cmljKCFzeW1tZXRyaWMpO1xuICAgIH1cbiAgfTtcblxuICAvLyBEcmF3IGJlemllciBjb250cm9sIHBvaW50cyBhbmQgZ3VpZGUgbGluZXNcbiAgY29uc3QgcmVkcmF3QmV6aWVyR3VpZGVzID0gKCkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGlmICghY2FudmFzKSByZXR1cm47XG4gICAgXG4gICAgLy8gR2V0IHRoZSBjYW52YXMgY29udGV4dFxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIFxuICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgY2FudmFzIHN0YXRlIHRvIHJlZHJhdyBsYXRlclxuICAgIGNvbnN0IGNhbnZhc0ltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgY2FudmFzSW1hZ2Uuc3JjID0gY2FudmFzLnRvRGF0YVVSTCgpO1xuICAgIFxuICAgIGNhbnZhc0ltYWdlLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIC8vIENsZWFyIGNhbnZhc1xuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgXG4gICAgICAvLyBSZWRyYXcgdGhlIGNhbnZhcyBjb250ZW50XG4gICAgICBjdHguZHJhd0ltYWdlKGNhbnZhc0ltYWdlLCAwLCAwKTtcbiAgICAgIFxuICAgICAgLy8gRHJhdyB0aGUgY29udHJvbCBwb2ludHMgYW5kIGd1aWRlIGxpbmVzXG4gICAgICBkcmF3QmV6aWVyR3VpZGVzKGN0eCwgdGVtcFBvaW50cyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBDdXN0b20gaGFuZGxlciBmb3Igc3RvcHBpbmcgZHJhd2luZyB3aXRoIHBlbiB0b29sXG4gIGNvbnN0IGhhbmRsZVN0b3BEcmF3aW5nID0gKGUpID0+IHtcbiAgICBjb25zb2xlLmxvZygnaGFuZGxlU3RvcERyYXdpbmcgY2FsbGVkJywgeyBcbiAgICAgIGV2ZW50VHlwZTogZT8udHlwZSwgXG4gICAgICBjdXJyZW50VG9vbCwgXG4gICAgICBpc0RyYXdpbmcsIFxuICAgICAgYWN0aXZlUG9pbnQsIFxuICAgICAgYWN0aXZlSGFuZGxlXG4gICAgfSk7XG4gICAgXG4gICAgLy8gSWYgd2UncmUgdXNpbmcgdGhlIHBlbiB0b29sIHdpdGggYWN0aXZlIHBvaW50IG9yIGhhbmRsZVxuICAgIGlmIChjdXJyZW50VG9vbCA9PT0gJ3BlbicpIHtcbiAgICAgIC8vIElmIHdlIHdlcmUgZHJhZ2dpbmcgYSBoYW5kbGUsIGp1c3QgcmVsZWFzZSBpdFxuICAgICAgaWYgKGFjdGl2ZUhhbmRsZSkge1xuICAgICAgICBzZXRBY3RpdmVIYW5kbGUobnVsbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSWYgd2Ugd2VyZSBkcmFnZ2luZyBhbiBhbmNob3IgcG9pbnQsIGp1c3QgcmVsZWFzZSBpdFxuICAgICAgaWYgKGFjdGl2ZVBvaW50ICE9PSAtMSkge1xuICAgICAgICBzZXRBY3RpdmVQb2ludCgtMSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgc3RvcERyYXdpbmcoZSk7XG4gICAgXG4gICAgLy8gSWYgdXNpbmcgdGhlIHBlbmNpbCB0b29sIGFuZCB3ZSd2ZSBqdXN0IGZpbmlzaGVkIGEgZHJhZywgdHJpZ2dlciBnZW5lcmF0aW9uXG4gICAgaWYgKGN1cnJlbnRUb29sID09PSAncGVuY2lsJyAmJiBpc0RyYXdpbmcpIHtcbiAgICAgIGNvbnNvbGUubG9nKGAke2N1cnJlbnRUb29sfSB0b29sIGNvbmRpdGlvbiBtZXQsIHdpbGwgdHJ5IHRvIHRyaWdnZXIgZ2VuZXJhdGlvbmApO1xuICAgICAgXG4gICAgICAvLyBTbWFsbCBkZWxheSB0byBlbnN1cmUgdGhlIGRyYXdpbmcgaXMgY29tcGxldGVcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnQXR0ZW1wdGluZyB0byBjYWxsIGhhbmRsZUdlbmVyYXRpb24gYWZ0ZXIgdGltZW91dCcpO1xuICAgICAgICBpZiAodHlwZW9mIGhhbmRsZUdlbmVyYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnQ2FsbGluZyBoYW5kbGVHZW5lcmF0aW9uIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgaGFuZGxlR2VuZXJhdGlvbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2hhbmRsZUdlbmVyYXRpb24gaXMgbm90IGEgZnVuY3Rpb246JywgaGFuZGxlR2VuZXJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0sIDEwMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKCdHZW5lcmF0aW9uIG5vdCB0cmlnZ2VyZWQgYmVjYXVzZTonLCB7IFxuICAgICAgICBpc1BlblRvb2w6IGN1cnJlbnRUb29sID09PSAncGVuJyxcbiAgICAgICAgaXNQZW5jaWxUb29sOiBjdXJyZW50VG9vbCA9PT0gJ3BlbmNpbCcsXG4gICAgICAgIHdhc0RyYXdpbmc6IGlzRHJhd2luZyBcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBDaGVjayBpZiB3ZSBjbGlja2VkIG9uIGFuIGV4aXN0aW5nIHBvaW50IG9yIGhhbmRsZVxuICBjb25zdCBjaGVja0ZvclBvaW50T3JIYW5kbGUgPSAoZSkgPT4ge1xuICAgIGlmIChjdXJyZW50VG9vbCAhPT0gJ3BlbicgfHwgIXNob3dCZXppZXJHdWlkZXMgfHwgdGVtcFBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBnZXRDb29yZGluYXRlcyhlLCBjYW52YXMpO1xuICAgIHNldExhc3RNb3VzZVBvcyh7IHgsIHkgfSk7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgd2UgY2xpY2tlZCBvbiBhIGhhbmRsZVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGVtcFBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcG9pbnQgPSB0ZW1wUG9pbnRzW2ldO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3IgaGFuZGxlSW5cbiAgICAgIGlmIChpc05lYXJIYW5kbGUocG9pbnQsICdoYW5kbGVJbicsIHgsIHkpKSB7XG4gICAgICAgIHNldEFjdGl2ZVBvaW50KGkpO1xuICAgICAgICBzZXRBY3RpdmVIYW5kbGUoJ2hhbmRsZUluJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3IgaGFuZGxlT3V0XG4gICAgICBpZiAoaXNOZWFySGFuZGxlKHBvaW50LCAnaGFuZGxlT3V0JywgeCwgeSkpIHtcbiAgICAgICAgc2V0QWN0aXZlUG9pbnQoaSk7XG4gICAgICAgIHNldEFjdGl2ZUhhbmRsZSgnaGFuZGxlT3V0Jyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3IgdGhlIGFuY2hvciBwb2ludCBpdHNlbGZcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KChwb2ludC54IC0geCkgKiogMiArIChwb2ludC55IC0geSkgKiogMik7XG4gICAgICBpZiAoZGlzdGFuY2UgPD0gMTApIHtcbiAgICAgICAgc2V0QWN0aXZlUG9pbnQoaSk7XG4gICAgICAgIHNldEFjdGl2ZUhhbmRsZShudWxsKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgXG4gIC8vIEhhbmRsZSBtb3VzZSBtb3ZlIGZvciBiZXppZXIgY29udHJvbCBwb2ludCBvciBoYW5kbGUgZHJhZ2dpbmdcbiAgY29uc3QgaGFuZGxlQmV6aWVyTW91c2VNb3ZlID0gKGUpID0+IHtcbiAgICBpZiAoY3VycmVudFRvb2wgIT09ICdwZW4nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0Q29vcmRpbmF0ZXMoZSwgY2FudmFzKTtcbiAgICBjb25zdCBkeCA9IHggLSBsYXN0TW91c2VQb3MueDtcbiAgICBjb25zdCBkeSA9IHkgLSBsYXN0TW91c2VQb3MueTtcbiAgICBcbiAgICAvLyBJZiB3ZSdyZSBkcmFnZ2luZyBhIGhhbmRsZVxuICAgIGlmIChhY3RpdmVQb2ludCAhPT0gLTEgJiYgYWN0aXZlSGFuZGxlKSB7XG4gICAgICBjb25zdCBuZXdQb2ludHMgPSBbLi4udGVtcFBvaW50c107XG4gICAgICB1cGRhdGVIYW5kbGUobmV3UG9pbnRzW2FjdGl2ZVBvaW50XSwgYWN0aXZlSGFuZGxlLCBkeCwgZHksIHN5bW1ldHJpYyk7XG4gICAgICBzZXRUZW1wUG9pbnRzKG5ld1BvaW50cyk7XG4gICAgICBzZXRMYXN0TW91c2VQb3MoeyB4LCB5IH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIC8vIElmIHdlJ3JlIGRyYWdnaW5nIGFuIGFuY2hvciBwb2ludFxuICAgIGlmIChhY3RpdmVQb2ludCAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IG5ld1BvaW50cyA9IFsuLi50ZW1wUG9pbnRzXTtcbiAgICAgIG5ld1BvaW50c1thY3RpdmVQb2ludF0ueCArPSBkeDtcbiAgICAgIG5ld1BvaW50c1thY3RpdmVQb2ludF0ueSArPSBkeTtcbiAgICAgIFxuICAgICAgLy8gSWYgdGhpcyBwb2ludCBoYXMgaGFuZGxlcywgbW92ZSB0aGVtIHdpdGggdGhlIHBvaW50XG4gICAgICBpZiAobmV3UG9pbnRzW2FjdGl2ZVBvaW50XS5oYW5kbGVJbikge1xuICAgICAgICAvLyBObyBuZWVkIHRvIGNoYW5nZSB0aGUgaGFuZGxlJ3Mgb2Zmc2V0LCBqdXN0IG1vdmUgd2l0aCB0aGUgcG9pbnRcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKG5ld1BvaW50c1thY3RpdmVQb2ludF0uaGFuZGxlT3V0KSB7XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gY2hhbmdlIHRoZSBoYW5kbGUncyBvZmZzZXQsIGp1c3QgbW92ZSB3aXRoIHRoZSBwb2ludFxuICAgICAgfVxuICAgICAgXG4gICAgICBzZXRUZW1wUG9pbnRzKG5ld1BvaW50cyk7XG4gICAgICBzZXRMYXN0TW91c2VQb3MoeyB4LCB5IH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvLyBIYW5kbGUgY2xpY2tzIGZvciBiZXppZXIgY3VydmUgdG9vbFxuICBjb25zdCBoYW5kbGVQZW5Ub29sQ2xpY2sgPSAoZSkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0Q29vcmRpbmF0ZXMoZSwgY2FudmFzKTtcbiAgICBcbiAgICAvLyBBZGQgYSBuZXcgcG9pbnRcbiAgICBpZiAodGVtcFBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIEZpcnN0IHBvaW50IGhhcyBubyBoYW5kbGVzIGluaXRpYWxseVxuICAgICAgY29uc3QgbmV3UG9pbnQgPSB7IHgsIHksIGhhbmRsZUluOiBudWxsLCBoYW5kbGVPdXQ6IG51bGwgfTtcbiAgICAgIHNldFRlbXBQb2ludHMoW25ld1BvaW50XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBwb2ludCB3aXRoIGhhbmRsZXMgcmVsYXRpdmUgdG8gdGhlIGxhc3QgcG9pbnRcbiAgICAgIGNvbnN0IG5ld1BvaW50ID0gY3JlYXRlQW5jaG9yUG9pbnQoeCwgeSwgdGVtcFBvaW50c1t0ZW1wUG9pbnRzLmxlbmd0aCAtIDFdKTtcbiAgICAgIHNldFRlbXBQb2ludHMoWy4uLnRlbXBQb2ludHMsIG5ld1BvaW50XSk7XG4gICAgfVxuICAgIFxuICAgIC8vIEFsd2F5cyBzaG93IGd1aWRlcyB3aGVuIGFkZGluZyBwb2ludHNcbiAgICBzZXRTaG93QmV6aWVyR3VpZGVzKHRydWUpO1xuICB9O1xuICBcbiAgLy8gVG9nZ2xlIGJlemllciBndWlkZSB2aXNpYmlsaXR5XG4gIGNvbnN0IHRvZ2dsZUJlemllckd1aWRlcyA9ICgpID0+IHtcbiAgICBzZXRTaG93QmV6aWVyR3VpZGVzKCFzaG93QmV6aWVyR3VpZGVzKTtcbiAgICBpZiAoc2hvd0Jlemllckd1aWRlcykge1xuICAgICAgcmVkcmF3QmV6aWVyR3VpZGVzKCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIERyYXcgdGhlIGZpbmFsIGJlemllciBjdXJ2ZSBhbmQgY2xlYXIgY29udHJvbCBwb2ludHNcbiAgY29uc3QgZmluYWxpemVCZXppZXJDdXJ2ZSA9ICgpID0+IHtcbiAgICBpZiAodGVtcFBvaW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAvLyBOZWVkIGF0IGxlYXN0IDIgcG9pbnRzIGZvciBhIHBhdGhcbiAgICAgIGNvbnNvbGUubG9nKCdOZWVkIGF0IGxlYXN0IDIgY29udHJvbCBwb2ludHMgdG8gZHJhdyBhIHBhdGgnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgXG4gICAgLy8gRHJhdyB0aGUgYWN0dWFsIGJlemllciBjdXJ2ZVxuICAgIGRyYXdCZXppZXJDdXJ2ZShjYW52YXMsIHRlbXBQb2ludHMpO1xuICAgIFxuICAgIC8vIEhpZGUgZ3VpZGVzIGFuZCByZXNldCBjb250cm9sIHBvaW50c1xuICAgIHNldFNob3dCZXppZXJHdWlkZXMoZmFsc2UpO1xuICAgIHNldFRlbXBQb2ludHMoW10pO1xuICAgIFxuICAgIC8vIFRyaWdnZXIgZ2VuZXJhdGlvblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBoYW5kbGVHZW5lcmF0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGhhbmRsZUdlbmVyYXRpb24oKTtcbiAgICAgIH1cbiAgICB9LCAxMDApO1xuICB9O1xuXG4gIC8vIEFkZCBjb250cm9sIHBvaW50IHRvIHNlZ21lbnRcbiAgY29uc3QgYWRkQ29udHJvbFBvaW50ID0gKGUpID0+IHtcbiAgICBpZiAoY3VycmVudFRvb2wgIT09ICdwZW4nIHx8IHRlbXBQb2ludHMubGVuZ3RoIDwgMikgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0Q29vcmRpbmF0ZXMoZSwgY2FudmFzKTtcbiAgICBcbiAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IHNlZ21lbnQgdG8gYWRkIGEgcG9pbnQgdG9cbiAgICBsZXQgY2xvc2VzdERpc3RhbmNlID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGxldCBpbnNlcnRJbmRleCA9IC0xO1xuICAgIFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGVtcFBvaW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIGNvbnN0IHAxID0gdGVtcFBvaW50c1tpXTtcbiAgICAgIGNvbnN0IHAyID0gdGVtcFBvaW50c1tpICsgMV07XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSBkaXN0YW5jZSBmcm9tIGNsaWNrIHRvIGxpbmUgYmV0d2VlbiBwb2ludHNcbiAgICAgIC8vIFRoaXMgaXMgYSBzaW1wbGlmaWVkIGRpc3RhbmNlIGNhbGN1bGF0aW9uIGZvciBkZW1vIHB1cnBvc2VzXG4gICAgICBjb25zdCBsaW5lTGVuZ3RoID0gTWF0aC5zcXJ0KChwMi54IC0gcDEueCkgKiogMiArIChwMi55IC0gcDEueSkgKiogMik7XG4gICAgICBpZiAobGluZUxlbmd0aCA9PT0gMCkgY29udGludWU7XG4gICAgICBcbiAgICAgIC8vIFByb2plY3QgcG9pbnQgb250byBsaW5lXG4gICAgICBjb25zdCB0ID0gKCh4IC0gcDEueCkgKiAocDIueCAtIHAxLngpICsgKHkgLSBwMS55KSAqIChwMi55IC0gcDEueSkpIC8gKGxpbmVMZW5ndGggKiBsaW5lTGVuZ3RoKTtcbiAgICAgIFxuICAgICAgLy8gSWYgcHJvamVjdGlvbiBpcyBvdXRzaWRlIHRoZSBsaW5lIHNlZ21lbnQsIHNraXBcbiAgICAgIGlmICh0IDwgMCB8fCB0ID4gMSkgY29udGludWU7XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSBjbG9zZXN0IHBvaW50IG9uIGxpbmVcbiAgICAgIGNvbnN0IGNsb3Nlc3RYID0gcDEueCArIHQgKiAocDIueCAtIHAxLngpO1xuICAgICAgY29uc3QgY2xvc2VzdFkgPSBwMS55ICsgdCAqIChwMi55IC0gcDEueSk7XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSBkaXN0YW5jZSB0byBjbG9zZXN0IHBvaW50XG4gICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydCgoeCAtIGNsb3Nlc3RYKSAqKiAyICsgKHkgLSBjbG9zZXN0WSkgKiogMik7XG4gICAgICBcbiAgICAgIGlmIChkaXN0YW5jZSA8IGNsb3Nlc3REaXN0YW5jZSAmJiBkaXN0YW5jZSA8IDIwKSB7XG4gICAgICAgIGNsb3Nlc3REaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICBpbnNlcnRJbmRleCA9IGkgKyAxO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBpZiAoaW5zZXJ0SW5kZXggPiAwKSB7XG4gICAgICAvLyBDcmVhdGUgYSBuZXcgYXJyYXkgd2l0aCB0aGUgbmV3IHBvaW50IGluc2VydGVkXG4gICAgICBjb25zdCBuZXdQb2ludHMgPSBbLi4udGVtcFBvaW50c107XG4gICAgICBjb25zdCBwcmV2UG9pbnQgPSBuZXdQb2ludHNbaW5zZXJ0SW5kZXggLSAxXTtcbiAgICAgIGNvbnN0IG5leHRQb2ludCA9IG5ld1BvaW50c1tpbnNlcnRJbmRleF07XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBwb2ludCBhdCB0aGUgY2xpY2sgcG9zaXRpb24gd2l0aCBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZWQgaGFuZGxlc1xuICAgICAgY29uc3QgbmV3UG9pbnQgPSB7IFxuICAgICAgICB4LCBcbiAgICAgICAgeSxcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGhhbmRsZXMgYmFzZWQgb24gdGhlIHBvc2l0aW9ucyBvZiBhZGphY2VudCBwb2ludHNcbiAgICAgICAgaGFuZGxlSW46IHsgXG4gICAgICAgICAgeDogKHByZXZQb2ludC54IC0geCkgKiAwLjI1LCBcbiAgICAgICAgICB5OiAocHJldlBvaW50LnkgLSB5KSAqIDAuMjUgXG4gICAgICAgIH0sXG4gICAgICAgIGhhbmRsZU91dDogeyBcbiAgICAgICAgICB4OiAobmV4dFBvaW50LnggLSB4KSAqIDAuMjUsIFxuICAgICAgICAgIHk6IChuZXh0UG9pbnQueSAtIHkpICogMC4yNSBcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gSW5zZXJ0IHRoZSBuZXcgcG9pbnRcbiAgICAgIG5ld1BvaW50cy5zcGxpY2UoaW5zZXJ0SW5kZXgsIDAsIG5ld1BvaW50KTtcbiAgICAgIHNldFRlbXBQb2ludHMobmV3UG9pbnRzKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInJlbGF0aXZlXCI+XG4gICAgICB7Y3VycmVudFRvb2wgPT09ICdwZW4nICYmIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtd3JhcCBtYi0yIGdhcC0yXCI+XG4gICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBvbkNsaWNrPXt0b2dnbGVCZXppZXJHdWlkZXN9XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJweC0yIHB5LTEgYmctYmx1ZS01MDAgdGV4dC13aGl0ZSByb3VuZGVkIHRleHQtc21cIlxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtzaG93QmV6aWVyR3VpZGVzID8gJ0hpZGUgR3VpZGVzJyA6ICdTaG93IEd1aWRlcyd9XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgXG4gICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRTeW1tZXRyaWMoIXN5bW1ldHJpYyl9XG4gICAgICAgICAgICBjbGFzc05hbWU9e2BweC0yIHB5LTEgJHtzeW1tZXRyaWMgPyAnYmctZ3JlZW4tNTAwJyA6ICdiZy1ncmF5LTUwMCd9IHRleHQtd2hpdGUgcm91bmRlZCB0ZXh0LXNtYH1cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7c3ltbWV0cmljID8gJ1N5bW1ldHJpYyBIYW5kbGVzJyA6ICdGcmVlIEhhbmRsZXMnfVxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgIFxuICAgICAgICAgIHt0ZW1wUG9pbnRzLmxlbmd0aCA+PSAyICYmIChcbiAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgIG9uQ2xpY2s9e2ZpbmFsaXplQmV6aWVyQ3VydmV9XG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cInB4LTIgcHktMSBiZy1ncmVlbi01MDAgdGV4dC13aGl0ZSByb3VuZGVkIHRleHQtc21cIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICBEcmF3IFBhdGhcbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICl9XG4gICAgICAgICAgXG4gICAgICAgICAge3RlbXBQb2ludHMubGVuZ3RoID4gMCAmJiAoXG4gICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRUZW1wUG9pbnRzKFtdKX1cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwicHgtMiBweS0xIGJnLXJlZC01MDAgdGV4dC13aGl0ZSByb3VuZGVkIHRleHQtc21cIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICBDbGVhciBQb2ludHNcbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICl9XG4gICAgICAgICAgXG4gICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC1zbSBtbC0yXCI+XG4gICAgICAgICAgICB7dGVtcFBvaW50cy5sZW5ndGh9IHBvaW50e3RlbXBQb2ludHMubGVuZ3RoICE9PSAxID8gJ3MnIDogJyd9IFxuICAgICAgICAgICAge3RlbXBQb2ludHMubGVuZ3RoID49IDIgPyAnIChyZWFkeSknIDogJyAobmVlZCAyKyknfVxuICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICBcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCB0ZXh0LXhzIHRleHQtZ3JheS02MDAgbXQtMVwiPlxuICAgICAgICAgICAgVGlwOiBDbGljayB0byBhZGQgcG9pbnRzLCBjbGljayArIGRyYWcgaGFuZGxlcyB0byBhZGp1c3QgY3VydmVzLCBkb3VibGUtY2xpY2sgb24gc2VnbWVudHMgdG8gYWRkIHBvaW50c1xuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG4gICAgICBcbiAgICAgIDxjYW52YXNcbiAgICAgICAgcmVmPXtjYW52YXNSZWZ9XG4gICAgICAgIHdpZHRoPXs5NjB9XG4gICAgICAgIGhlaWdodD17NTQwfVxuICAgICAgICBvbk1vdXNlRG93bj17KGUpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnQ2FudmFzIG9uTW91c2VEb3duJywgeyBjdXJyZW50VG9vbCwgaXNEcmF3aW5nIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEZvciBwZW4gKGJlemllcikgdG9vbCwgaGFuZGxlIGRpZmZlcmVudGx5XG4gICAgICAgICAgaWYgKGN1cnJlbnRUb29sID09PSAncGVuJykge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UgY2xpY2tlZCBvbiBhbiBleGlzdGluZyBwb2ludCBvciBoYW5kbGVcbiAgICAgICAgICAgIGlmICghY2hlY2tGb3JQb2ludE9ySGFuZGxlKGUpKSB7XG4gICAgICAgICAgICAgIC8vIElmIG5vdCBpbnRlcmFjdGluZyB3aXRoIGV4aXN0aW5nIHBvaW50cy9oYW5kbGVzLCBhZGQgYSBuZXcgcG9pbnRcbiAgICAgICAgICAgICAgaGFuZGxlUGVuVG9vbENsaWNrKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGb3Igb3RoZXIgdG9vbHMsIHVzZSB0aGUgcmVndWxhciBkcmF3aW5nIGJlaGF2aW9yXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRXhlY3V0aW5nIHJlZ3VsYXIgc3RhcnREcmF3aW5nIGhhbmRsZXInKTtcbiAgICAgICAgICAgIHN0YXJ0RHJhd2luZyhlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH19XG4gICAgICAgIG9uTW91c2VNb3ZlPXsoZSkgPT4ge1xuICAgICAgICAgIC8vIEZvciBwZW4gKGJlemllcikgdG9vbCwgaGFuZGxlIGNvbnRyb2wgcG9pbnQvaGFuZGxlIGRyYWdnaW5nXG4gICAgICAgICAgaWYgKGN1cnJlbnRUb29sID09PSAncGVuJyAmJiBoYW5kbGVCZXppZXJNb3VzZU1vdmUoZSkpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGhhbmRsZWQgYSBiZXppZXIgZWxlbWVudCBtb3ZlLCByZXR1cm4gZWFybHlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRm9yIG90aGVyIHRvb2xzLCB1c2UgcmVndWxhciBkcmF3aW5nXG4gICAgICAgICAgZHJhdyhlKTtcbiAgICAgICAgfX1cbiAgICAgICAgb25Nb3VzZVVwPXsoZSkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdvbk1vdXNlVXAgZXZlbnQgdHJpZ2dlcmVkJywgeyBjdXJyZW50VG9vbCwgaXNEcmF3aW5nIH0pO1xuICAgICAgICAgIGhhbmRsZVN0b3BEcmF3aW5nKGUpO1xuICAgICAgICB9fVxuICAgICAgICBvbk1vdXNlTGVhdmU9eyhlKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ29uTW91c2VMZWF2ZSBldmVudCB0cmlnZ2VyZWQnLCB7IGN1cnJlbnRUb29sLCBpc0RyYXdpbmcgfSk7XG4gICAgICAgICAgaGFuZGxlU3RvcERyYXdpbmcoZSk7XG4gICAgICAgIH19XG4gICAgICAgIG9uRG91YmxlQ2xpY2s9eyhlKSA9PiB7XG4gICAgICAgICAgaWYgKGN1cnJlbnRUb29sID09PSAncGVuJykge1xuICAgICAgICAgICAgYWRkQ29udHJvbFBvaW50KGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVDYW52YXNDbGljayhlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH19XG4gICAgICAgIG9uQ2xpY2s9e2hhbmRsZUNhbnZhc0NsaWNrfVxuICAgICAgICBvblRvdWNoU3RhcnQ9e3N0YXJ0RHJhd2luZ31cbiAgICAgICAgb25Ub3VjaE1vdmU9e2RyYXd9XG4gICAgICAgIG9uVG91Y2hFbmQ9e2hhbmRsZVN0b3BEcmF3aW5nfVxuICAgICAgICBvbktleURvd249e2hhbmRsZUtleURvd259XG4gICAgICAgIHRhYkluZGV4PXswfVxuICAgICAgICBjbGFzc05hbWU9e2Bib3JkZXItMiBib3JkZXItYmxhY2sgdy1mdWxsIHNtOmgtWzYwdmhdIGgtWzMwdmhdIG1pbi1oLVszMjBweF0gYmctd2hpdGUvOTAgdG91Y2gtbm9uZSAke1xuICAgICAgICAgIGN1cnJlbnRUb29sID09PSAncGVuJyA/ICdjdXJzb3ItY3Jvc3NoYWlyJyA6ICdob3ZlcjpjdXJzb3ItY3Jvc3NoYWlyJ1xuICAgICAgICB9YH1cbiAgICAgICAgYXJpYS1sYWJlbD1cIkRyYXdpbmcgY2FudmFzXCJcbiAgICAgIC8+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBDYW52YXM7ICJdLCJuYW1lcyI6WyJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsImdldENvb3JkaW5hdGVzIiwiZHJhd0JlemllckN1cnZlIiwiZHJhd0Jlemllckd1aWRlcyIsImNyZWF0ZUFuY2hvclBvaW50IiwiaXNOZWFySGFuZGxlIiwidXBkYXRlSGFuZGxlIiwiQ2FudmFzIiwiY2FudmFzUmVmIiwiY3VycmVudFRvb2wiLCJpc0RyYXdpbmciLCJzdGFydERyYXdpbmciLCJkcmF3Iiwic3RvcERyYXdpbmciLCJoYW5kbGVDYW52YXNDbGljayIsImhhbmRsZVBlbkNsaWNrIiwiaGFuZGxlR2VuZXJhdGlvbiIsInRlbXBQb2ludHMiLCJzZXRUZW1wUG9pbnRzIiwic2hvd0Jlemllckd1aWRlcyIsInNldFNob3dCZXppZXJHdWlkZXMiLCJhY3RpdmVQb2ludCIsInNldEFjdGl2ZVBvaW50IiwiYWN0aXZlSGFuZGxlIiwic2V0QWN0aXZlSGFuZGxlIiwic3ltbWV0cmljIiwic2V0U3ltbWV0cmljIiwibGFzdE1vdXNlUG9zIiwic2V0TGFzdE1vdXNlUG9zIiwieCIsInkiLCJoYXNEcmF3aW5nIiwic2V0SGFzRHJhd2luZyIsInByZXZlbnRUb3VjaERlZmF1bHQiLCJlIiwicHJldmVudERlZmF1bHQiLCJjYW52YXMiLCJjdXJyZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsInBhc3NpdmUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY29uc29sZSIsImxvZyIsImxlbmd0aCIsInJlZHJhd0Jlemllckd1aWRlcyIsImN0eCIsImdldENvbnRleHQiLCJpbWFnZURhdGEiLCJnZXRJbWFnZURhdGEiLCJ3aWR0aCIsImhlaWdodCIsImhhc05vbldoaXRlUGl4ZWxzIiwiQXJyYXkiLCJmcm9tIiwiZGF0YSIsInNvbWUiLCJwaXhlbCIsImluZGV4IiwiZmlsbFN0eWxlIiwiZm9udCIsInRleHRBbGlnbiIsImZpbGxUZXh0IiwiaGFuZGxlS2V5RG93biIsImtleSIsImNhbnZhc0ltYWdlIiwiSW1hZ2UiLCJzcmMiLCJ0b0RhdGFVUkwiLCJvbmxvYWQiLCJjbGVhclJlY3QiLCJkcmF3SW1hZ2UiLCJoYW5kbGVTdG9wRHJhd2luZyIsImV2ZW50VHlwZSIsInR5cGUiLCJzZXRUaW1lb3V0IiwiZXJyb3IiLCJpc1BlblRvb2wiLCJpc1BlbmNpbFRvb2wiLCJ3YXNEcmF3aW5nIiwiY2hlY2tGb3JQb2ludE9ySGFuZGxlIiwiaSIsInBvaW50IiwiZGlzdGFuY2UiLCJNYXRoIiwic3FydCIsImhhbmRsZUJlemllck1vdXNlTW92ZSIsImR4IiwiZHkiLCJuZXdQb2ludHMiLCJoYW5kbGVJbiIsImhhbmRsZU91dCIsImhhbmRsZVBlblRvb2xDbGljayIsIm5ld1BvaW50IiwidG9nZ2xlQmV6aWVyR3VpZGVzIiwiZmluYWxpemVCZXppZXJDdXJ2ZSIsImFkZENvbnRyb2xQb2ludCIsImNsb3Nlc3REaXN0YW5jZSIsIk51bWJlciIsIlBPU0lUSVZFX0lORklOSVRZIiwiaW5zZXJ0SW5kZXgiLCJwMSIsInAyIiwibGluZUxlbmd0aCIsInQiLCJjbG9zZXN0WCIsImNsb3Nlc3RZIiwicHJldlBvaW50IiwibmV4dFBvaW50Iiwic3BsaWNlIiwiZGl2IiwiY2xhc3NOYW1lIiwiYnV0dG9uIiwib25DbGljayIsInNwYW4iLCJyZWYiLCJvbk1vdXNlRG93biIsIm9uTW91c2VNb3ZlIiwib25Nb3VzZVVwIiwib25Nb3VzZUxlYXZlIiwib25Eb3VibGVDbGljayIsIm9uVG91Y2hTdGFydCIsIm9uVG91Y2hNb3ZlIiwib25Ub3VjaEVuZCIsIm9uS2V5RG93biIsInRhYkluZGV4IiwiYXJpYS1sYWJlbCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/Canvas.js\n"));

/***/ })

});